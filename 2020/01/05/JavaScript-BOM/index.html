<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="符佳凤的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        JavaScript BOM - FU的博客 | FU&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<link rel="alternate" href="/atom.xml" title="FU's Blog" type="application/atom+xml">
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Fashion passes ,   style remains. </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>Jiafeng Fu</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#window对象"><span class="toc-text">window对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局作用域"><span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#窗口关系及框架"><span class="toc-text">窗口关系及框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#窗口位置"><span class="toc-text">窗口位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#窗口大小"><span class="toc-text">窗口大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#导航-amp-打开窗口"><span class="toc-text">导航 & 打开窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#间歇调用-amp-超时调用"><span class="toc-text">间歇调用 & 超时调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统对话框"><span class="toc-text">系统对话框</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location对象"><span class="toc-text">location对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查询字符串参数"><span class="toc-text">查询字符串参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#位置操作"><span class="toc-text">位置操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#assign-URL-方法"><span class="toc-text">assign(URL) 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#href-属性"><span class="toc-text">href 属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hash-、search、hostname、pathname、port-属性"><span class="toc-text">hash 、search、hostname、pathname、port 属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-方法"><span class="toc-text">replace() 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reload-方法"><span class="toc-text">reload() 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#navigator对象"><span class="toc-text">navigator对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#检测插件"><span class="toc-text">检测插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册处理程序"><span class="toc-text">注册处理程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#screen对象"><span class="toc-text">screen对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history对象"><span class="toc-text">history对象</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> Fashion passes ,   style remains. </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        JavaScript BOM
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-01-05 22:27:23</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#JavaScript高级程序设计" title="JavaScript高级程序设计">JavaScript高级程序设计</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <blockquote>
<p><strong>BOM</strong> = browser Object Model 浏览器对象模型</p>
</blockquote>
<p>BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。其中，<strong>浏览器之间共有的对象</strong> 成为了事实标准。</p>
<p>W3C 为了把浏览器中JavaScript 最基本的部分标准化，已经将 <strong>BOM的主要方面</strong> 纳入了 <strong>HTML5 的规范</strong>中。</p>
<p><br><br><br><br><br></p>
<h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>BOM 的核心对象是window，它表示 <strong>浏览器的一个实例</strong>。<br>在浏览器中，window 对象有双重角色：</p>
<ol>
<li>通过JavaScript 访问浏览器窗口的一个接口；</li>
<li>ECMAScript 规定的Global 对象。</li>
</ol>
<p><br></p>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>由于window 对象同时扮演着ECMAScript 中Global 对象的角色，因此 <strong>所有在全局作用域中声明的变量、函数 都会变成window 对象的属性和方法</strong>。</p>
<blockquote>
<p><u>定义全局变量</u> 与 <u>在window 对象上直接定义属性</u> 的差别：<br>全局变量不能通过delete 操作符删除，而直接在window 对象上定义的属性可以。</p>
</blockquote>
<ul>
<li>使用<code>var</code> 语句添加的window 属性有一个名为 <code>[[Configurable]]</code> 的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。</li>
<li>IE8及更早版本 在遇到使用delete删除window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。</li>
<li>尝试访问未声明的变量会抛出错误，但是<strong>通过 <u>查询window 对象</u>，可以知道某个可能未声明的变量是否存在</strong>。</li>
</ul>
<p><br></p>
<h4 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h4><ul>
<li>如果页面中包含框架，则每个框架都拥有自己的window 对象，并且保存在 <strong>frames 集合</strong>中。</li>
<li>在frames集合中，可以通过 <strong>数值索引</strong>（从0 开始，从左至右，从上到下）或者 <strong>框架名称</strong> 来访问相应的window 对象。</li>
<li>每个window 对象都有一个 <strong>name 属性</strong>，其中包含框架的名称（注意，除非最高层窗口是通过 <code>window.open()</code> 打开的，否则其window 对象的 <code>name</code> 属性不会包含任何值）。</li>
</ul>
<blockquote>
<p>对于 <u>在一个框架中</u> 编写的任何代码来说，其中的 <u>window 对象</u> 指向的都是 <u>那个框架的特定实例</u>，而非最高层的框架。</p>
</blockquote>
<p><strong>与框架有关的对象</strong>（window对象）：</p>
<ul>
<li><strong>top 对象</strong>：始终指向 <strong>最高（最外）层的框架</strong>，也就是浏览器窗口（使用它可以确保在一个框架中正确地访问另一个框架）；</li>
<li><strong>parent（父）对象</strong>：始终指向当前框架的 <strong>直接上层框架</strong>（在某些情况下，parent 有可能等于top；在没有框架的情况下，parent 一定等于top，此时它们都等于window）；</li>
<li><strong>self 对象</strong>：<strong>始终指向window</strong>；实际上，self 和window 对象可以互换使用（引入self 对象的目的只是为了与top 和parent 对象相对应）。</li>
</ul>
<p>以下是一个包含框架的页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"160,*"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在 <strong>最高层窗口</strong> 中，通过代码来访问上述代码中每个框架的不同方式如下：</p>
<img src="/2020/01/05/JavaScript-BOM/窗口关系.png" title="窗口关系">
<p><br></p>
<h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><blockquote>
<p>窗口相对于屏幕左边和上边的位置：</p>
<ul>
<li><strong>screenLeft</strong> 和 <strong>screenTop</strong> —— Safari、Chrome、IE、Opera；</li>
<li><strong>screenX</strong> 和 <strong>screenY</strong> —— Firefox、Safari、Chrome。</li>
</ul>
</blockquote>
<p><strong>跨浏览器获取 窗口左边和上边的位置</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：</p>
<p>在IE、Opera 中，screenLeft 和screenTop 中保存的是 <strong>从屏幕左边和上边到由window 对象表示的<u>页面可见区域</u>的距离</strong>。换句话说，如果window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox 和Safari 中，screenY 或screenTop中保存的是 <strong><u>整个浏览器窗口</u>相对于屏幕的坐标值</strong>，即在窗口的y 轴坐标为0 时返回0。</p>
<p>Firefox、Safari 和Chrome <strong>始终返回页面中每个框架的top.screenX 和top.screenY 值</strong>。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX 和screenY 每次也都会返回相同的值。而IE 和Opera 则会给出框架相对于屏幕边界的精确坐标值。</p>
<p>最终结果，就是 <strong>无法</strong> 在跨浏览器的条件下取得窗口左边和上边的精确坐标值。</p>
</blockquote>
<p>将窗口精确地移动到一个新位置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将窗口移动到屏幕左上角</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//将窗向下移动100 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//将窗口移动到(200,300)</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">//将窗口向左移动50 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">-50</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7（及更高版本）中默认就<br>是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。</p>
<p><br></p>
<h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><blockquote>
<p>跨浏览器确定一个窗口的大小不是一件简单的事。<br>IE9+、Firefox、Safari、Opera 和Chrome 均为此提供了4 个属性：<strong>innerWidth</strong>、<strong>innerHeight</strong>、<strong>outerWidth</strong> 和<strong>outerHeight</strong>。在IE9+、Safari 和Firefox中，outerWidth 和outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的window 对象还是从某个框架访问）。在Opera 中，这两个属性的值表示页面视图容器①的大小。而innerWidth 和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome 中，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。</p>
<p>IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM 提供了页面可见区域的相关信息。</p>
<p>在IE、Firefox、Safari、Opera 和Chrome 中，<strong>document.documentElement.clientWidth</strong> 和<strong>document.documentElement.clientHeight</strong> 中保存了页面视口的信息。在IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过 <strong>document.body.clientWidth</strong> 和 <strong>document.body.clientHeight</strong> 取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentElement还是document.body 中的clientWidth 和clientHeight 属性，都可以取得视口的大小。</p>
</blockquote>
<p>虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123; <span class="comment">// 标准模式</span></span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>resizeTo()</code> 和 <code>resizeBy()</code> 方法可以调整浏览器窗口的大小：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整到100×100</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//调整到200×150</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//调整到 300×300</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">300</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure></p>
<p>在Opera和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window 对象使用。</p>
<p><br></p>
<h4 id="导航-amp-打开窗口"><a href="#导航-amp-打开窗口" class="headerlink" title="导航 &amp; 打开窗口"></a>导航 &amp; 打开窗口</h4><p><strong><code>window.open()</code></strong> 方法：<br>（1）导航到一个特定的URL；<br>（2）打开一个新的浏览器窗口。</p>
<blockquote>
<p>这个方法可以接收4 个参数：</p>
<ol>
<li>要加载的URL；</li>
<li>窗口目标；</li>
<li>一个特性字符串；</li>
<li>一个表示 <u>新页面是否取代浏览器历史记录中当前加载页面</u> 的布尔值。</li>
</ol>
</blockquote>
<p>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top 或_blank。</p>
<ol>
<li><strong>弹出窗口</strong></li>
</ol>
<p>如果给 <code>window.open()</code> 传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。</p>
<p>第三个参数是一个 <strong>逗号分隔的设置字符串</strong>，表示在新窗口中都显示哪些特性。其中，名值对以<strong>等号</strong>表示（注意，整个特性字符串中 <u>不允许出现空格</u>）。</p>
<p><code>window.open()</code> 方法会返回一个指向新窗口的引用。</p>
<p>调用 <code>close()</code> 方法还可以关闭 <code>window.open()</code>  新打开的窗口。弹出窗口关闭之后，窗口的引用仍然还在，但除了检测其 <strong>closed 属性</strong>之外，已经没有其他用处了</p>
<p>新创建的window 对象有一个 <strong><code>opener</code></strong> 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window 对象（top）中有定义，而且指向调用 <code>window.open()</code> 的窗口或框架。</p>
<p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口。</p>
<blockquote>
<p>有些浏览器（如IE8 和Chrome）会在 <strong>独立的进程</strong> 中运行每个标签页。当一个标签页打开另一个标签页时，<strong>如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中</strong>。在Chrome中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页。</p>
</blockquote>
<ol>
<li><strong>弹出窗口屏蔽程序</strong></li>
</ol>
<p>如果是浏览器 <strong>内置的屏蔽程序</strong> 阻止的弹出窗口，那么 <strong>window.open()很可能会返回null</strong>。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line"><span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是 <strong>浏览器扩展或其他程序</strong> 阻止的弹出窗口，那么<code>window.open()</code>通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 <code>window.open()</code> 的调用封装在一个<code>try-catch</code> 块中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="间歇调用-amp-超时调用"><a href="#间歇调用-amp-超时调用" class="headerlink" title="间歇调用 &amp; 超时调用"></a>间歇调用 &amp; 超时调用</h4><blockquote>
<p>JavaScript 是一个<strong>单线程</strong>序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript <strong>任务队列</strong>。这些任务会按照将它们添加到队列的顺序执行。</p>
</blockquote>
<p>JavaScript 是 <strong>单线程</strong>语言，但它允许通过设置 <strong>超时值</strong> 和 <strong>间歇时间值</strong> 来调度代码 <u>在特定的时刻</u> 执行。</p>
<ol>
<li>超时调用</li>
</ol>
<p><strong>超时调用</strong> 需要使用window 对象的 <strong><code>setTimeout()</code></strong> 方法。setTimeout()的第二个参数告诉JavaScript 再过多长时间 <strong>把当前任务添加到 JavaScript任务队列</strong>中。<u>如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行</u>。</p>
<p>调用 <code>setTimeout()</code> 之后，该方法会返回一个<strong>数值ID</strong>，表示超时调用。这个超时调用ID 是<strong>计划执行代码的唯一标识符</strong>，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 <code>clearTimeout()</code> 方法并将相应的超时调用ID 作为参数传递给它。</p>
<ol>
<li>间歇调用</li>
</ol>
<p><strong>间歇调用</strong> 的方法是 <strong><code>setInterval()</code></strong> ，它会按照 <u>指定的时间间隔</u> <strong>重复执行</strong> 代码，直至<u><strong>间歇调用被取消</strong></u>或者<u><strong>页面被卸载</strong></u>。</p>
<p>调用 <code>setInterval()</code> 方法同样也会返回一个 <strong>间歇调用ID</strong>，该ID 可用于在将来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用 <strong><code>clearInterval()</code></strong> 方法并传入相应的间歇调用ID。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">//如果执行次数达到了max 设定的值，则取消后续尚未执行的调用</span></span><br><span class="line">    <span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">        clearInterval(intervalId);</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用超时调用来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">//如果执行次数未达到max 设定的值，则设置另一次超时调用</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">        setTimeout(incrementNumber, <span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。</p>
</blockquote>
<p><br></p>
<h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><ul>
<li>浏览器通过 <code>alert()</code>、<code>confirm()</code> 和 <code>prompt()</code> 方法可以调用系统对话框向用户显示消息。</li>
<li>系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。</li>
<li>通过这几个方法打开的对话框都是 <strong>同步</strong> 和 <strong>模态</strong> 的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。</li>
</ul>
<p><br><br><br><br><br></p>
<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location 提供了与 <strong>当前窗口中加载的文档</strong> 有关的信息，还提供了一些导航功能。</p>
<p>location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document 对象的属性；换句话说，<code>window.location</code> 和 <code>document.location</code> 引用的是同一个对象。</p>
<p><strong>location 对象的作用：</strong><br>（1）保存着当前文档的信息；<br>（2）它将URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段</p>
<p><img src="en-resource://database/631:1" alt="1553e212e5f94576dba0e8d40aaa45c1.png"><br><img src="/2020/01/05/JavaScript-BOM/location对象.png" title="location对象"></p>
<p><br></p>
<h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//取得查询字符串并去掉开头的问号</span></span><br><span class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">        <span class="comment">//保存数据的对象</span></span><br><span class="line">        args = &#123;&#125;,</span><br><span class="line">        <span class="comment">//取得每一项</span></span><br><span class="line">        items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">        item = <span class="literal">null</span>,</span><br><span class="line">        name = <span class="literal">null</span>,</span><br><span class="line">        value = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">//在for 循环中使用</span></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = items.length;</span><br><span class="line">    <span class="comment">//逐个将每一项添加到args 对象中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><p>使用location 对象可以通过很多方式来改变浏览器的位置。</p>
<h5 id="assign-URL-方法"><a href="#assign-URL-方法" class="headerlink" title="assign(URL) 方法"></a>assign(URL) 方法</h5><p>立即打开新URL 并在浏览器的历史记录中生成一条记录。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="href-属性"><a href="#href-属性" class="headerlink" title="href 属性"></a>href 属性</h5><p>如果是将 <code>location.href</code> 或 <code>window.location</code> 设置为一个URL 值，也会以该值调用 <code>assign()</code>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.wrox.com"</span>;</span><br><span class="line">location.href = <span class="string">"http://www.wrox.com"</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="hash-、search、hostname、pathname、port-属性"><a href="#hash-、search、hostname、pathname、port-属性" class="headerlink" title="hash 、search、hostname、pathname、port 属性"></a>hash 、search、hostname、pathname、port 属性</h5><p>修改location 对象的属性也可以改变当前加载的页面，浏览器的历史记录中会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设初始URL 为http://www.wrox.com/WileyCDA/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/WileyCDA/"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/mydir/"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com:8080/WileyCDA/"</span></span><br><span class="line">location.port = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p>
<p>每次修改location 的属性（hash 除外），页面都会以新URL 重新加载。</p>
<blockquote>
<p>在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome 中，修改hash 的值会在浏览器的历史记录中生成一条新记录。在IE 的早期版本中，hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash 的URL 时才会被更新。</p>
</blockquote>
<h5 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h5><ul>
<li>只接受一个参数，即要导航到的URL；</li>
<li>不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面。</li>
</ul>
<h5 id="reload-方法"><a href="#reload-方法" class="headerlink" title="reload() 方法"></a>reload() 方法</h5><p>重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location.reload(); <span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line"></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure></p>
<p>位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。</p>
<p><br><br><br><br><br></p>
<h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象：识别客户端浏览器的事实标准。</p>
<p><br></p>
<h4 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h4><p>检测浏览器中是否安装了特定的插件：</p>
<ul>
<li><p>对于 <strong>非IE浏览器</strong>：<br>使用 <strong><code>plugins</code></strong> 数组，该数组中每一项都包含下列属性：</p>
<ol>
<li><strong>name</strong> ：插件的名字；</li>
<li><strong>description</strong>：插件的描述；</li>
<li><strong>filename</strong>：插件的文件名；</li>
<li><strong>length</strong>：插件所处理的 MIME 类型数量。</li>
</ol>
</li>
</ul>
<blockquote>
<p>一般来说，name 属性中会包含检测插件必需的所有信息，但有时候也不完全如此。</p>
</blockquote>
<pre><code>在检测插件时，需要像下面这样循环迭代每个插件并将插件的name 与给定的名字进行比较：
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测插件（在IE 中无效）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = name.toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasPlugin(<span class="string">"Flash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasPlugin(<span class="string">"QuickTime"</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 <strong>IE浏览器</strong>：<br>在IE 中检测插件的唯一方式就是使用专有的 <strong>ActiveXObject</strong> 类型，并<strong>尝试创建一个特定插件的实例</strong>。IE 是以 COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其 <strong>COM标识符</strong>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测IE 中的插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>典型的做法是 <u>针对每个插件分别创建检测函数</u>，而不是使用前面介绍的通用检测方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测所有浏览器中的Flash</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"Flash"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测所有浏览器中的QuickTime</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasQuickTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"QuickTime"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasFlash());</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasQuickTime());</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h4><p>Firefox 2 为navigator 对象新增了 <strong>registerContentHandler()</strong> 和 <strong>registerProtocolHandler()</strong> 方法（这两个方法是在HTML5 中定义的）。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着RSS 阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。</p>
<p><br><br><br><br><br></p>
<h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。</p>
<p><br><br><br><br><br></p>
<h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history 是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history 对象与特定的window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进。</p>
<p>使用 <strong>go()</strong> 方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个<strong>整数值</strong>。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。也可以给go()方法传递一个<strong>字符串参数</strong>，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做。</p>
<p>另外，还可以使用两个简写方法 <strong>back()</strong> 和 <strong>forward()</strong> 来代替go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。</p>
<p>history 对象还有一个 <strong>length 属性</strong>，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length 等于0。</p>
<p><br><br><br><br><br></p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/jiafengfu">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
