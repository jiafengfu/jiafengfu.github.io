<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FU&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/73cc2ea2ef5bc47deb559bec0ea4d367</icon>
  <subtitle>Fashion passes ,   style remains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fujiafeng.com/"/>
  <updated>2020-03-02T14:07:21.057Z</updated>
  <id>http://fujiafeng.com/</id>
  
  <author>
    <name>Jiafeng Fu</name>
    <email>jiafengfu@github.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识区块链</title>
    <link href="http://fujiafeng.com/2020/03/02/%E5%88%9D%E8%AF%86%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://fujiafeng.com/2020/03/02/%E5%88%9D%E8%AF%86%E5%8C%BA%E5%9D%97%E9%93%BE/</id>
    <published>2020-03-02T14:04:40.000Z</published>
    <updated>2020-03-02T14:07:21.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>钥，多音字，在密码学中读音为 <strong>yào</strong>，即发音应为 密钥（yào）、公钥（yào）、私钥（yào）。</p></blockquote><h2 id="WHAT-什么是区块链"><a href="#WHAT-什么是区块链" class="headerlink" title="WHAT - 什么是区块链"></a>WHAT - 什么是区块链</h2><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p><strong>区块</strong> 指信息块，比特币系统 <strong>大约每10分钟</strong> 就会创建一个区块（随算力的提升，会调整 hash值的难度系数，使区块创建时间维持在10分钟），其中包含了 <strong>这段时间里</strong> <strong>全网范围内</strong> 所发生的 <strong>所有交易</strong>。</p><p><strong>区块三要素</strong>： 本区块的 ID（哈希值）、若干交易单、前一区块的 ID。</p><blockquote><p><strong>创世区块</strong> 是由 中本聪 创建的 第一个区块。</p></blockquote><h4 id="区块组成"><a href="#区块组成" class="headerlink" title="区块组成"></a>区块组成</h4><p>一个区块由以下两部分组成：</p><ul><li><strong>区块头</strong>：包含 <u>区块的特征信息</u>；</li><li><strong>区块体</strong>：包含 比特币交易信息。</li></ul><p>其中，区块的特征信息 包括：</p><ul><li><strong>父区块（上一个区块）的哈希值</strong></li><li><strong>当前区块的哈希值</strong></li><li><strong>挖矿难度、Nonce随机数、时间戳</strong></li><li><strong>Merkle树根</strong></li></ul><h4 id="哈希的用处"><a href="#哈希的用处" class="headerlink" title="哈希的用处"></a>哈希的用处</h4><p><strong>哈希算法</strong>：哈希算法将任意长度的二进制值 映射为 <strong>固定长度</strong> 的较小二进制值（即哈希值）。</p><p>区块链的哈希算法是 <strong>SHA-256（安全散列算法）</strong>， 输入的明文与输出的散列数据一一对应；区块链的 <strong>哈希长度是 256位</strong>。</p><p>区块哈希的计算公式 如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Hash</span> = SHA256( 区块头 )</span><br></pre></td></tr></table></figure></p><ul><li>区块的 <strong>Hash值</strong> 是根据 <strong>区块头</strong> 计算的；</li><li>每个区块的哈希值都是不一样的，哈希值可以 <strong>唯一标识区块</strong>；</li><li><strong>区块与哈希值 一一对应</strong>，如果区块的内容改变，则其哈希值一定会改变；</li><li>除非掌握了全网 <strong>51%以上</strong> 的计算力，否则短时间内修改多个区块几乎不可能发生（不可篡改）。</li></ul><h4 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h4><p>我们将一段时间（大约10min）内发生的所有有效交易打包 并计算哈希值的过程，叫做 <strong>比特币挖矿</strong>。计算哈希值需要大量的计算，谁先计算出有效哈希，就立即广播全网，并将该区块添加至区块链，享受这个区块的全部收益（区块链奖励 + 交易提成），其他矿工将放弃此次计算。</p><p>新生成的区块必须添加在区块链中最后一个区块的后边。为了保持所有节点的一致，每当有新区块加入，所有节点都必须立即同步信息，所以 新区块的添加速度不能太快。</p><p>为了控制区块添加速度，中本聪 的设计思路是 矿工必须找到 <strong>满足特定要求</strong> 的 SHA-256 哈希值，才能创建出一个新的区块。</p><p><strong>哈希值要求</strong>：</p><ul><li>包括前一个区块头的哈希值</li><li>小于或等于 <strong>目标数</strong></li><li>包括一个称为 <strong>随机数Nonce</strong> 的数字</li><li>包括所有交易的 <strong>merkle树根</strong></li></ul><blockquote><p><strong>目标数</strong>：区块链协议规定，使用一个常量除以难度系数，可以得到目标数（target），难度系数越大，目标数就越小。不管有多少计算能力或旷工，都可以通过 <strong>动态调整难度系数</strong>，来保持 <strong>每10分钟</strong> 创造一个区块。<br><strong>Nonce数</strong>：32位的二进制数，是用于工作量证明 PoW 的计数器。当前区块的哈希由区块头唯一决定。如果要对同一个区块反复计算哈希，就意味着，区块头必须不停地变化，否则不可能算出不一样的哈希。区块头里面所有的特征值都是固定的，为了让区块头产生变化，中本聪故意增加了一个随机项，叫做 Nonce。（旷工的任务就是去猜这个 Nounce）。<br><strong>Merkle 树根数据</strong>：它能够总结区块中的所有交易，并快速归纳和校验大规模数据的完整性。</p></blockquote><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>区块中的数据就是一笔笔的 <strong>比特币交易</strong>。要进行比特币交易，就需要拥有自己的公钥和私钥（当开通比特币账户时，会生成一个比特币钱包，用来存放账户的公钥和私钥）。</p><p><strong>- 公钥和私钥</strong></p><p>在比特币系统中，私钥本质上是由 <strong>32个字节</strong> 组成的数组；公钥的长度是 <strong>512位（64字节）</strong>，不方便传播，因此规定要为公钥生成一个 <strong>160位</strong> 的易于传播的 哈希值（转换为十六进制，大约是 26~35 个字符）。</p><p>公钥是公开的，任何人都可以获取；私钥是保密的，只有拥有者才能使用。</p><blockquote><p>公钥和地址的生成 都依赖私钥。</p></blockquote><p><strong>- 比特币交易</strong></p><p>比特币交易，实质上就是 <strong>一个地址的比特币 转移到另一个地址</strong>。每个地址拥有多少比特币， 公开可查，因此可以轻易验证这笔交易是否有效。同时，为了防止有人冒名申报交易，在进行交易时，支付方需要提供以下数据：</p><ul><li>交易金额</li><li>上一笔交易的 Hash（可溯源）</li><li>本次交易的双方地址</li><li>支付方公钥</li><li>支付方私钥生成的数字签名</li></ul><p>申报交易后，这条交易信息被广播至各个节点。其他节点 <strong>验证这笔交易是否属实</strong>，需要三步：</p><ol><li>根据哈希值 找到上一笔交易，确认支付方 比特币的来源；</li><li>根据支付方公钥 计算对应的哈希值，确认与提供的支付方地址一致，从而保证公钥属实；</li><li>使用支付方公钥 解开支付方的数字签名，确认私钥属实。</li></ol><p>确认交易属实后，交易数据 就会被送至矿工那里，由矿工负责将交易写入区块链（矿工将一批交易信息打包 并计算有效哈希值，即我们所说的 挖矿）。交易一旦写入区块链即无法更改。</p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p><strong>区块链</strong> 实质上是一系列 使用密码学而产生的互相关联的数据块，每一个数据块中包含了多条 经比特币的网络交易有效确认的信息。本质上，我们可以将区块链看做一个 <strong>去中心化的 分布式账本 / 分布式数据库</strong>。</p><p>任何人都可以通过 架设服务器 加入区块链，并成为一个节点。区块链中的每个节点都是 <strong>平等的</strong>，都保存着区块链中的所有数据。当区块链中加入新区块时，所有节点将同步信息，保持区块链数据的一致性。</p><h3 id="区块的扩容"><a href="#区块的扩容" class="headerlink" title="区块的扩容"></a>区块的扩容</h3><blockquote><p>中本聪在创建区块链时，将一个区块的容量设置 <strong>1M</strong>（=1024KB =1048576 B），一笔比特币交易的大小为 <strong>250B ~ 500B</strong>。若交易大小按 250B 计算，则一个区块可包含的交易数为： 1048576 B / 250 B = 4194.3 笔交易；而一个区块的确认时间：<strong>10min</strong> （= 600s），则一个区块 <strong>每秒可处理交易数</strong>为： 4194.3 / 600 = <strong>7 个</strong>。</p><p> 若交易数据 <strong>&gt;250B</strong>，则一个区块每秒可处理交易数更少（ <strong>&lt;7个</strong> ）</p></blockquote><p>为了提高比特币交易效率，许多 <u>区块的扩容方案</u> 产生了，而由于扩容方案的不一致，就导致了区块链的分叉问题。</p><h3 id="区块链分叉"><a href="#区块链分叉" class="headerlink" title="区块链分叉"></a>区块链分叉</h3><p>当两个节点 <strong>同时</strong> 向区块链末端A后<strong>添加区块</strong>时，会形成分叉。这时，最先生成 6 个新区块的分支会成为有效的主链，这称为“<strong>六次确认</strong>”。</p><h4 id="硬分叉"><a href="#硬分叉" class="headerlink" title="硬分叉"></a>硬分叉</h4><p>定义：比特币的 <u>区块格式 / 交易格式</u> 发生改变时，未升级的节点 <strong>拒绝验证</strong> 已升级的节点产生的区块，而已升级的节点 可以验证 未升级的节点产生的区块，而后大家各自延续自己认为正确的链，所以分成两条链。</p><p>特点：</p><ul><li>硬分叉是 <strong>永久的</strong>；</li><li>没有 向前兼容性（需强制升级）；</li><li>在区块链层面 有分叉的两条链，<strong>一条旧链，一条新链</strong>；</li><li>需在某个时间点 全部同意分叉升级，不同意的将会进入旧链。</li></ul><h4 id="软分叉"><a href="#软分叉" class="headerlink" title="软分叉"></a>软分叉</h4><p>定义：比特币交易的数据结构发生改变时，未升级的节点 <strong>可以验证</strong> 已经升级的节点产生的区块，且已升级的节点也可以验证未升级的节点产生的区块。</p><p>特点：</p><ul><li>软分叉是 <strong>暂时的</strong>；</li><li>兼容性好，可不升级；</li><li>在区块链层面没有分叉的链，只是组成链的区块有新区块和旧区块之分；</li><li>相当长时间内，可暂不升级，<strong>新旧区块可并存</strong>。</li></ul><h2 id="WHY-为什么使用区块链"><a href="#WHY-为什么使用区块链" class="headerlink" title="WHY - 为什么使用区块链"></a>WHY - 为什么使用区块链</h2><ul><li><strong>去中心化</strong>（分布式的 P2P网络，每个节点都具有 读/写权限）</li><li><strong>去信任</strong>（不需要具有公信力的政府或第三方机构，信任的是数学算法）</li><li><strong>可靠的数据库</strong>（不可篡改）</li><li><strong>可追溯</strong>（时间戳 + hash值 记录了每个区块的一生）</li><li><strong>集体维护</strong>（区块链 由所有节点共同维护）</li></ul><h2 id="HOW-怎么使用区块链"><a href="#HOW-怎么使用区块链" class="headerlink" title="HOW - 怎么使用区块链"></a>HOW - 怎么使用区块链</h2><h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><ol><li><strong>数据层</strong></li><li><strong>网络层</strong>：P2P网络（去中心化，节点间直接交易）</li><li><strong>共识层</strong>：通过共识机制，确认区块有效并加入区块链</li><li><strong>激励层</strong>：发行机制、分配机制（鼓励旷工挖矿）</li><li><strong>合约层</strong>：脚本代码、算法机制、智能合约</li><li><strong>应用层</strong>：区块链 +</li></ol><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>常见类型：</p><ul><li><strong>公有链</strong>：全世界任何人都可读取、任何人都能在其中发送交易 且交易能够获得有效确认、任何人都能参与共识过程 的区块链（比特币、以太币 使用的就是公有链）；</li><li><strong>私有链</strong>：写入权限仅在 一个组织 手中的区块链（没有去中心化）；</li><li><strong>联盟链</strong>：指共识过程受到 <strong>预选节点</strong> 控制的区块链，即若干机构共同参与管理区块链，每个机构运行着一个或多个节点（部分去中心化），超过 2/3 的机构确认即可使区块生效（<strong>2/3确认</strong>，可控性较强）（比如，R3联盟）。</li></ul><h3 id="发展脉络"><a href="#发展脉络" class="headerlink" title="发展脉络"></a>发展脉络</h3><ol><li>区块链 1.0 - <strong>可编程货币</strong>（比特币）</li><li>区块链 2.0 - <strong>可编程金融</strong>（智能合约）</li><li>区块链 3.0 - <strong>可编程社会</strong>（DAPP）</li></ol><h3 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h3><p><strong>共识过程</strong> 决定哪个区块可被添加到区块链中，也能让参与者明确当前状态。</p><p>共识机制如下：</p><ul><li><strong>工作量证明 PoW</strong></li><li><strong>权益证明 PoS</strong></li><li><strong>股份授权证明 DPoS</strong></li><li>投注共识</li><li>瑞波共识机制</li><li>Pool 验证池</li><li>实用拜占庭容错</li><li>授权拜占庭容错</li><li>帕克索斯算法</li></ul><h3 id="智能合约（Smart-Contract）"><a href="#智能合约（Smart-Contract）" class="headerlink" title="智能合约（Smart Contract）"></a>智能合约（Smart Contract）</h3><p>智能合约 是 以太坊（Ethereum） 网络上的一种特殊账户，其中包含：</p><ul><li><strong>以太坊地址</strong>（账户的唯一标识符）</li><li><strong>以太币余额</strong>（这意味着代码可以 拥有、管理资金；若代码有误，则资金会被错误处理）</li><li><strong>状态</strong>（即 智能合约中声明的所有变量 和 变量的当前状态）</li><li><strong>代码</strong>（指 编译后可在 <u>以太坊客户端和节点</u> 运行的<strong>字节码</strong>）</li></ul><p>智能合约通过可编程特性，使得达到触发条件时，可以自动触发执行合约。</p><blockquote><p>有趣的是，智能合约 还可以调用其他智能合约， 这使得 自动化代理 的实现成为可能，可为各种行业提供去中心化的解决方案。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;钥，多音字，在密码学中读音为 &lt;strong&gt;yào&lt;/strong&gt;，即发音应为 密钥（yào）、公钥（yào）、私钥（yào）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;WHAT-什么是区块链&quot;&gt;&lt;a href=&quot;#WHAT-什么是
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://fujiafeng.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>CSS 选择器</title>
    <link href="http://fujiafeng.com/2020/02/26/CSS-%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://fujiafeng.com/2020/02/26/CSS-%E9%80%89%E6%8B%A9%E5%99%A8/</id>
    <published>2020-02-26T12:36:55.000Z</published>
    <updated>2020-02-26T13:10:14.330Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>顾名思义，选择器 就是 <strong>通过表达式，选中<u>一系列的元素</u></strong><br>&emsp;&emsp;expression =&gt; Array<element></element></p></blockquote><h1 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h1><h2 id="标签-类型选择器"><a href="#标签-类型选择器" class="headerlink" title="标签/类型选择器"></a>标签/类型选择器</h2><blockquote><p>以 <strong>HTML标签</strong> 作为 CSS规则 的选择器</p></blockquote><p>语法如下：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">元素 </span><span class="template-variable">&#123; 样式声明 &#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><ul><li>通过设置元素的 class属性，为元素指定类名；</li><li>文档中可为 <strong>多个元素</strong> 指定相同的类名；</li><li>类选择器以 <strong>英文句号（.）</strong> 开头</li></ul><p><br></p><h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><ul><li>通过设置元素的 id属性，为元素指定id；</li><li>每个 id在文档中必须 <strong>唯一</strong>；</li><li>id 选择器以 <strong>井号（#）</strong> 开头。</li></ul><p><br></p><h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><blockquote><p>使用 <strong>星号（*）</strong> 来表示“<strong>任意元素</strong>”</p></blockquote><p>CSS3 中，<u>* 可与 命名空间</u> 组合使用：</p><ul><li><code>ns|*</code> - 匹配 <strong>ns</strong> 命名空间下的所有元素</li><li><code>*|*</code> - 匹配 <strong>所有</strong> 命名空间下的所有元素</li><li><code>|*</code> - 匹配 所有 <strong>没有命名空间</strong> 的元素</li></ul><p>语法如下，选中页面中所有元素：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><blockquote><p>通过 <strong>已存在的 属性名 / 属性值</strong> 匹配元素。</p></blockquote><p>语法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示带有以 attr 命名的属性的元素 */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr]</span> &#123; <span class="attribute">property</span>: value; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表示带有以 attr 命名的属性，且属性值为 value 的元素 */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr=value]</span> &#123; <span class="attribute">property</span>: value; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表示带有以 attr 命名的属性的元素，且该属性是一个 以空格作为分隔 的值列表，其中至少有一个值为 value */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr~=value]</span> &#123; <span class="attribute">property</span>: value; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表示带有以 attr 命名的属性的元素，属性值为value 或以‘value-’为前缀（常用来匹配语言简写代码） */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr|=value]</span> &#123; <span class="attribute">property</span>: value; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表示带有以 attr 命名的属性，且属性值以 value开头的元素 */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr^=value]</span> &#123; <span class="attribute">property</span>: value; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表示带有以 attr 命名的属性，且属性值以 value结尾的元素 */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr$=value]</span> &#123; <span class="attribute">property</span>: value; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表示带有以 attr 命名的属性，且属性值 包含 value的元素 */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr*=value]</span> &#123; <span class="attribute">property</span>: value; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在属性选择器的右方括号前添加一个 用空格隔开的字母 i 或 I ，可在匹配属性值时 忽略大小写 */</span></span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-attr">[attr operator value i]</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：与 JS 不同，CSS 可以在 <strong>不使用双引号</strong> 的情况下，直接使用 <strong>带连字符（-）</strong> 的属性名。</p></blockquote><p><br><br><br></p><h1 id="伪选择器"><a href="#伪选择器" class="headerlink" title="伪选择器"></a>伪选择器</h1><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><blockquote><p>CSS 伪类（Pseudo-class）用来 <strong>根据元素状态 改变样式</strong>。</p></blockquote><p>语法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-pseudo">:pseudo-class</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><p>常用 <strong>伪类列表</strong>：</p><ul><li><strong><code>:link</code></strong></li><li><strong><code>:visited</code></strong></li><li><strong><code>:active</code></strong></li><li><strong><code>:hover</code></strong></li><li><strong><code>:focus</code></strong></li><li><strong><code>:focus-within</code></strong></li><li><strong><code>:first-child</code></strong></li><li><strong><code>:nth-child</code></strong></li><li><strong><code>:nth-last-child</code></strong></li><li><strong><code>:nth-of-type</code></strong></li><li><strong><code>:first-of-type</code></strong></li><li><strong><code>:last-of-type</code></strong></li><li><strong><code>:empty</code></strong></li><li><strong><code>:target</code></strong></li><li><strong><code>:checked</code></strong></li><li><strong><code>:enabled</code></strong></li><li><strong><code>:disabled</code></strong></li></ul><p><br></p><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><blockquote><p>CSS 伪元素（Pseudo-elements）是一个 附加至选择器末尾的关键词，用于 <strong>对被选择元素的特定部分 设置特殊效果</strong>。</p></blockquote><p>语法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-pseudo">::pseudo-element</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><p>CSS 类 可与 伪元素 配合使用：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span><span class="selector-pseudo">::pseudo-element</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：</p><ol><li>一个选择器 只能使用一个伪元素；</li><li>伪元素 必须紧跟在 简单选择器 之后。</li></ol><p><br></p><h3 id="before-伪元素"><a href="#before-伪元素" class="headerlink" title="::before 伪元素"></a>::before 伪元素</h3><blockquote><p>::before创建一个伪元素，作为 <strong>选中的元素的第一个子元素</strong>，常通过 <code>content</code> 属性为元素添加 修饰性的内容。此元素默认为 <strong>行内元素</strong>。</p></blockquote><p>语法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS3 语法 */</span></span><br><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CSS2 语法（单冒号，仅用来支持 IE8） */</span></span><br><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">:before</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在每一个元素前插入 content内容 */</span></span><br><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content</span>: <span class="string">"♥"</span>; &#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="after-伪元素"><a href="#after-伪元素" class="headerlink" title="::after 伪元素"></a>::after 伪元素</h3><blockquote><p>::after 创建一个伪元素，作为 <strong>已选中元素的最后一个子元素</strong>，常通过 <code>content</code> 属性为该元素添加装饰内容。这个虚拟元素默认是 <strong>行内元素</strong>。</p></blockquote><p>语法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS3 语法 */</span></span><br><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CSS2 语法（用来支持 IE8） */</span></span><br><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">:after</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：由 <code>::before</code> 和 <code>::after</code> 生成的伪元素 <strong>包含在元素格式框内</strong>，因此 <strong>不能应用在 替换元素</strong>（如 <code>&lt;img&gt;</code>、<code>&lt;br&gt;</code> 元素）上。</p></blockquote><p><br></p><h3 id="first-letter-伪元素"><a href="#first-letter-伪元素" class="headerlink" title="::first-letter 伪元素"></a>::first-letter 伪元素</h3><blockquote><p>匹配 <strong>块级元素的第一行的第一个字母</strong>，且文字所处的行之前 没有其他内容（图片、内联表格等）。</p></blockquote><p>语法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">::first-letter</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><p> 可用属性：</p><ul><li><code>font properties</code>、</li><li><code>color properties</code>、</li><li><code>background properties</code>、</li><li><code>margin properties</code>、</li><li><code>padding properties</code>、</li><li><code>border properties</code>、</li><li><code>text-decoration</code>、</li><li><code>vertical-align</code>（<em>float 为 none 时</em>）、</li><li><code>text-transform</code>、</li><li><code>line-height</code>、</li><li><code>float</code>、</li><li><code>clear</code></li></ul><p><br></p><h3 id="first-line-伪元素"><a href="#first-line-伪元素" class="headerlink" title="::first-line 伪元素"></a>::first-line 伪元素</h3><blockquote><p>用于向 <strong>文本的首行</strong> 设置特殊样式，只能用于 <strong>块级元素</strong>。</p></blockquote><p>语法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">::first-line</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><p>可用属性：</p><ul><li><code>font</code>、</li><li><code>color</code>、</li><li><code>background</code>、</li><li><code>word-spacing</code>、</li><li><code>letter-spacing</code>、</li><li><code>text-decoration</code>、</li><li><code>vertical-align</code>、</li><li><code>text-transform</code>、</li><li><code>line-height</code>、</li><li><code>clear</code></li></ul><p><br></p><h3 id="cue-伪元素"><a href="#cue-伪元素" class="headerlink" title="::cue 伪元素"></a>::cue 伪元素</h3><blockquote><p>::cue 匹配所选元素中的 WebVTT（网络视频轨道格式） 提示，用于 在VTT 轨道媒体中使用字幕。</p></blockquote><p>语法如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::cue | ::cue( &lt;selector&gt; ) &#123; property: value; &#125;</span><br></pre></td></tr></table></figure></p><p>设置提示样式，使文本为白色、背景为半透明黑盒，示例如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::cue</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>( 0, 0, 0, 0.6 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>延伸：<strong>WebVTT</strong> = Web Video Text Tracks Format ，<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API" target="_blank" rel="noopener">查看详情</a>。</p></blockquote><p><br></p><h3 id="selection-伪元素"><a href="#selection-伪元素" class="headerlink" title="::selection 伪元素"></a>::selection 伪元素</h3><blockquote><p>::selection 应用于 文档中被用户高亮的部分（被鼠标/其他选择设备 选中的部分）</p></blockquote><p>语法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::selection</span> &#123; <span class="attribute">property</span>: value; &#125;</span><br></pre></td></tr></table></figure></p><p>可用属性：</p><ul><li>color</li><li>background-color</li><li>cursor</li><li>caret-color</li><li>outline</li><li>text-decoration 等相关属性</li><li>text-emphasis-color</li><li>text-shadow</li></ul><p>示例如下：<br><img src="/2020/02/26/CSS-选择器/selection伪元素.png" title="selection伪元素"></p><img src="/2020/02/26/CSS-选择器/selection伪元素2.png" title="selection伪元素"><p><br></p><h3 id="slotted-伪元素"><a href="#slotted-伪元素" class="headerlink" title="::slotted() 伪元素"></a>::slotted() 伪元素</h3><blockquote><p>::slotted() 用于选定 <strong>被放置在 HTML模板中的元素</strong>。</p></blockquote><p>语法如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">::slotted( &lt;compound-selector-list&gt; )  &#123; property:</span> value; &#125;</span><br></pre></td></tr></table></figure></p><p>注意：</p><ol><li>IE 浏览器不支持；</li><li>仅适用于 影子节点树（Shadow Dom）;</li><li>只选择 实际的元素节点，而不包括文本节点；</li><li>延伸阅读：<a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" target="_blank" rel="noopener">Shadow DOM</a>。</li></ol><p><br><br><br></p><h1 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h1><h2 id="后代选择器（A-B）"><a href="#后代选择器（A-B）" class="headerlink" title="后代选择器（A B）"></a>后代选择器（A B）</h2><blockquote><p>匹配元素A的任一 <strong>后代元素E</strong>  (后代节点指A的子节点，子节点的子节点，以此类推)</p></blockquote><p><br></p><h2 id="子选择器（A-gt-B）"><a href="#子选择器（A-gt-B）" class="headerlink" title="子选择器（A &gt; B）"></a>子选择器（A &gt; B）</h2><blockquote><p>匹配元素A的任一 <strong>子元素E</strong> (也就是 <strong>直系后代</strong>)</p></blockquote><p><br></p><h2 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h2><h3 id="相邻兄弟选择器（A-B）"><a href="#相邻兄弟选择器（A-B）" class="headerlink" title="相邻兄弟选择器（A + B）"></a>相邻兄弟选择器（A + B）</h3><blockquote><p>匹配 元素A的任一 <strong>下一个兄弟元素B</strong></p></blockquote><p><br></p><h3 id="通用兄弟选择器（A-B）"><a href="#通用兄弟选择器（A-B）" class="headerlink" title="通用兄弟选择器（A ~ B）"></a>通用兄弟选择器（A ~ B）</h3><blockquote><p>匹配 A元素后面的 <strong>拥有共同父元素的兄弟元素B</strong></p></blockquote><p>示例如下：<br><img src="/2020/02/26/CSS-选择器/关系选择器.png" title="关系选择器示例"></p><img src="/2020/02/26/CSS-选择器/关系选择器2.png" title="关系选择器示例"><p><br><br><br></p><h1 id="选择器分组"><a href="#选择器分组" class="headerlink" title="选择器分组"></a>选择器分组</h1><p>相同样式的选择器名称，用 <strong>逗号分隔</strong> ：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="comment">/* some properties */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h1 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h1><blockquote><ol><li>多个规则 为同一元素 指定相同属性，则拥有 <strong>更高确定度</strong> 的选择器 优先级更高；</li><li>可将多个选择器组合 来提高选择器的确定度；</li><li>若元素的CSS规则冲突，且它们的确定度相同，则 <strong>后出现的规则</strong> 优先级高。</li></ol></blockquote><p><strong>id 选择器 &gt; 类选择器 &gt; 标签选择器</strong></p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;顾名思义，选择器 就是 &lt;strong&gt;通过表达式，选中&lt;u&gt;一系列的元素&lt;/u&gt;&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;expression =&amp;gt; Array&lt;element&gt;&lt;/element&gt;&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="http://fujiafeng.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs process 进程模块</title>
    <link href="http://fujiafeng.com/2020/02/14/NodeJs-process-%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9D%97/"/>
    <id>http://fujiafeng.com/2020/02/14/NodeJs-process-%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-14T08:25:10.000Z</published>
    <updated>2020-02-14T09:02:57.558Z</updated>
    
    <content type="html"><![CDATA[<p><code>process</code> 对象：</p><ul><li>全局变量，提供 当前Node.js 进程相关的信息，并对其进行控制；</li><li>始终可供 Node.js 应用程序使用，无需 <code>require()</code> 。</li></ul><p><br><br><br></p><h2 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h2><p><code>process</code> 对象是 <code>EventEmitter</code> 的实例。</p><p><br></p><h3 id="beforeExit-事件"><a href="#beforeExit-事件" class="headerlink" title="beforeExit 事件"></a><code>beforeExit</code> 事件</h3><ul><li>当 Node.js <strong>清空其事件循环</strong> 并且<strong>没有其他工作要安排</strong>时，会触发 <code>&#39;beforeExit&#39;</code> 事件。</li><li>通常，Node.js 进程将在没有调度工作时退出，但在 <code>‘beforeExit’</code>事件上注册的监听器可以进行 <strong>异步调用</strong>，从而导致 Node.js 进程继续。</li><li>调用监听器回调函数时，会将 <code>process.exitCode</code> 值作为 唯一参数 传入。</li><li>导致 <strong>显式终止</strong> 的条件，<strong>不会触发</strong> <code>&#39;beforeExit&#39;</code> 事件（调用 <code>process.exit()</code> 或 未捕获的异常）。</li></ul><img src="/2020/02/14/NodeJs-process-进程模块/beforeExit1.png" title="beforeExit"><p>执行结果如下：</p><img src="/2020/02/14/NodeJs-process-进程模块/beforeExit2.png" title="beforeExit"><p><br><br><br><br><br></p><h3 id="disconnect-事件"><a href="#disconnect-事件" class="headerlink" title="disconnect 事件"></a><code>disconnect</code> 事件</h3><p>如果使用 IPC 通道衍生 Node.js 进程，则在 IPC 通道关闭时 触发  <code>&#39;disconnect&#39;</code> 事件。</p><blockquote><p><strong>IPC</strong>，InterProcess Communication <strong>进程间通信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;process&lt;/code&gt; 对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局变量，提供 当前Node.js 进程相关的信息，并对其进行控制；&lt;/li&gt;
&lt;li&gt;始终可供 Node.js 应用程序使用，无需 &lt;code&gt;require()&lt;/code&gt; 。&lt;/li&gt;
&lt;/
      
    
    </summary>
    
    
    
      <category term="NodeJs" scheme="http://fujiafeng.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 process.env.NODE_ENV</title>
    <link href="http://fujiafeng.com/2020/01/16/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-process-env-NODE-ENV/"/>
    <id>http://fujiafeng.com/2020/01/16/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-process-env-NODE-ENV/</id>
    <published>2020-01-16T09:22:30.000Z</published>
    <updated>2020-02-14T08:18:18.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="process-env-NODE-ENV"><a href="#process-env-NODE-ENV" class="headerlink" title="process.env.NODE_ENV"></a>process.env.NODE_ENV</h3><blockquote><p>process 对象是存在 node.js 中的一个<strong>全局变量</strong>，所有模块均可调用。</p></blockquote><p><code>NODE_ENV</code> 不是 <code>process.env</code> 的自带属性，而是为了 <strong>区分开发环境（development）与生产环境（production）</strong> 而设置的变量。</p><h4 id="设置-NODE-ENV"><a href="#设置-NODE-ENV" class="headerlink" title="设置 NODE_ENV"></a>设置 NODE_ENV</h4><p>通过 <strong>cross-env 命令</strong> 来设置环境变量：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cross</span>-<span class="keyword">env</span> NODE_ENV=development</span><br></pre></td></tr></table></figure></p><p>在 scripts 脚本启动命令中设置的 <code>NODE_ENV</code> 可通过 <code>process.env.NODE_ENV</code> 直接访问（在 <code>npm run xxx</code> 执行启动命令时，设置 <code>NODE_ENV</code> 变量）。</p><p><br><br><br></p><h3 id="配置环境变量的方法"><a href="#配置环境变量的方法" class="headerlink" title="配置环境变量的方法"></a>配置环境变量的方法</h3><p>Node 中常用到的环境变量是 <code>NODE_ENV</code>，以此为例：</p><h4 id="cmd-命令"><a href="#cmd-命令" class="headerlink" title="cmd 命令"></a>cmd 命令</h4><p><strong>Windows 环境</strong><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 环境变量 是否存在</span></span><br><span class="line"><span class="builtin-name">set</span> NODE_ENV</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若不存在，添加 环境变量</span></span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">NODE_ENV</span>=production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量 追加值 set 变量名=%变量名%;变量内容</span></span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">path</span>=%path%;C:\web;C:\Tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 环境变量</span></span><br><span class="line"><span class="builtin-name">set</span> NODE_ENV=</span><br></pre></td></tr></table></figure></p><p><strong>Linux 环境（包括 Mac 环境）</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 环境变量 是否存在</span></span><br><span class="line">echo <span class="variable">$NODE_ENV</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若不存在，添加 环境变量</span></span><br><span class="line">export NODE_ENV=production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量 追加值 </span></span><br><span class="line">export path=<span class="variable">$path</span><span class="symbol">:/home/download</span><span class="symbol">:/usr/local/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 环境变量</span></span><br><span class="line">unset NODE_ENV</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有 环境变量</span></span><br><span class="line">env</span><br></pre></td></tr></table></figure></p><blockquote><p>在命令行中设置环境变量后，该环境变量的值是<strong>全局的</strong>（比如，设置 <code>NODE_ENV</code> 为 production，则所有项目下 <code>NODE_ENV</code> 都是生产环境，此时使用 <code>npm install</code>下载依赖包，只会下载 package.json 中 dependencies 配置项中的包依赖包，而不会下载 devDependencies 中的）。<br>因此，我们有时需要 删除设置的环境变量。</p></blockquote><p><br></p><h4 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin()"></a>webpack.DefinePlugin()</h4><p>DefinePlugin 允许我们创建全局变量，可在编译时进行设置。<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new webpack.DefinePlugin(&#123;</span><br><span class="line">    '<span class="attribute">process.env.NODE_ENV'</span>: JSON<span class="variable">.stringify</span>(process<span class="variable">.env</span><span class="variable">.NODE_ENV</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>我们可以在 <strong>webpack.conf.js</strong> 中通过 <code>webpack.DefinePlugin()</code> 设置 <code>process.env.NODE_ENV</code> ，当 webpack 编译时就会设置该环境变量；同时，我们在 <strong>package.json</strong> 中的 scripts中配置 <code>NODE_ENV=xxx</code> ，使项目代码打包时可以设置 <code>NODE_ENV</code> 的值：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"NODE_ENV=production webpack --progress --devtool"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="cross-env-工具包"><a href="#cross-env-工具包" class="headerlink" title="cross-env 工具包"></a>cross-env 工具包</h4><p><code>cross-env</code> 是一个 <u><strong>跨平台</strong> 地设置及使用 <strong>环境变量</strong></u> 的工具。</p><blockquote><p><strong>跨平台</strong> 指的是：不同平台下，可使用统一的指令。<br>&emsp;&emsp;我们可通过 <code>cross-env</code> 跨Win/Linux 平台设置 <code>process.env</code>值。</p><p>注意：<em>Windows不支持 <code>NODE_ENV=development</code> 这种环境变量设置方式，会报错（阻塞或异常），通过 <code>cross-env</code> 我们就能以 Unix方式设置环境变量了。</em></p></blockquote><p><br></p><h5 id="安装-cross-env"><a href="#安装-cross-env" class="headerlink" title="安装 cross-env"></a>安装 cross-env</h5><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> <span class="built_in">cross</span>-env</span><br></pre></td></tr></table></figure><p><br><br><br></p><h4 id="同时配置-webpack-和-cross-env"><a href="#同时配置-webpack-和-cross-env" class="headerlink" title="同时配置 webpack 和 cross-env"></a>同时配置 webpack 和 cross-env</h4><ul><li><p><strong>cross-env</strong> 设置NODE_ENV <strong>使webpack的配置文件可以获取该值</strong>；</p></li><li><p><strong>webpack配置文件</strong>中设置的NODE_ENV 是为了 <strong>在打包文件中获取该值</strong>。</p></li></ul><p>由此可知，我们需要做的配置如下：</p><ol><li>在<strong>package.json</strong>文件中的 <code>scripts</code> 脚本中，既要配置环境变量 <code>cross-env NODE_ENV=XXX</code>，又要指定对应的 webpack配置文件 <code>webpack --config /build/webpack.conf.js</code> ；</li><li>并在<strong>webpack配置文件</strong>中使用 <code>DefinePlugin()</code> （或 在webpack4 中可使用 <strong><code>mode</code></strong> ）设置打包文件中的环境变量 <code>NODE_ENV</code> 。</li></ol><p>关于 webpack4 的 <code>mode</code> 属性，element 源码中设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.demo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line"></span><br><span class="line">    mode: process.env.NODE_ENV,</span><br><span class="line">    </span><br><span class="line">    entry: isProd ? &#123;</span><br><span class="line">        docs: <span class="string">'./examples/entry.js'</span></span><br><span class="line">    &#125; : (isPlay ? <span class="string">'./examples/play.js'</span> : <span class="string">'./examples/entry.js'</span>),</span><br><span class="line">    </span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(process.cwd(), <span class="string">'./examples/element-ui/'</span>),</span><br><span class="line">        publicPath: process.env.CI_ENV || <span class="string">''</span>,</span><br><span class="line">        filename: <span class="string">'[name].[hash:7].js'</span>,</span><br><span class="line">        chunkFilename: isProd ? <span class="string">'[name].[hash:7].js'</span> : <span class="string">'[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">        port: <span class="number">8085</span>,</span><br><span class="line">        publicPath: <span class="string">'/'</span>,</span><br><span class="line">        hot: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>当我们设置 mode 为 development 或者 production时，webpack会自动的进行一些设置（当然设置了模式以后，webpack会自动的为项目添加一些插件）</p><blockquote><p>mode: development –&gt; process.env.NODE_ENV = development<br>&emsp;&emsp;mode: production –&gt; process.env.NODE_ENV = production<br>&emsp;&emsp;默认情况下 –&gt; process.env.NODE_ENV = production</p></blockquote><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;process-env-NODE-ENV&quot;&gt;&lt;a href=&quot;#process-env-NODE-ENV&quot; class=&quot;headerlink&quot; title=&quot;process.env.NODE_ENV&quot;&gt;&lt;/a&gt;process.env.NODE_ENV&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="源码系列" scheme="http://fujiafeng.com/tags/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
      <category term="NodeJs" scheme="http://fujiafeng.com/tags/NodeJs/"/>
    
      <category term="前端工程化" scheme="http://fujiafeng.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 npm scripts</title>
    <link href="http://fujiafeng.com/2020/01/16/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-npm-scripts/"/>
    <id>http://fujiafeng.com/2020/01/16/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-npm-scripts/</id>
    <published>2020-01-16T09:06:53.000Z</published>
    <updated>2020-01-16T09:16:51.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>将 打包、部署 等命令都封装到 npm scripts 中，通过运行 <code>npm run xxx</code> 命令可以 <strong>执行多个自定义任务</strong>：增加 scripts 中的键值对，然后用一个 <strong>总任务脚本</strong> 将相关键值对用 <code>&amp;&amp;</code> 连接起来。</p></blockquote><p><br><br><br></p><h3 id="package-json-中的-scripts"><a href="#package-json-中的-scripts" class="headerlink" title="package.json 中的 scripts"></a>package.json 中的 scripts</h3><blockquote><p>package.json 中的scripts 执行的脚本是 本地项目的 <code>/node_modules/.bin</code> 目录下的脚本。</p><p> <code>npm run</code> 会 <strong>创建一个Shell</strong>，执行指定的命令，并临时将 <code>/node_modules/.bin</code> 加入 <strong><code>PATH</code></strong> 变量，这意味着 本地模块可以直接运行。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ... </span><br><span class="line">    "scripts": &#123;</span><br><span class="line">        "serve": "vue-cli-service serve",</span><br><span class="line">        "build": "vue-cli-service build",</span><br><span class="line">        "lint": "vue-cli-service lint"</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端项目中的 package.json 文件中，<u>scripts 脚本说明</u>：</p><ul><li>执行 <strong><code>npm run &lt;scripts的key&gt;</code></strong> 相当于执行 <code>&lt;scripts的key对应的value&gt;</code></li><li><code>build</code>，<code>build:prod</code>，<code>build:sit</code> 分别为 本地环境、生产环境、测试环境 打包</li><li><code>build:doc</code>  自动生成文档</li></ul><p><u>常用配置信息</u>：</p><ul><li>【 <strong><code>cross-env</code></strong> 】跨平台设置及使用环境变量（<code>npm i --save-dev cross-env</code>）</li><li>【 <strong><code>NODE_ENV</code></strong> 】/config 下对应环境配置的 NODE_ENV 值</li><li>【 <strong><code>env_config</code></strong> 】/config 下对应环境配置的 env_config 值</li><li>【 <strong><code>node build/build.js</code></strong> 】环境入口文件</li><li>【 <strong><code>npm-run-all</code></strong> 】并行（<code>--parallel</code>）/按序（<code>--sequential</code>）执行多个脚本</li></ul><p><br><br><br></p><h3 id="控制符-amp-amp-与-amp"><a href="#控制符-amp-amp-与-amp" class="headerlink" title="控制符 &amp;&amp; 与 &amp;"></a>控制符 &amp;&amp; 与 &amp;</h3><ul><li><code>npm-run-all --parallel</code> 相当于  <code>&amp;</code>  ，并行执行</li><li><code>npm-run-all --sequential</code> 相当于  <code>&amp;&amp;</code> ，串行执行</li></ul><img src="/2020/01/16/深入解析-npm-scripts/Image1.png" title="StackOverflow相关讨论"><img src="/2020/01/16/深入解析-npm-scripts/Image2.png" title="StackOverflow相关讨论"><p><br><br><br></p><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ul><li>只能用在 <strong>开发环境</strong>（ <code>NODE_ENV=development</code> ）</li><li>用于构建 <strong>本地服务器</strong></li></ul><p>详情请见：深入解析 webpack-dev-server</p><p><br><br><br></p><h3 id="scripts-命令的hook"><a href="#scripts-命令的hook" class="headerlink" title="scripts 命令的hook"></a>scripts 命令的hook</h3><p>每个命令都有对应的 pre<scriptname>脚本 和 post<scriptname>脚本，显示定义时，会执行对应的 pre/post命令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  "prebuild" : "echo \" this is pre build \"",</span><br><span class="line">  "build" : "echo \" this is build \"",</span><br><span class="line">  "postbuild" : "echo \" this is post build \""</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></scriptname></scriptname></p><p>执行 <code>npm run build</code> 会依次执行 prebuild、build、postbuild 三个命令。</p><p>npm默认提供如下钩子：</p><ul><li>prepublish, postpublish</li><li>preinstall, postinstall</li><li>preuninstall, postuninstall</li><li>preversion, postversion</li><li>pretest, posttest</li><li>prestop, poststop</li><li>prestart, poststart</li><li>prerestart, postrestart</li></ul><p>自定义脚本命令 也可以添加钩子：<strong>pre</strong>myscript, myscript, <strong>post</strong>myscript 。</p><p><br><br><br></p><h3 id="npm命令简写"><a href="#npm命令简写" class="headerlink" title="npm命令简写"></a>npm命令简写</h3><ul><li>npm start === npm run start</li><li>npm stop === npm run stop</li><li>npm test === npm run test</li><li>npm restart === npm run restart</li></ul><p><br><br><br></p><h3 id="ElementUI-源码中的scripts"><a href="#ElementUI-源码中的scripts" class="headerlink" title="ElementUI 源码中的scripts"></a>ElementUI 源码中的scripts</h3><p>详情请见： ElementUI 源码分析 - package.json配置</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;将 打包、部署 等命令都封装到 npm scripts 中，通过运行 &lt;code&gt;npm run xxx&lt;/code&gt; 命令可以 &lt;strong&gt;执行多个自定义任务&lt;/strong&gt;：增加 scripts 中的键值对，然后用一个 &lt;strong&gt;总
      
    
    </summary>
    
    
    
      <category term="NodeJs" scheme="http://fujiafeng.com/tags/NodeJs/"/>
    
      <category term="前端工程化" scheme="http://fujiafeng.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="npm" scheme="http://fujiafeng.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>ElementUI 源码分析 - 目录结构</title>
    <link href="http://fujiafeng.com/2020/01/16/ElementUI-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://fujiafeng.com/2020/01/16/ElementUI-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2020-01-16T08:48:36.000Z</published>
    <updated>2020-01-16T08:59:03.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>ElementUI 的目录结构大致如下：<br><img src="/2020/01/16/ElementUI-源码分析-目录结构/element-content.png" title="element目录结构"></p><p>将项目 clone 下来之后，执行打包命令 生成 <code>/lib</code>  目录：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> dist</span></span><br></pre></td></tr></table></figure></p><p>该命令依次执行了以下脚本：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webpack --config build/webpack<span class="selector-class">.conf</span><span class="selector-class">.js</span> &amp;&amp;</span><br><span class="line">webpack --config build/webpack<span class="selector-class">.common</span><span class="selector-class">.js</span> &amp;&amp;</span><br><span class="line">webpack --config build/webpack<span class="selector-class">.component</span><span class="selector-class">.js</span> &amp;&amp;</span><br></pre></td></tr></table></figure></p><p>其中，webpack.conf.js 与 webpack.common.js 打包的入口文件都是 <code>src/index.js</code> ，输出文件都在 <code>/lib</code> 目录，分别是 <strong>UMD规范</strong> 和 <strong>commonjs规范</strong> ；webpack.component.js 入口文件为 components.json 中的所有组件，即 <code>/packages</code> 目录下的所有组件。</p><p><br><br><br><br><br></p><h3 id="入口文件-src-index-js"><a href="#入口文件-src-index-js" class="headerlink" title="入口文件 src/index.js"></a>入口文件 src/index.js</h3><p>src 下的入口文件index.js 实现的功能：</p><ul><li>国际化配置</li><li>组件全局注册</li><li>在 prototype 上挂载共用方法<img src="/2020/01/16/ElementUI-源码分析-目录结构/srcIndex.png" title="element入口文件"></li></ul><p><br><br><br><br><br></p><h3 id="自定义指令-src-directives"><a href="#自定义指令-src-directives" class="headerlink" title="自定义指令 src/directives"></a>自定义指令 src/directives</h3><p>主要实现了两种功能：</p><ol><li><strong>鼠标滚轮事件 mousewheel.js</strong> ： 应用在 table组件 中（如：固定表头、流体高度）。（<a href="https://github.com/basilfx/normalize-wheel" target="_blank" rel="noopener">参考链接</a> ）</li><li><strong>函数防抖 repeat-click.js</strong> ：主要用在 InputNumber 计数器中，控制用户点击频率。<img src="/2020/01/16/ElementUI-源码分析-目录结构/srcDirectives.png" title="element自定义指令"></li></ol><p><br><br><br><br><br></p><h3 id="混用-src-mixins"><a href="#混用-src-mixins" class="headerlink" title="混用 src/mixins"></a>混用 src/mixins</h3><ol><li><p><strong>emitter.js</strong><br>（1）broadcast 函数：广播 （父 -&gt; 子）；<br>（2）dispatch 函数：分发（子 -&gt; 父）<br>组件中添加 自定义属性‘componentName’</p></li><li><p><strong>focus.js</strong><br>使 DOM 元素获取焦点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">ref</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        methods: &#123;</span><br><span class="line">            focus() &#123;</span><br><span class="line">                <span class="keyword">this</span>.$refs[ref].focus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>locale.js</strong><br>国际化输出。</p></li><li><p><strong>migrating.js</strong><br>在浏览器控制台 输出 elementUI 已经移除的一些属性。</p></li></ol><img src="/2020/01/16/ElementUI-源码分析-目录结构/srcMixins.png" title="element混用"><p><br><br><br><br><br></p><h3 id="通用库-utils"><a href="#通用库-utils" class="headerlink" title="通用库 utils"></a>通用库 utils</h3><ol><li><strong>clickoutside.js</strong><br>点击元素外面 才会触发的事件</li><li><strong>date.js</strong><br>日期格式化</li><li><strong>dom.js</strong><br>对 DOM元素 进行操作，如 <code>hasClass</code>, <code>addClass</code>, <code>removeClass</code>, <code>getStyle</code>, <code>setStyle</code>, <code>on</code>, <code>off</code> 等。</li><li><strong>util.js</strong><br>定义一些常用函数：<code>hasOwn</code>, <code>getValueByPath</code>, <code>valueEquals</code> 。</li><li><strong>vdom.js</strong><br>vnode 判断，vnode获取。</li></ol><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;ElementUI 的目录结构大致如下：&lt;br&gt;&lt;img src=&quot;/2020/01/16/ElementUI-源码分析-目录结构/elem
      
    
    </summary>
    
    
    
      <category term="elementUI" scheme="http://fujiafeng.com/tags/elementUI/"/>
    
      <category term="源码系列" scheme="http://fujiafeng.com/tags/%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs path 路径模块</title>
    <link href="http://fujiafeng.com/2020/01/16/NodeJs-path-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/"/>
    <id>http://fujiafeng.com/2020/01/16/NodeJs-path-%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/</id>
    <published>2020-01-16T06:57:19.000Z</published>
    <updated>2020-01-16T07:27:35.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname( path )"></a>path.dirname( path )</h3><p>返回 path 的<strong>目录名</strong>，尾部的目录分隔符将被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.dirname(<span class="string">'/foo/bar/baz/asdf/quux'</span>);</span><br><span class="line"><span class="comment">// 返回 '/foo/bar/baz/asdf'</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="path-basename-path-ext"><a href="#path-basename-path-ext" class="headerlink" title="path.basename( path[, ext] )"></a>path.basename( path[, ext] )</h3><p>获取 <code>path</code> 的<strong>最后一部分</strong>，尾部的 目录分隔符 将被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/foo/bar/baz/asdf/quux.html'</span>);</span><br><span class="line"><span class="comment">// 返回 'quux.html'</span></span><br><span class="line"></span><br><span class="line">path.basename(<span class="string">'/foo/bar/baz/asdf/quux.html'</span>, <span class="string">'.html'</span>);</span><br><span class="line"><span class="comment">// 返回 'quux'</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname( path )"></a>path.extname( path )</h3><p>返回 path 的<strong>扩展名</strong>（从最后一个 <code>.</code> 字符到 <code>path</code> 最后一部分的字符串结束）；若 <code>path</code> 的最后一部分中没有 <code>.</code> 字符，或者 path 的基本名称除了第一个字符以外没有 <code>.</code> 字符，则返回 空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.extname(<span class="string">'.index'</span>);</span><br><span class="line"><span class="comment">// 返回 ''</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format( pathObject )"></a>path.format( pathObject )</h3><p>从对象返回路径字符串。与 <code>path.parse()</code> 相反。</p><blockquote><p>pathObject <object> = {<br>&emsp;&emsp;&emsp;&emsp;    dir: <string>,<br>&emsp;&emsp;&emsp;&emsp;    root: <string>,<br>&emsp;&emsp;&emsp;&emsp;    base: <string>,<br>&emsp;&emsp;&emsp;&emsp;    name: <string>,<br>&emsp;&emsp;&emsp;&emsp;    ext: <string><br>&emsp;&emsp;}</string></string></string></string></string></object></p></blockquote><p>pathObject 属性优先级：</p><ul><li>提供了 <code>pathObject.dir</code> ，则忽略 <code>pathObject.root</code> 。</li><li>提供了 <code>pathObject.base</code>，则忽略 <code>pathObject.ext</code> 和 <code>pathObject.name</code> 。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果提供了 `dir`、 `root` 和 `base`，</span></span><br><span class="line"><span class="comment">// 则返回 `$&#123;dir&#125;$&#123;path.sep&#125;$&#123;base&#125;`。</span></span><br><span class="line"><span class="comment">// `root` 会被忽略。</span></span><br><span class="line">path.format(&#123;</span><br><span class="line">  root: <span class="string">'/ignored'</span>,</span><br><span class="line">  dir: <span class="string">'/home/user/dir'</span>,</span><br><span class="line">  base: <span class="string">'file.txt'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回: '/home/user/dir/file.txt'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果未指定 `dir`，则使用 `root`。 </span></span><br><span class="line"><span class="comment">// 如果只提供 `root`，或 'dir` 等于 `root`，则将不包括平台分隔符。 </span></span><br><span class="line"><span class="comment">// `ext` 将被忽略。</span></span><br><span class="line">path.format(&#123;</span><br><span class="line">  root: <span class="string">'/'</span>,</span><br><span class="line">  base: <span class="string">'file.txt'</span>,</span><br><span class="line">  ext: <span class="string">'ignored'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回: '/file.txt'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果未指定 `base`，则使用 `name` + `ext`。</span></span><br><span class="line">path.format(&#123;</span><br><span class="line">  root: <span class="string">'/'</span>,</span><br><span class="line">  name: <span class="string">'file'</span>,</span><br><span class="line">  ext: <span class="string">'.txt'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回: '/file.txt'</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse( path )"></a>path.parse( path )</h3><p>返回一个对象，其属性表示 path 的重要元素。忽略 尾部的目录分隔符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path.parse(<span class="string">'/home/user/dir/file.txt'</span>);</span><br><span class="line"><span class="comment">// 返回:</span></span><br><span class="line"><span class="comment">// &#123; root: '/',</span></span><br><span class="line"><span class="comment">//   dir: '/home/user/dir',</span></span><br><span class="line"><span class="comment">//   base: 'file.txt',</span></span><br><span class="line"><span class="comment">//   ext: '.txt',</span></span><br><span class="line"><span class="comment">//   name: 'file' &#125;</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute( path )"></a>path.isAbsolute( path )</h3><p>检测 path 是否为<strong>绝对路径</strong>。零长度字符串 返回 false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.isAbsolute(<span class="string">'.'</span>);   <span class="comment">//  false</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative( from, to )"></a>path.relative( from, to )</h3><p>根据当前工作目录，返回 <strong><code>from</code> 到 <code>to</code> 的相对路径</strong>。</p><p>如果 <code>from</code> 和 <code>to</code> 各自解析到相同的路径（分别调用 <code>path.resolve()</code> 之后），则返回零长度的字符串。</p><p>如果将零长度的字符串 传入 <code>from</code> 或 <code>to</code> ，则使用 当前工作目录 代替该零长度的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.relative(<span class="string">'/fruit/orange/type1/a'</span>, <span class="string">'/fruit/orange/type2/b'</span>);</span><br><span class="line"><span class="comment">// 返回 '.. / .. / type2 / b'</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve( […paths] )"></a>path.resolve( […paths] )</h3><p>将 路径 或 路径片段 的序列，解析为<strong>绝对路径</strong>。</p><ul><li>给定的路径序列 从右到左 进行处理，每个后续的 path 前置，直到构造出一个绝对路径。</li><li>若在处理完所有给定的 path 片段之后 还未生成绝对路径，则再加上 当前工作目录。</li><li>生成的路径 已经规范化；除非将路径解析为 根目录，否则将删除尾部斜杠。</li><li>零长度的 path 片段会被忽略。</li><li>未传入 path 片段，则 <code>path.resolve()</code> 将返回 当<strong>前工作目录的绝对路径</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'./baz'</span>);</span><br><span class="line"><span class="comment">// 返回 '/foo/bar/baz'</span></span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>);</span><br><span class="line"><span class="comment">// 返回 '/tmp/file'</span></span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">'wwwroot'</span>, <span class="string">'static_files/png/'</span>, <span class="string">'../gif/image.gif'</span>);</span><br><span class="line"><span class="comment">// 如果当前工作目录是 /home/myself/node,</span></span><br><span class="line"><span class="comment">// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif'</span></span><br></pre></td></tr></table></figure><blockquote><p>path.resolve() 类似于对路径执行 <code>cd</code> 操作，不同的是，<code>resolve()</code> 的 <code>path</code> 可以是文件，且不必是真实存在的路径 （ <strong><code>resolve()</code> 方法不会利用 底层文件系统 判断路径是否存在，只是进行 路径字符串操作</strong> ）</p></blockquote><p><br><br><br><br><br></p><h3 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join( […paths] )"></a>path.join( […paths] )</h3><p>使用 <strong>平台特定分隔符</strong> 作为 界定符，将所有给定的 path 片段连接在一起，规范化生成的路径。</p><ul><li>零长度的 path 片段会被忽略。</li><li>如果连接的路径字符串是零长度的字符串，则返回 <code>&#39;.&#39;</code> ，表示 当前工作目录。</li></ul><p><br><br><br><br><br></p><h3 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h3><p>提供平台特定的 路径片段分隔符：</p><ul><li>Windows 上是 <code>\</code> 。</li><li>POSIX 上是 <code>/</code>  。</li></ul><blockquote><p>在Windows 上，正斜杠（<code>/</code>）和反斜杠（<code>\</code>）都被接受为 路径片段分隔符，但 path 方法只添加反斜杠（<code>\</code>）。</p></blockquote><p><br><br><br><br><br></p><h3 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize( path )"></a>path.normalize( path )</h3><p>规范化给定的 path，<strong>解析 <code>&#39;..&#39;</code> 和 <code>&#39;.&#39;</code> 片段</strong>。</p><p>当找到多个连续的 <strong>路径片段分隔字符</strong>（如 POSIX上的 <code>/</code>，Windows上的 <code>\</code>或 <code>/</code>），则它们将被替换为 单个 平台特定的路径段分隔符（POSIX上的 <code>/</code>，Windows上的 <code>\</code>）。保留 尾部的分隔符。</p><p><br><br><br><br><br></p><h3 id="path-toNamespacedPath-path"><a href="#path-toNamespacedPath-path" class="headerlink" title="path.toNamespacedPath( path )"></a>path.toNamespacedPath( path )</h3><p>仅在 Windows 系统上，返回给定 <code>path</code> 的等效 <strong>名称空间前缀路径</strong> 。</p><p>如果 <code>path</code> 不是字符串，则将返回 <code>path</code> 而不进行修改。</p><p><br><br><br><br><br></p><h3 id="path-delimiter"><a href="#path-delimiter" class="headerlink" title="path.delimiter"></a>path.delimiter</h3><p>提供平台特定的 <strong>路径界定符</strong>：</p><ul><li><strong><code>;</code></strong> 用于 Windows</li><li><strong><code>:</code></strong> 用于 POSIX</li></ul><p><br><br><br><br><br></p><h3 id="path-posix"><a href="#path-posix" class="headerlink" title="path.posix"></a>path.posix</h3><p>提供对 path 方法的 POSIX 特定实现的访问。</p><p><br><br><br><br><br></p><h3 id="path-win32"><a href="#path-win32" class="headerlink" title="path.win32"></a>path.win32</h3><p>提供对特定于 Windows 的 <code>path</code> 方法实现的访问。</p><p><br><br><br><br><br></p><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="path-resolve-与-path-join-对比"><a href="#path-resolve-与-path-join-对比" class="headerlink" title="path.resolve() 与 path.join() 对比"></a>path.resolve() 与 path.join() 对比</h4><img src="/2020/01/16/NodeJs-path-路径模块/path_resolve_1.png" title="path_resolve_1"><p>运行结果如下：</p><img src="/2020/01/16/NodeJs-path-路径模块/path_resolve_2.png" title="path_resolve_2"><p><br></p><h4 id="内置全局变量-dirname、-filename"><a href="#内置全局变量-dirname、-filename" class="headerlink" title="内置全局变量 __dirname、__filename"></a>内置全局变量 __dirname、__filename</h4><ul><li><code>__dirname</code> 当前脚本文件 <u><strong>所在目录</strong></u> 的<strong>绝对路径</strong>（被执行的 js文件所在文件夹的绝对路径）</li><li><code>__filename</code> 当前执行<strong>脚本文件</strong> 的<strong>绝对路径</strong></li></ul><p><br></p><h4 id="Node-js-中的几种文件路径"><a href="#Node-js-中的几种文件路径" class="headerlink" title="Node.js 中的几种文件路径"></a>Node.js 中的几种文件路径</h4><ul><li><code>__dirname</code> </li><li><code>__filename</code></li><li><code>module.filename === __filename</code></li><li><code>process.cwd()</code>  运行当前脚本的 <strong>工作目录的路径</strong>（即 node命令路径）</li><li><code>process.chdir()</code>  改变工作目录</li><li><code>./</code> 当前工作路径（node命令路径）</li></ul><img src="/2020/01/16/NodeJs-path-路径模块/path_1.png" title="path_1"><p>上述代码运行结果如下：</p><img src="/2020/01/16/NodeJs-path-路径模块/path_2.png" title="path_2"><blockquote><p>注意：</p><p>（1）在 <code>require()</code> 中使用 <code>./</code> 和 <code>../</code> 时，<code>&#39;.&#39;</code> 指的是 当前脚本文件的 <strong>相对路径</strong>。（即 请求路径是相对于当前执行文件的目录的，<code>./</code> 指的是<u>同级目录</u>下的相对路径， <code>../</code> 指的是<u>上级目录</u>下的相对路径）</p><p>（2）除了在 <code>require()</code> 中使用 <strong>相对路径</strong> 的写法，其他地方均使用 <strong>绝对路径</strong> ，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前目录</span></span><br><span class="line">path.dirname(__filename) + <span class="string">'/demo.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相邻目录</span></span><br><span class="line">path.resolve( __dirname, <span class="string">'../siblings/subfile.js'</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据绝对路径读取文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync( path.resolve(__dirname, <span class="string">'./demo.js'</span>) );</span><br></pre></td></tr></table></figure></p></blockquote><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;path-dirname-path&quot;&gt;&lt;a href=&quot;#path-dirname-path&quot; class=&quot;headerlink&quot; title=&quot;path.dirname( path )&quot;&gt;&lt;/a&gt;path.dirname( path )&lt;/h3&gt;&lt;p&gt;返回 p
      
    
    </summary>
    
    
    
      <category term="NodeJs" scheme="http://fujiafeng.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 阻塞调用与非阻塞调用</title>
    <link href="http://fujiafeng.com/2020/01/16/NodeJs-%E9%98%BB%E5%A1%9E%E8%B0%83%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B0%83%E7%94%A8/"/>
    <id>http://fujiafeng.com/2020/01/16/NodeJs-%E9%98%BB%E5%A1%9E%E8%B0%83%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B0%83%E7%94%A8/</id>
    <published>2020-01-16T06:40:48.000Z</published>
    <updated>2020-01-16T07:01:29.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>阻塞：在Node.js 程序中，其他 JavaScript语句的执行，必须等待一个 非JavaScript 操作（如 I/O）的完成。</p><blockquote><p>当阻塞发生时，事件循环 无法继续运行 JavaScript。</p></blockquote><p>在 Node.js 标准库中的所有 I/O 方法都提供 异步版本（非阻塞），并接受回调函数；某些方法提供对应的 阻塞版本，名称以 <code>Sync</code> 结尾。</p><p><br><br><br><br><br></p><h3 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h3><p><strong>阻塞</strong>方法 - <strong>同步</strong>执行；<br><strong>非阻塞</strong>方法 - <strong>异步</strong>执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步 文件读取（阻塞 其它js 语句的执行，直到整个文件读取完毕）</span></span><br><span class="line"><span class="keyword">const</span> data = fs.readFileSync(<span class="string">'/file.md'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步 文件读取（提高吞吐量）</span></span><br><span class="line">fs.readFile(<span class="string">'/file.md'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h3 id="并发-amp-吞吐量"><a href="#并发-amp-吞吐量" class="headerlink" title="并发 &amp; 吞吐量"></a>并发 &amp; 吞吐量</h3><p>在 Node.js 中 JavaScript 的执行是 <strong>单线程</strong> 的，因此，<strong>并发性</strong> 是指 <u>事件循环在完成其他工作后 执行 JavaScript回调函数的能力</u>。</p><blockquote><p>混合 阻塞和非阻塞代码，可能导致执行顺序错误。</p></blockquote><p><br></p><p>参考链接： </p><ul><li>nodejs核心库（跨平台事件库）  <a href="https://libuv.org/" target="_blank" rel="noopener">libuv</a></li></ul><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;阻塞&quot;&gt;&lt;a href=&quot;#阻塞&quot; class=&quot;headerlink&quot; title=&quot;阻塞&quot;&gt;&lt;/a&gt;阻塞&lt;/h3&gt;&lt;p&gt;阻塞：在Node.js 程序中，其他 JavaScript语句的执行，必须等待一个 非JavaScript 操作（如 I/O）的完成。&lt;/p
      
    
    </summary>
    
    
    
      <category term="NodeJs" scheme="http://fujiafeng.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>《我们之间的距离》</title>
    <link href="http://fujiafeng.com/2020/01/14/%E3%80%8A%E6%88%91%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB%E3%80%8B/"/>
    <id>http://fujiafeng.com/2020/01/14/%E3%80%8A%E6%88%91%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB%E3%80%8B/</id>
    <published>2020-01-14T12:29:32.000Z</published>
    <updated>2020-02-26T13:24:44.438Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/01/14/《我们之间的距离》/bookPic.jpg" title="我们之间的距离" style="width: 120px;"></p><p>“ 每个人都不能孤立于社会，在我们的生命里，有些人有些事的出现，不是为了让你陷入绝望，而是要推你向前，遇见更好的自己。</p><p><em>#抄句子#</em></p><blockquote><ol><li><p><strong>总是会有一段乐曲来标志一段相遇。</strong></p></li><li><p>一群快乐的疯子，我才应该给他们鼓掌，拥抱他们，我想告诉他们，我在他们身上感受到的关怀让我可以承受这一切痛苦。</p></li><li><p>虚伪的人是最糟糕的。</p></li><li><p>生活中的偏见无处不在。</p></li><li><p>我喜欢观察周围的生活。曾经有段时间，在离这里不远的地方，晚上我会去超市散步。在那里可以遇见各种各样的人，大学生、夜班工人，还有很多上了年纪的人去那里排遣寂寞。</p></li><li><p>“我是录有声书的。只出声，不出镜，跟默片正好相反，但我觉得这份工作挺有诗意的，不是吗？”</p></li><li><p>客厅里的灯光弱下来，天色变暗了。窗户开着，能听到风吹过树木发出的沙沙声。</p></li><li><p>只要他想到我，我就存在。</p></li><li><p>准备去水池旁边散散步，看看路人，想象他们的生活，这是他的乐趣之一，也是他开发应用的灵感来源。</p></li><li><p><strong>我说离开家的时候什么都没有失去，这是谎话。因为我在那里抛弃了一部分自己，这份骄傲让我付出了代价，直到现在我还会因此受苦。</strong></p></li><li><p>太多人因为不同的原因错过了彼此，为了获得幸福冒冒险又何妨？</p></li><li><p>观察，但不评论。</p></li><li><p>一段爱情故事的开始总是非常纠结。恋人们处于恐慌中，犹豫着要不要告诉对方自己的思念之情。什么都想给对方，但是又不愿前进一步。恋人们对幸福精打细算，想存起来，慢慢享用。刚刚诞生的爱情疯狂又脆弱。</p></li><li><p>我明白跟失去的双腿相比，<strong>我更需要的是温柔</strong>。</p></li><li><p>某一天，当我在孟买的街上散步时，我们会呼吸同样的空气，我知道光是这样就会让我幸福。谁知道呢？也许我们会再次在公园里相遇。无尽的温柔。</p></li><li><p>当人生触及最低谷时，生活会给我们准备一份意外的惊喜。</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/01/14/《我们之间的距离》/bookPic.jpg&quot; title=&quot;我们之间的距离&quot; style=&quot;width: 120px;&quot;&gt;&lt;/p&gt;
&lt;p&gt;“ 每个人都不能孤立于社会，在我们的生命里，有些人有些事的出现，不是为了让你陷入绝望，而是要
      
    
    </summary>
    
    
    
      <category term="读书" scheme="http://fujiafeng.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Docker 入门</title>
    <link href="http://fujiafeng.com/2020/01/09/Docker-%E5%85%A5%E9%97%A8/"/>
    <id>http://fujiafeng.com/2020/01/09/Docker-%E5%85%A5%E9%97%A8/</id>
    <published>2020-01-09T05:48:21.000Z</published>
    <updated>2020-01-09T06:19:18.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h3><blockquote><p><strong>虚拟化</strong>：在硬件性能过剩的前提下，为不同应用提供某个级别的 <strong>运行环境隔离</strong>。（虚拟机是 硬件虚拟化，容器是 操作系统虚拟化）</p><p><strong>微服务</strong> 带来的两个问题：<br>（1）微服务拆分，使需要 <strong>打包、测试、上线</strong> 的量级信息大量增加；<br>（2）进行 <strong>服务器扩容</strong>，需要对 <strong>环境初始化</strong>，使其与原先的环境一致，部署工作繁重。</p></blockquote><p><strong>容器</strong> 完全使用 <strong>沙箱机制</strong>，相互之间不会有任何接口（类似 iPhone 的 app），性能开销极低。</p><p>Docker 是一个开源的 <strong>应用容器引擎</strong>：</p><ul><li>可以让开发者打包他们的应用以及依赖包到一个 <u><em>轻量级、可移植的容器</em></u> 中，然后发布到任何流行的 Linux 机器上；</li><li>也可以实现 <em><u>虚拟化</u></em>。</li></ul><blockquote><p><strong>Docker</strong><br>（1）解决了 应用程序 <strong>运行时隔离</strong> 的问题；<br>（2）Docker镜像 解决了 DevOps中 微服务运行的环境 难以在本地环境、测试环境及线上环境保持一致的问题（ <strong>运行环境迁移</strong> 问题）。<br>Docker 镜像可以打包： <u>应用程序 及其所有依赖</u>、<strong><u>整个操作系统</u></strong>。</p></blockquote><p><strong>应用场景</strong>：</p><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><p><br><br><br><br><br></p><h3 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h3><p>三个基本概念：</p><ul><li><strong>镜像</strong>（Image）：相当于一个 root 文件系统；</li><li><strong>容器</strong>（Container）：镜像运行时的实体，可以被创建、启动、停止、删除、暂停等；</li><li><strong>仓库</strong>（Repository）：代码控制中心，用来保存镜像。</li></ul><p>Docker 使用 <strong>客户端-服务器(C/S)架构模式</strong>，使用远程API 来管理和创建Docker 容器。</p><p>Docker 容器通过 Docker 镜像来创建。</p><blockquote><p>镜像和容器的关系，类似于面向对象编程中的类与对象，镜像是静态的定义。</p></blockquote><p><br><br><br><br><br></p><h3 id="Win10系统-Docker-安装"><a href="#Win10系统-Docker-安装" class="headerlink" title="Win10系统 Docker 安装"></a>Win10系统 Docker 安装</h3><h4 id="开启-Hyper-v"><a href="#开启-Hyper-v" class="headerlink" title="开启 Hyper-v"></a>开启 Hyper-v</h4><p>Windows【开始菜单】 -&gt; 右键菜单，选择【应用和功能】-&gt; 相关设置，点击【程序和功能】-&gt; 左侧菜单，点击【启用或关闭 Windows 功能】-&gt; 选中 Hyper-v，点击【确定】</p><p><br></p><h4 id="安装-Toolbox"><a href="#安装-Toolbox" class="headerlink" title="安装 Toolbox"></a>安装 Toolbox</h4><p>最新版 Toolbox 下载地址： <a href="https://www.docker.com/get-docker" target="_blank" rel="noopener">Docker 官方下载</a></p><p>点击【Download Desktop and Take a Tutorial】，下载Windows相应版本。<br><img src="/2020/01/09/Docker-入门/docker_download.png" title="docker_download"></p><p><br></p><h4 id="运行安装文件"><a href="#运行安装文件" class="headerlink" title="运行安装文件"></a>运行安装文件</h4><p>安装时，勾选 <u>使用 Windows容器</u>：<br><img src="/2020/01/09/Docker-入门/docker_install.png" title="docker_install"></p><p>安装完成后，查看版本信息：</p><img src="/2020/01/09/Docker-入门/docker_version.png" title="docker_version"><p><br></p><h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><p>在 【Settings -&gt; Daemon -&gt; Registry mirrors】中填写 镜像加速地址：<br><img src="/2020/01/09/Docker-入门/docker_speed.png" title="docker_speed"></p><p>参考可用的地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//dockerhub.azk8s.cn        #Azure 中国镜像 </span></span><br><span class="line">https:<span class="comment">//reg-mirror.qiniu.com      #七牛云加速器 </span></span><br><span class="line">https:<span class="comment">//registry.docker-cn.com　　 #Docker中国区</span></span><br><span class="line">http:<span class="comment">//hub-mirror.c.163.com　　　　 #网易</span></span><br><span class="line">https:<span class="comment">//docker.mirrors.ustc.edu.cn       #USTC</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="修改镜像文件存储地址"><a href="#修改镜像文件存储地址" class="headerlink" title="修改镜像文件存储地址"></a>修改镜像文件存储地址</h4><p>执行 <code>docker info</code> 查看Docker 系统信息：<br><img src="/2020/01/09/Docker-入门/docker_info.png" title="docker_info"></p><p>Windows 系统默认的镜像地址是 <code>C:\ProgramData\Docker</code> ，由于Docker 使用过程中可能会拉取很多镜像文件，建议将Docker 的镜像文件存储地址修改到其他盘。</p><h5 id="通过Docker-GUI-界面修改"><a href="#通过Docker-GUI-界面修改" class="headerlink" title="通过Docker GUI 界面修改"></a>通过Docker GUI 界面修改</h5><p>在 【Settings -&gt; Daemon】中勾选【Advanced】选项，添加 <strong>graph属性</strong> 配置自定义路径：<br><img src="/2020/01/09/Docker-入门/docker_graph.png" title="docker_graph"></p><p>配置后点击【Apply】Docker 将自动重启，再查看 <code>Root Dir</code> 显示如下：<br><img src="/2020/01/09/Docker-入门/docker_info_changed.png" title="docker_info_changed"></p><h5 id="使用-命令行-修改"><a href="#使用-命令行-修改" class="headerlink" title="使用 命令行 修改"></a>使用 命令行 修改</h5><p>停止运行 Docker：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl stop docker</span></span><br></pre></td></tr></table></figure></p><p>修改 daemon.json 文件，添加 graph属性配置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/docker/daemon.json</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Windows 上配置文件的默认位置： <code>%programdata%\docker\config\daemon.json</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是-Docker&quot;&gt;&lt;a href=&quot;#什么是-Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是 Docker&quot;&gt;&lt;/a&gt;什么是 Docker&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;：在硬件性
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://fujiafeng.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 简介</title>
    <link href="http://fujiafeng.com/2020/01/06/Vuex-%E7%AE%80%E4%BB%8B/"/>
    <id>http://fujiafeng.com/2020/01/06/Vuex-%E7%AE%80%E4%BB%8B/</id>
    <published>2020-01-06T07:55:21.000Z</published>
    <updated>2020-01-06T09:56:04.012Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex 官方文档</a></p><p><br></p><h3 id="Vuex是什么"><a href="#Vuex是什么" class="headerlink" title="Vuex是什么"></a>Vuex是什么</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的 <strong>状态管理模式</strong> 。它采用 <strong>集中式存储</strong> 管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><img src="/2020/01/06/Vuex-简介/vuex.png" title="vuex状态管理"><p>每一个 Vuex 应用的核心就是 <strong>store（仓库）</strong>。“store”基本上就是一个容器，它包含着你的应用中大部分的 <strong>状态 (state)</strong> 。</p><p>Vuex 和单纯的全局对象有以下两点不同：</p><ol><li>Vuex 的状态存储是 <strong>响应式</strong> 的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地 <strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ol><p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要<strong>在计算属性中返回</strong>即可。触发变化也仅仅是<strong>在组件的 methods 中提交 mutation</strong>。</p><p><br><br><br><br><br></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><h5 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h5><p>用一个对象就包含了全部的应用层级状态，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><h5 id="在Vue-组件中获取Vuex-状态"><a href="#在Vue-组件中获取Vuex-状态" class="headerlink" title="在Vue 组件中获取Vuex 状态"></a>在Vue 组件中获取Vuex 状态</h5><p>Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">    store,</span><br><span class="line">    components: &#123; Counter &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">        &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h5><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 </span></span><br><span class="line"><span class="comment">// Vuex.mapStateimport &#123; mapState &#125; from 'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span>])</span><br></pre></td></tr></table></figure></p><h5 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h5><p>mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="组件仍保有-局部状态"><a href="#组件仍保有-局部状态" class="headerlink" title="组件仍保有 局部状态"></a>组件仍保有 局部状态</h5><p><br></p><h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br>Getter 接受 state 作为其第一个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h5 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h5><p>Getter 也可以接受其他 getter 作为第二个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">store.getters.doneTodosCount <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure></p><p>我们可以在任何组件中使用它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>注意，getter 在通过属性访问时是<strong>作为Vue 的响应式系统的一部分缓存其中</strong> 的。</p><h5 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h5><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> (id) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// -&gt; &#123; id: 2, text: '...', done: false &#125;</span></span><br></pre></td></tr></table></figure><p>注意，getter 在通过方法访问时，<strong>每次都会去进行调用，而不会缓存结果</strong>。</p><h5 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h5><p>将 store 中的 getter 映射到局部计算属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong> 。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <strong><code>store.commit</code></strong> 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure></p><h5 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h5><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>在大多数情况下，载荷应该是一个<strong>对象</strong>，这样可以<strong>包含多个字段</strong>并且记录的 mutation 会更易读：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h5><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Mutation-需遵守Vue-的响应规则"><a href="#Mutation-需遵守Vue-的响应规则" class="headerlink" title="Mutation 需遵守Vue 的响应规则"></a>Mutation 需遵守Vue 的响应规则</h5><p> Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p><ol><li>最好提前在 store 中<strong>初始化</strong>好所有所需属性。</li><li>当需要在对象上添加新属性时，你应该<ul><li>使用 Vue.set(obj, ‘newProp’, 123), 或者</li><li>以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="使用常量替代Mutation-事件类型"><a href="#使用常量替代Mutation-事件类型" class="headerlink" title="使用常量替代Mutation 事件类型"></a>使用常量替代Mutation 事件类型</h5><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h5><h5 id="在组件中提交Mutation"><a href="#在组件中提交Mutation" class="headerlink" title="在组件中提交Mutation"></a>在组件中提交Mutation</h5><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意 <strong>异步</strong>操作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p><p>实践中，我们会经常用到 ES2015 的 <strong>参数解构</strong> 来简化代码（特别是我们需要调用 commit 很多次的时候）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h5><p>Action 通过 <strong><code>store.dispatch</code></strong> 方法触发：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure></p><p>可以在 action 内部执行 <strong>异步操作</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>Actions 支持同样的 <strong>载荷方式</strong> 和 <strong>对象方式</strong> 进行分发：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>购物车示例，涉及到 <strong>调用异步 API</strong> 和 <strong>分发多重 mutation</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h5><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <strong><code>mapActions</code></strong>  辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h5><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？如何才能组合多个 action，以处理更加复杂的异步流程？</p><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另外一个 action 中也可以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>利用 <strong>async / await</strong>，我们可以如下组合 action：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>一个 store.dispatch 在不同模块中可以<strong>触发多个 action 函数</strong>。在这种情况下，只有当<strong>所有</strong>触发函数<strong>完成后</strong>，返回的 <strong>Promise 才会执行</strong>。</p></blockquote><p><br></p><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。<br>为了解决以上问题，Vuex 允许我们<strong>将store 分割成模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure></p><h5 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h5><p>对于模块内部的 mutation 和 getter，接收的第一个参数是 <strong>模块的局部状态对象</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p><strong>默认</strong>情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局</strong>命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <strong><code>namespaced: true</code></strong> 的方式使其成为 <strong>带命名空间的模块</strong>。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容（module assets）</span></span><br><span class="line">      state: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。</p><h6 id="在-带命名空间的模块内-访问全局内容（Global-Assets）"><a href="#在-带命名空间的模块内-访问全局内容（Global-Assets）" class="headerlink" title="在 带命名空间的模块内 访问全局内容（Global Assets）"></a>在 带命名空间的模块内 访问全局内容（Global Assets）</h6><ul><li><p>如果你希望使用全局 state 和 getter，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p></li><li><p>若需要在全局命名空间内分发 action 或提交 mutation，将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块的 getter 中，`getters` 被局部化了</span></span><br><span class="line">      <span class="comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span></span><br><span class="line">      someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter <span class="comment">// -&gt; 'foo/someOtherGetter'</span></span><br><span class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; 'someOtherGetter'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    actions: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span></span><br><span class="line">      <span class="comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span></span><br><span class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">        getters.someGetter <span class="comment">// -&gt; 'foo/someGetter'</span></span><br><span class="line">        rootGetters.someGetter <span class="comment">// -&gt; 'someGetter'</span></span><br><span class="line"></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>) <span class="comment">// -&gt; 'foo/someOtherAction'</span></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someOtherAction'</span></span><br><span class="line"></span><br><span class="line">        commit(<span class="string">'someMutation'</span>) <span class="comment">// -&gt; 'foo/someMutation'</span></span><br><span class="line">        commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someMutation'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="在-带命名空间的模块-注册全局action"><a href="#在-带命名空间的模块-注册全局action" class="headerlink" title="在 带命名空间的模块 注册全局action"></a>在 带命名空间的模块 注册全局action</h6><p>若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    someOtherAction (&#123;dispatch&#125;) &#123;</span><br><span class="line">      dispatch(<span class="string">'someAction'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: <span class="literal">true</span>,</span><br><span class="line">          handler (namespacedContext, payload) &#123; ... &#125; <span class="comment">// -&gt; 'someAction'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h6><p>当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.b</span><br><span class="line">  &#125;)&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'some/nested/module/foo'</span>, <span class="comment">// -&gt; this['some/nested/module/foo']()</span></span><br><span class="line">    <span class="string">'some/nested/module/bar'</span> <span class="comment">// -&gt; this['some/nested/module/bar']()</span></span><br><span class="line">  ])&#125;</span><br></pre></td></tr></table></figure></p><p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">  &#125;)&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">'some/nested/module'</span>, [</span><br><span class="line">    <span class="string">'foo'</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">    <span class="string">'bar'</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">  ])&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过使用 <strong>createNamespacedHelpers</strong> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">'some/nested/module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">      b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'foo'</span>,</span><br><span class="line">      <span class="string">'bar'</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h5><p>在 store 创建 <strong>之后</strong>，你可以使用 <code>store.registerModule</code> 方法注册模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)<span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p><ul><li>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，<code>vuex-router-sync</code> 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</li><li>可以使用 <code>store.unregisterModule(moduleName)</code> 来<strong>动态卸载模块</strong>。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</li><li>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 preserveState 选项将其归档：<code>store.registerModule(&#39;a&#39;, module, { preserveState: true })</code>。</li><li>当你设置 <code>preserveState: true</code> 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。</li></ul><h5 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h5><p>有时我们可能需要创建一个模块的多个实例，例如：</p><ul><li>创建多个 store，他们公用同一个模块 (例如当 runInNewContext 选项是 false 或 ‘once’ 时，为了在服务端渲染中避免有状态的单例)</li><li>在一个 store 中多次注册同一个模块</li></ul><p>使用一个函数来声明模块状态（仅 2.3.0+ 支持）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyReusableModule = &#123;</span><br><span class="line">  state () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// mutation, action 和 getter 等等...&#125;</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>一些需要遵守的规则：</p><ul><li>应用层级的状态应该集中到单个 store 对象中。</li><li>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 action 里面。</li></ul><p><br><br><br><br><br></p><h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><p>严格模式中，表单元素使用 v-modal 可能导致错误：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"obj.message"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>假设 obj 是在计算属性中返回的 Vuex store的对象，则有两种解决方案：</p><p><br></p><h4 id="用-value-和-input-change-替代-v-modal"><a href="#用-value-和-input-change-替代-v-modal" class="headerlink" title="用 :value 和 @input/@change 替代 v-modal"></a>用 <code>:value</code> 和 <code>@input/@change</code> 替代 <code>v-modal</code></h4><p>给 <code>&lt;input&gt;</code> 中绑定 <code>value</code>，然后侦听 <code>input</code> 或 <code>change</code> 事件，在事件回调中调用 action ：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"updateMessage"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    message: <span class="function"><span class="params">state</span> =&gt;</span> state.obj.message</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage (e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex 的 mutation 函数...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  updateMessage (state, message) &#123;</span><br><span class="line">    state.obj.message = message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="双向绑定-计算属性"><a href="#双向绑定-计算属性" class="headerlink" title="双向绑定 计算属性"></a>双向绑定 计算属性</h4><p>使用带有 <code>setter</code> 的双向绑定计算属性：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  message: &#123;</span><br><span class="line">    get () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</span><br><span class="line">    &#125;,</span><br><span class="line">    set (value) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://vuex.vuejs.org/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vuex 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;Vuex是什么&quot;&gt;&lt;a href=&quot;#Vuex是什么&quot; cla
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://fujiafeng.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面向对象的程序设计</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-01-05T14:40:37.000Z</published>
    <updated>2020-01-05T14:56:33.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p><strong>特性</strong>：为了实现JavaScript 引擎的，只有内部才用的特性（attribute），描述了属性（property）的各种特征。</p><ul><li>在JavaScript 中不能直接访问它们。</li><li>放在两对儿方括号中，例如[[Enumerable]]。</li></ul><p>ECMAScript 中有两种 <strong>属性</strong>：<u><strong>数据属性</strong></u> 和 <u><strong>访问器属性</strong></u>。</p><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>包含 <strong>一个数据值的位置</strong>。在这个位置可以读取和写入值。数据属性有4 个描述其行为的特性：</p><ul><li><strong>[[Configurable]]</strong> ：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><strong>[[Enumerable]]</strong> ：表示能否通过for-in 循环返回属性。</li><li><strong>[[Writable]]</strong> ：表示能否修改属性的值。</li><li><strong>[[Value]]</strong> ：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为 undefined。</li></ul><p><u><strong>修改属性默认的特性</strong></u>：使用ES5 的 <code>Object.defineProperty()</code> 方法（接收三个参数：属性所在的对象、属性名 和 一个描述符对象）：</p><ul><li>如果不指定，<code>configurable</code>、<code>enumerable</code> 和 <code>writable</code> 特性的默认值都是 false。</li><li>一旦把属性定义为不可配置的，就不能再把它变回可配置了。</li></ul><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>包含一对儿 getter 和setter 函数（非必需）：</p><ul><li>在读取访问器属性时，会调用<strong>getter 函数</strong>，这个函数负责返回有效的值；</li><li>在写入访问器属性时，会调用<strong>setter 函数</strong>并传入新值，这个函数负责决定如何处理数据。</li></ul><p>访问器属性有如下4 个特性：</p><ul><li><strong>[[Configurable]]</strong> ：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</li><li><strong>[[Enumerable]]</strong> ：表示能否通过for-in 循环返回属性。</li><li><strong>[[Get]]</strong> ：在读取属性时调用的函数。默认值为undefined。</li><li><strong>[[Set]]</strong> ：在写入属性时调用的函数。默认值为undefined。</li></ul><p><br></p><h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p>ES 5 定义了 <code>Object.defineProperties()</code> 方法，利用这个方法可以通过描述符一次定义多个属性。</p><p><br></p><h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p>使用ECMAScript 5 的 <code>Object.getOwnPropertyDescriptor()</code> 方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable 和value。</p><p><br><br><br><br><br></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>Object 构造函数 或 对象字面量 创建单个对象，有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p><p><br></p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式抽象了 创建具体对象的过程，在 JavaScript 中用函数来封装 以特定接口创建对象的细节：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></p><p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p><p><br></p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>按照惯例，<strong>构造函数</strong> 始终都应该以一个 <strong>大写字母开头</strong>，而非构造函数则应该以一个小写字母开头。</li><li>下划线开头是一种常用的记号，用于表示 <strong>只能通过对象方法访问</strong> 的属性。</li></ul></blockquote><p>使用 <strong>new 操作符</strong> 调用构造函数实际上会经历以下 4 个步骤：</p><p>(1) 创建一个新对象；<br>(2) 将构造函数的作用域赋给新对象（因此this 就指向了这个新对象）；<br>(3) 执行构造函数中的代码（为这个新对象添加属性）；<br>(4) 返回新对象。</p><p>对象的constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 <strong>instanceof</strong> 操作符要更可靠一些。</p><p><strong>创建自定义的构造函数</strong> 意味着将来可以将它的实例标识为一种特定的类型。</p><ol><li>将构造函数 当做函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当作构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">person.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到window</span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName(); <span class="comment">//"Kristen"</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>当在全局作用域中调用一个函数时，this 对象总是指向Global 对象（在浏览器中就是window 对象）</strong>。</p></blockquote><ol><li>构造函数的问题</li></ol><p>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</p><blockquote><p>ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><p>把sayName()函数的定义转移到了 构造函数外部。而在构造函数内部，我们将sayName 属性设置成等于全局的sayName 函数。由于sayName 包含的是一个指向函数的指针，因此person1 和person2 对象就共享了在全局作用域中定义的同一个sayName()函数。</p><p>这样做确实解决了两个函数做同一件事的问题，可是新问题又来了：</p><ol><li>在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。</li><li>如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</li></ol><p>这些问题可以通过使用 原型模式 来解决。</p><p><br></p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个 <strong>指针</strong>，指向一个对象，而这个对象的用途是 <strong>包含可以由特定类型的所有实例共享的属性和方法</strong>。使用原型对象的好处是 可以让所有对象实例共享它所包含的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h5 id="1-理解原型对象"><a href="#1-理解原型对象" class="headerlink" title="1. 理解原型对象"></a>1. 理解原型对象</h5><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype 属性所在函数的指针。</p><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 <strong><code>[[Prototype]]</code></strong> （内部属性），指向构造函数的原型对象。虽然在脚本中没有标准的方式访问 <code>[[Prototype]]</code> ，但Firefox、Safari 和Chrome 在每个对象上都支持一个属性 <code>__proto__</code> ；而在其他实现中，这个属性对脚本则是完全不可见的。需要明确的是，这个连接存在于 <strong>实例</strong> 与 <strong>构造函数的<u>原型对象</u></strong> 之间，而不是存在于实例与构造函数之间。</p><img src="/2020/01/05/JavaScript-面向对象的程序设计/理解原型对象.png" title="理解原型对象"><p>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 <strong>isPrototypeOf()</strong> 方法来确定对象之间是否存在这种关系。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>ECMAScript 5 增加了一个新方法，叫 <strong>Object.getPrototypeOf()</strong> ，在所有支持的实现中，这个方法返回 <code>[[Prototype]]</code> 的值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>读取对象属性：</p><ol><li>搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；</li><li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</li></ol></blockquote><ul><li>通过对象实例，可以访问保存在原型中的值，不能重写原型中的值；</li><li>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；</li><li>使用<code>delete</code> 操作符则可以完全删除实例属性，从而可以重新访问原型中的属性；</li></ul><p>使用 <strong>hasOwnProperty()</strong> 方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（它是从Object 继承来的）只在给定属性存在于对象实例中时，才会返回true。</p><h5 id="2-原型与-in-操作符"><a href="#2-原型与-in-操作符" class="headerlink" title="2. 原型与 in 操作符"></a>2. 原型与 in 操作符</h5><p>有两种方式使用in 操作符：</p><ul><li><strong>单独使用</strong>：in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中；</li><li><strong>在 <code>for-in</code> 循环中使用</strong>：返回的是所有能够 <strong>通过对象访问的</strong>、<strong>可枚举的</strong>（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。</li></ul><p>同时使用 <code>hasOwnProperty()</code> 方法和 <code>in</code> 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>要取得对象上<strong>所有<u>可枚举</u>的实例属性</strong>，可以使用ES5 的 <strong>Object.keys()</strong> 方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组；</li><li>如果你想要得到<strong>所有实例属性</strong>，无论它是否可枚举，都可以使用<strong>Object.getOwnPropertyNames()</strong> 方法。</li></ul><h5 id="3-更简单的原型语法"><a href="#3-更简单的原型语法" class="headerlink" title="3. 更简单的原型语法"></a>3. 更简单的原型语法</h5><p>为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是：用一个包含所有属性和方法的 <strong>对象字面量</strong> 来重写整个原型对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上述代码本质上完全 <strong>重写了默认的prototype 对象</strong>，因此 <strong>constructor</strong> 属性也就变成了新对象的constructor 属性（<strong>指向Object 构造函数</strong>），不再指向Person 函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor 已经无法确定对象的类型了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重设构造函数，只适用于ECMAScript 5 兼容的浏览器</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="4-原型的动态性"><a href="#4-原型的动态性" class="headerlink" title="4. 原型的动态性"></a>4. 原型的动态性</h5><p><strong>可以随时为原型添加属性和方法</strong>，并且修改能够<strong>立即在所有对象实例中反映</strong>出来；但如果是 <strong>重写整个原型对象</strong>，那么情况就不一样了：调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p><blockquote><p>请记住：实例中的指针 [[Prototype]] 仅指向原型，而不指向构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Nicholas",</span><br><span class="line">    age: 29,</span><br><span class="line">    job: "Software Engineer",</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">friend.sayName(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><img src="/2020/01/05/JavaScript-面向对象的程序设计/原型的动态性.png" title="原型的动态性"><p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。</p><h5 id="5-原生对象的原型"><a href="#5-原生对象的原型" class="headerlink" title="5. 原生对象的原型"></a>5. 原生对象的原型</h5><p>所有原生引用类型（Object、Array、String，等等）都在其 <strong>构造函数的原型</strong> 上定义了方法。</p><p>通过原生对象的原型，不仅可以 <strong>取得所有默认方法的引用</strong>，而且也可以 <strong>定义新方法</strong>。</p><h5 id="6-原型对象的问题"><a href="#6-原型对象的问题" class="headerlink" title="6. 原型对象的问题"></a>6. 原型对象的问题</h5><ol><li>它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值；</li><li>原型中所有属性是被很多实例共享的，对于 <strong>包含<u>引用类型值</u>的属性</strong> 来说，问题就比较突出了：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Nicholas",</span><br><span class="line">    age: 29,</span><br><span class="line">    job: "Software Engineer",</span><br><span class="line">    friends: ["Shelby", "Court"],</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="组合使用-构造函数模式-和-原型模式"><a href="#组合使用-构造函数模式-和-原型模式" class="headerlink" title="组合使用 构造函数模式 和 原型模式"></a>组合使用 构造函数模式 和 原型模式</h4><p><strong>创建自定义类型</strong> 的最常见方式。</p><ul><li>构造函数模式：定义 <strong>实例属性</strong>；</li><li>原型模式：定义 <strong>方法</strong> 和 <strong>共享属性</strong>；</li><li>支持向构造函数 <strong>传递参数</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">//"Shelby,Count"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure></p><p><strong>if 语句</strong> 检查的可以是 <strong>初始化之后应该存在的任何属性或方法</strong> ——不必用一大堆if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用instanceof 操作符确定它的类型。</p><p><br></p><h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><p>寄生（parasitic）构造函数模式的基本思想是：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p><p>构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return 语句，可以重写调用构造函数时返回的值。</p><p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array 构造函数，因此可以使用这个模式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="comment">//添加值</span></span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回数组</span></span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line">alert(colors.toPipedString());   <span class="comment">//"red|blue|green"</span></span><br></pre></td></tr></table></figure></p><ul><li>返回的对象与构造函数或者与构造函数的原型属性之间没有关系；</li><li>不能依赖instanceof 操作符来确定对象类型。</li></ul><p><br></p><h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><p>稳妥对象（durable objects）指的是 <strong>没有公共属性</strong>，而且 <strong>其方法也不引用this</strong> 的对象。</p><p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：<br>一是新创建对象的实例方法不引用this；<br>二是不使用new 操作符调用构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回对象</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>OO语言支持两种继承方式：<br>（1）接口继承：只继承 方法签名；<br>（2）实现继承：继承 实际的方法。</p></blockquote><p>ECMAScript 只支持 <strong>实现继承</strong>，而且其实现继承主要是依靠 <strong>原型链</strong> 来实现的。</p><p><br></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><blockquote><p>构造函数、原型和实例的关系：<br>每个构造函数都有一个原型对象，<br>原型对象都包含一个指向构造函数的指针，<br>而实例都包含一个指向原型对象的内部指针。</p></blockquote><p>实现原型链的一种基本模式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>实现的本质是重写原型对象，代之以一个新类型的实例。实例以及构造函数和原型之间的关系如图：</p><img src="/2020/01/05/JavaScript-面向对象的程序设计/原型链.png" title="原型链"><p>通过实现原型链，本质上是扩展了 原型搜索机制。调用 <code>instance.getSuperValue()</code> 会经历三个搜索步骤：1）搜索实例；2）搜索 <code>SubType.prototype</code>；3）搜索 <code>SuperType.prototype</code>，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p><h5 id="1-别忘记默认的原型"><a href="#1-别忘记默认的原型" class="headerlink" title="1. 别忘记默认的原型"></a>1. 别忘记默认的原型</h5><blockquote><ul><li>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。</li><li>所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向 <code>Object.prototype</code> 。</li></ul></blockquote><p>上述代码完整的原型链如下：</p><img src="/2020/01/05/JavaScript-面向对象的程序设计/完整原型链.png" title="完整原型链"><h5 id="2-确定原型和实例的关系"><a href="#2-确定原型和实例的关系" class="headerlink" title="2. 确定原型和实例的关系"></a>2. 确定原型和实例的关系</h5><ul><li>使用 <strong><code>instanceof</code></strong> 操作符：测试实例与原型链中出现过的构造函数，结果就会返回true。</li><li>使用 <strong><code>isPrototypeOf()</code></strong> 方法：只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此 <code>isPrototypeOf()</code> 方法也会返回true。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="3-谨慎地定义方法"><a href="#3-谨慎地定义方法" class="headerlink" title="3. 谨慎地定义方法"></a>3. 谨慎地定义方法</h5><ul><li>给原型添加方法的代码一定要放在 <strong>替换原型的语句之后</strong>。</li><li>在通过原型链实现继承时，<strong>不能</strong> 使用 <strong>对象字面量</strong> 创建原型方法，因为这样做就会重写原型链。</li></ul><h5 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4. 原型链的问题"></a>4. 原型链的问题</h5><ul><li><strong>最主要的问题</strong>：包含引用类型值的原型。</li></ul><p>包含引用类型值的原型属性会被所有实例共享。</p><p>要在构造函数中，而不是在原型对象中定义属性。</p><ul><li><strong>第二个问题</strong>：在创建子类型的实例时，不能向超类型的构造函数中传递参数。</li></ul><blockquote><p>注：被继承的类一般称为“<strong>超类 / 父类</strong>”，继承的类称为“<strong>子类</strong>”。</p></blockquote><p><br></p><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>借用构造函数（constructor stealing）的技术（伪造对象 / 经典继承）：在<strong>子类型</strong>构造函数的内部调用<strong>超类型</strong>构造函数。</p><blockquote><p>函数只不过是 <strong>在特定环境中执行代码的对象</strong>，因此通过使用 <strong><code>apply()</code></strong> 和 <strong><code>call()</code></strong> 方法也可以在（将来）新创建的对象上执行构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);   <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors);   <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure><p>在新建的SubType 实例的环境下调用了SuperType 构造函数。这样一来，就会在新SubType 对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的colors 属性的副本了。</p><p>借用构造函数，就可以 在子类型构造函数中向超类型构造函数 <strong>传递参数</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType，同时还传递了参数</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">    <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name); <span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age); <span class="comment">//29</span></span><br></pre></td></tr></table></figure></p><p>为了确保 超类型构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p><p><strong>借用构造函数的问题</strong>：如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</p><p><br></p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承（combination inheritance）（伪经典继承）的思路是：使用 <strong>原型链</strong> 实现对原型属性和方法的继承，而通过 <strong>借用构造函数</strong> 来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);    <span class="comment">//  第二次调用 SuperType()</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();     <span class="comment">// 第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code> 和 <code>isPrototypeOf()</code> 能够用于识别基于组合继承创建的对象。</p><p><strong>组合继承的问题</strong>：无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p><p><br></p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure><p>从本质上讲，object()对传入其中的对象执行了一次 <strong>浅拷贝</strong>。</p><p>ECMAScript 5 通过新增 <strong><code>Object.create()</code></strong> 方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象 和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create() 与 object() 方法的行为相同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式（parasitic）继承：创建一个仅用于 <strong>封装继承过程</strong> 的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();   <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p></blockquote><p><br></p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>组合继承的问题如下：</p><img src="/2020/01/05/JavaScript-面向对象的程序设计/组合继承的问题.png" title="组合继承的问题"><p>所谓 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是 使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上例中只调用了一次 SuperType 构造函数，并且因此避免了在<code>SubType.prototype</code> 上面创建不必要的、多余的属性。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h3&gt;&lt;h4 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 客户端检测</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/</id>
    <published>2020-01-05T14:40:12.000Z</published>
    <updated>2020-01-05T14:42:45.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h3><p>又称 <strong>特性检测</strong>，指在 <strong>编写代码之前</strong> 先检测 <strong>特定浏览器的能力</strong>。</p><p>例如，脚本在调用某个函数之前，可能要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出来，让他们把注意力集中到相应的能力是否存在上。</p><p>采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。能力检测的基本模式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object.propertyInQuestion)&#123;</span><br><span class="line">    <span class="comment">//使用object.propertyInQuestion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意：</p><ul><li>先检测达成目的的最常用的特性</li><li>必须测试实际要用到的特性（检测某个或某几个特性并不能够确定浏览器）</li><li>能力检测无法精确地检测特定的浏览器和版本</li></ul><p>想知道某个特性是否会 <strong>按照适当方式行事</strong>（而不仅仅是某个特性存在），要尽量使用 <strong>typeof</strong> 进行能力检测。</p><p>由于 typeof 的行为不标准，在浏览器环境下测试任何对象的某个特性是否存在，可以使用下面这个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作者：Peter Michaux</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHostMethod</span>(<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> object[property];</span><br><span class="line">    <span class="keyword">return</span> t == <span class="string">'function'</span> ||</span><br><span class="line">        (!!(t == <span class="string">'object'</span> &amp;&amp; object[property])) ||</span><br><span class="line">        t == <span class="string">'unknown'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果知道自己的应用程序需要使用某些特定的浏览器特性，那么最好是 <strong>一次性检测</strong> <strong>所有相关特性</strong>，而不要分别检测：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定浏览器是否支持Netscape 风格的插件</span></span><br><span class="line"><span class="keyword">var</span> hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);</span><br><span class="line"><span class="comment">//确定浏览器是否具有DOM1 级规定的能力</span></span><br><span class="line"><span class="keyword">var</span> hasDOM1 = !!(<span class="built_in">document</span>.getElementById &amp;&amp; <span class="built_in">document</span>.createElement &amp;&amp;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName);</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h3><p>怪癖检测（quirks detection）的目标是 <strong>识别浏览器的特殊行为</strong>。</p><p>怪癖 = <strong>浏览器实现中存在的bug</strong>，例如早期的WebKit 中就存在一个怪癖，即它会在for-in 循环中返回被隐藏的属性。</p><ul><li>建议仅检测那些对你有直接影响的“怪癖”</li><li>最好在脚本一开始就执行此类检测，以便尽早解决问题</li><li>怪癖检测无法精确地检测特定的浏览器和版本</li></ul><p><br><br><br><br><br></p><h3 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h3><p>通过检测 <strong>用户代理字符串</strong> 来识别浏览器。</p><ol><li>识别<strong>呈现引擎</strong></li></ol><p>主要检测五大呈现引擎：<br><strong>IE</strong>、<strong>Gecko</strong>、<strong>WebKit</strong>、<strong>KHTML</strong> 和 <strong>Opera</strong>。</p><p>要正确地识别呈现引擎，关键是 <strong>检测顺序</strong> 要正确：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opera<span class="function"> -&gt;</span> WebKit <span class="function"><span class="params">( 关键字 AppleWebKit )</span> -&gt;</span> KHTML<span class="function"> -&gt;</span> Gecko<span class="function"> -&gt;</span> IE</span><br></pre></td></tr></table></figure></p><ol><li>识别<strong>浏览器</strong></li></ol><p>苹果公司的Safari 浏览器和谷歌公司的Chrome 浏览器都使用WebKit 作为呈现引擎，但它们的 <strong>JavaScript 引擎</strong> 却不一样。</p><ol><li>识别<strong>平台</strong></li></ol><p>目前的三大主流平台是<br><strong>Windows</strong>、<strong>Mac</strong> 和 <strong>Unix</strong>（包括各种 <strong>Linux</strong>）。</p><p>在确定平台时，检测 <strong><code>navigator.platform</code></strong> ：可能的值包括”Win32”、”Win64”、<br>“MacPPC”、”MacIntel”、”X11”和”Linux i686”，这些值在不同的浏览器中都是一致的。</p><ol><li>识别<strong>Windows 操作系统</strong></li></ol><blockquote><p>在Windows XP 之前，Windows 有两种版本，分别针对家庭用户和商业用户。针对家庭用户的版本分别是Windows 95、98 和Windows ME。而针对商业用户的版本则一直叫做Window NT，最后由于市场原因改名为Windows 2000。这两个产品线后来又合并成一个由Windows NT 发展而来的公共的代码基，代表产品就是Windows XP。随后，微软在Windows XP 基础上又构建了Windows Vista。</p></blockquote><ol><li>识别<strong>移动设备</strong></li></ol><p>四种主要的移动设备平台：<br><strong>iOS设备</strong>、<strong>Android操作系统</strong>、<strong>诺基亚N系列</strong>、<strong>Windows Mobile</strong>。</p><ol><li>识别<strong>游戏系统</strong></li></ol><p>任天堂Wii 和Playstation 3 或者内置Web 浏览器，或者提供了浏览器下载。Wii 中的浏览器实际上是定制版的Opera，是专门为Wii Remote 设计的。Playstation 的浏览器是自己开发的，没有基于前面提到的任何呈现引擎。这两个浏览器中的用户代理字符串如下所示：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Opera/<span class="number">9.10</span> (Nintendo Wii;U; ; <span class="number">1621</span>; en)</span><br><span class="line"></span><br><span class="line">Mozilla/<span class="number">5.0</span> (PLAYSTATION <span class="number">3</span>; <span class="number">2.00</span>)</span><br></pre></td></tr></table></figure></p><p><br></p><p>完整的用户代理字符串检测脚本（包括检测呈现引擎、平台、Windows 操作系统、移动设备和游戏系统）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//呈现引擎</span></span><br><span class="line">    <span class="keyword">var</span> engine = &#123;</span><br><span class="line">        ie: <span class="number">0</span>,</span><br><span class="line">        gecko: <span class="number">0</span>,</span><br><span class="line">        webkit: <span class="number">0</span>,</span><br><span class="line">        khtml: <span class="number">0</span>,</span><br><span class="line">        opera: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">//完整的版本号</span></span><br><span class="line">        ver: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//浏览器</span></span><br><span class="line">    <span class="keyword">var</span> browser = &#123;</span><br><span class="line">        <span class="comment">//主要浏览器</span></span><br><span class="line">        ie: <span class="number">0</span>,</span><br><span class="line">        firefox: <span class="number">0</span>,</span><br><span class="line">        safari: <span class="number">0</span>,</span><br><span class="line">        konq: <span class="number">0</span>,</span><br><span class="line">        opera: <span class="number">0</span>,</span><br><span class="line">        chrome: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">//具体的版本号</span></span><br><span class="line">        ver: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//平台、设备和操作系统</span></span><br><span class="line">    <span class="keyword">var</span> system = &#123;</span><br><span class="line">        win: <span class="literal">false</span>,</span><br><span class="line">        mac: <span class="literal">false</span>,</span><br><span class="line">        x11: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">//移动设备</span></span><br><span class="line">        iphone: <span class="literal">false</span>,</span><br><span class="line">        ipod: <span class="literal">false</span>,</span><br><span class="line">        ipad: <span class="literal">false</span>,</span><br><span class="line">        ios: <span class="literal">false</span>,</span><br><span class="line">        android: <span class="literal">false</span>,</span><br><span class="line">        nokiaN: <span class="literal">false</span>,</span><br><span class="line">        winMobile: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">//游戏系统</span></span><br><span class="line">        wii: <span class="literal">false</span>,</span><br><span class="line">        ps: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测呈现引擎和浏览器</span></span><br><span class="line">    <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.opera) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">window</span>.opera.version();</span><br><span class="line">        engine.opera = browser.opera = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/AppleWebKit\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.webkit = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">        <span class="comment">//确定是Chrome 还是Safari</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Chrome\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.chrome = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/Version\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.safari = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//近似地确定版本号</span></span><br><span class="line">            <span class="keyword">var</span> safariVersion = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (engine.webkit &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">312</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1.2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">412</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1.3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                safariVersion = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            browser.safari = browser.ver = safariVersion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/KHTML\/(\S+)/</span>.test(ua) || <span class="regexp">/Konqueror\/([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.khtml = browser.konq = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.gecko = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">        <span class="comment">//确定是不是Firefox</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Firefox\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.firefox = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/MSIE ([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.ie = browser.ie = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测浏览器</span></span><br><span class="line">    browser.ie = engine.ie;</span><br><span class="line">    browser.opera = engine.opera;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测平台</span></span><br><span class="line">    <span class="keyword">var</span> p = navigator.platform;</span><br><span class="line">    system.win = p.indexOf(<span class="string">"Win"</span>) == <span class="number">0</span>;</span><br><span class="line">    system.mac = p.indexOf(<span class="string">"Mac"</span>) == <span class="number">0</span>;</span><br><span class="line">    system.x11 = (p == <span class="string">"X11"</span>) || (p.indexOf(<span class="string">"Linux"</span>) == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测Windows 操作系统</span></span><br><span class="line">    <span class="keyword">if</span> (system.win) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/</span>.test(ua)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">RegExp</span>[<span class="string">"$1"</span>] == <span class="string">"NT"</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">RegExp</span>[<span class="string">"$2"</span>]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"5.0"</span>:</span><br><span class="line">                        system.win = <span class="string">"2000"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"5.1"</span>:</span><br><span class="line">                        system.win = <span class="string">"XP"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"6.0"</span>:</span><br><span class="line">                        system.win = <span class="string">"Vista"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"6.1"</span>:</span><br><span class="line">                        system.win = <span class="string">"7"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        system.win = <span class="string">"NT"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">RegExp</span>[<span class="string">"$1"</span>] == <span class="string">"9x"</span>) &#123;</span><br><span class="line">                system.win = <span class="string">"ME"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                system.win = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移动设备</span></span><br><span class="line">    system.iphone = ua.indexOf(<span class="string">"iPhone"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    system.ipod = ua.indexOf(<span class="string">"iPod"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    system.ipad = ua.indexOf(<span class="string">"iPad"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    system.nokiaN = ua.indexOf(<span class="string">"NokiaN"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//windows mobile</span></span><br><span class="line">    <span class="keyword">if</span> (system.win == <span class="string">"CE"</span>) &#123;</span><br><span class="line">        system.winMobile = system.win;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (system.win == <span class="string">"Ph"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Windows Phone OS (\d+.\d+)/</span>.test(ua)) &#123;</span><br><span class="line">            ;</span><br><span class="line">            system.win = <span class="string">"Phone"</span>;</span><br><span class="line">            system.winMobile = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>[<span class="string">"$1"</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//检测iOS 版本</span></span><br><span class="line">    <span class="keyword">if</span> (system.mac &amp;&amp; ua.indexOf(<span class="string">"Mobile"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/CPU (?:iPhone )?OS (\d+_\d+)/</span>.test(ua)) &#123;</span><br><span class="line">            system.ios = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>.$<span class="number">1.</span>replace(<span class="string">"_"</span>, <span class="string">"."</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            system.ios = <span class="number">2</span>; <span class="comment">//不能真正检测出来，所以只能猜测</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测Android 版本</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/Android (\d+\.\d+)/</span>.test(ua)) &#123;</span><br><span class="line">        system.android = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//游戏系统</span></span><br><span class="line">    system.wii = ua.indexOf(<span class="string">"Wii"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    system.ps = <span class="regexp">/playstation/i</span>.test(ua);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回这些对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        engine: engine,</span><br><span class="line">        browser: browser,</span><br><span class="line">        system: system</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p><p>用户代理检测是客户端检测的 <strong>最后一个选择</strong>，一般适用于下列情形：</p><ul><li>不能直接准确地使用能力检测或怪癖检测</li><li>同一款浏览器在不同平台下具备不同的能力</li><li>为了跟踪分析等目的需要知道确切的浏览器</li></ul><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;能力检测&quot;&gt;&lt;a href=&quot;#能力检测&quot; class=&quot;headerlink&quot; title=&quot;能力检测&quot;&gt;&lt;/a&gt;能力检测&lt;/h3&gt;&lt;p&gt;又称 &lt;strong&gt;特性检测&lt;/strong&gt;，指在 &lt;strong&gt;编写代码之前&lt;/strong&gt; 先检测 &lt;stron
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript BOM</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-BOM/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-BOM/</id>
    <published>2020-01-05T14:27:23.000Z</published>
    <updated>2020-01-05T15:00:31.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>BOM</strong> = browser Object Model 浏览器对象模型</p></blockquote><p>BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。其中，<strong>浏览器之间共有的对象</strong> 成为了事实标准。</p><p>W3C 为了把浏览器中JavaScript 最基本的部分标准化，已经将 <strong>BOM的主要方面</strong> 纳入了 <strong>HTML5 的规范</strong>中。</p><p><br><br><br><br><br></p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>BOM 的核心对象是window，它表示 <strong>浏览器的一个实例</strong>。<br>在浏览器中，window 对象有双重角色：</p><ol><li>通过JavaScript 访问浏览器窗口的一个接口；</li><li>ECMAScript 规定的Global 对象。</li></ol><p><br></p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>由于window 对象同时扮演着ECMAScript 中Global 对象的角色，因此 <strong>所有在全局作用域中声明的变量、函数 都会变成window 对象的属性和方法</strong>。</p><blockquote><p><u>定义全局变量</u> 与 <u>在window 对象上直接定义属性</u> 的差别：<br>全局变量不能通过delete 操作符删除，而直接在window 对象上定义的属性可以。</p></blockquote><ul><li>使用<code>var</code> 语句添加的window 属性有一个名为 <code>[[Configurable]]</code> 的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。</li><li>IE8及更早版本 在遇到使用delete删除window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。</li><li>尝试访问未声明的变量会抛出错误，但是<strong>通过 <u>查询window 对象</u>，可以知道某个可能未声明的变量是否存在</strong>。</li></ul><p><br></p><h4 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h4><ul><li>如果页面中包含框架，则每个框架都拥有自己的window 对象，并且保存在 <strong>frames 集合</strong>中。</li><li>在frames集合中，可以通过 <strong>数值索引</strong>（从0 开始，从左至右，从上到下）或者 <strong>框架名称</strong> 来访问相应的window 对象。</li><li>每个window 对象都有一个 <strong>name 属性</strong>，其中包含框架的名称（注意，除非最高层窗口是通过 <code>window.open()</code> 打开的，否则其window 对象的 <code>name</code> 属性不会包含任何值）。</li></ul><blockquote><p>对于 <u>在一个框架中</u> 编写的任何代码来说，其中的 <u>window 对象</u> 指向的都是 <u>那个框架的特定实例</u>，而非最高层的框架。</p></blockquote><p><strong>与框架有关的对象</strong>（window对象）：</p><ul><li><strong>top 对象</strong>：始终指向 <strong>最高（最外）层的框架</strong>，也就是浏览器窗口（使用它可以确保在一个框架中正确地访问另一个框架）；</li><li><strong>parent（父）对象</strong>：始终指向当前框架的 <strong>直接上层框架</strong>（在某些情况下，parent 有可能等于top；在没有框架的情况下，parent 一定等于top，此时它们都等于window）；</li><li><strong>self 对象</strong>：<strong>始终指向window</strong>；实际上，self 和window 对象可以互换使用（引入self 对象的目的只是为了与top 和parent 对象相对应）。</li></ul><p>以下是一个包含框架的页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"160,*"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在 <strong>最高层窗口</strong> 中，通过代码来访问上述代码中每个框架的不同方式如下：</p><img src="/2020/01/05/JavaScript-BOM/窗口关系.png" title="窗口关系"><p><br></p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><blockquote><p>窗口相对于屏幕左边和上边的位置：</p><ul><li><strong>screenLeft</strong> 和 <strong>screenTop</strong> —— Safari、Chrome、IE、Opera；</li><li><strong>screenX</strong> 和 <strong>screenY</strong> —— Firefox、Safari、Chrome。</li></ul></blockquote><p><strong>跨浏览器获取 窗口左边和上边的位置</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：</p><p>在IE、Opera 中，screenLeft 和screenTop 中保存的是 <strong>从屏幕左边和上边到由window 对象表示的<u>页面可见区域</u>的距离</strong>。换句话说，如果window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox 和Safari 中，screenY 或screenTop中保存的是 <strong><u>整个浏览器窗口</u>相对于屏幕的坐标值</strong>，即在窗口的y 轴坐标为0 时返回0。</p><p>Firefox、Safari 和Chrome <strong>始终返回页面中每个框架的top.screenX 和top.screenY 值</strong>。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX 和screenY 每次也都会返回相同的值。而IE 和Opera 则会给出框架相对于屏幕边界的精确坐标值。</p><p>最终结果，就是 <strong>无法</strong> 在跨浏览器的条件下取得窗口左边和上边的精确坐标值。</p></blockquote><p>将窗口精确地移动到一个新位置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将窗口移动到屏幕左上角</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//将窗向下移动100 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//将窗口移动到(200,300)</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">//将窗口向左移动50 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">-50</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7（及更高版本）中默认就<br>是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。</p><p><br></p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><blockquote><p>跨浏览器确定一个窗口的大小不是一件简单的事。<br>IE9+、Firefox、Safari、Opera 和Chrome 均为此提供了4 个属性：<strong>innerWidth</strong>、<strong>innerHeight</strong>、<strong>outerWidth</strong> 和<strong>outerHeight</strong>。在IE9+、Safari 和Firefox中，outerWidth 和outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的window 对象还是从某个框架访问）。在Opera 中，这两个属性的值表示页面视图容器①的大小。而innerWidth 和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome 中，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。</p><p>IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM 提供了页面可见区域的相关信息。</p><p>在IE、Firefox、Safari、Opera 和Chrome 中，<strong>document.documentElement.clientWidth</strong> 和<strong>document.documentElement.clientHeight</strong> 中保存了页面视口的信息。在IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过 <strong>document.body.clientWidth</strong> 和 <strong>document.body.clientHeight</strong> 取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentElement还是document.body 中的clientWidth 和clientHeight 属性，都可以取得视口的大小。</p></blockquote><p>虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123; <span class="comment">// 标准模式</span></span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>resizeTo()</code> 和 <code>resizeBy()</code> 方法可以调整浏览器窗口的大小：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整到100×100</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//调整到200×150</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//调整到 300×300</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">300</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure></p><p>在Opera和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window 对象使用。</p><p><br></p><h4 id="导航-amp-打开窗口"><a href="#导航-amp-打开窗口" class="headerlink" title="导航 &amp; 打开窗口"></a>导航 &amp; 打开窗口</h4><p><strong><code>window.open()</code></strong> 方法：<br>（1）导航到一个特定的URL；<br>（2）打开一个新的浏览器窗口。</p><blockquote><p>这个方法可以接收4 个参数：</p><ol><li>要加载的URL；</li><li>窗口目标；</li><li>一个特性字符串；</li><li>一个表示 <u>新页面是否取代浏览器历史记录中当前加载页面</u> 的布尔值。</li></ol></blockquote><p>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top 或_blank。</p><ol><li><strong>弹出窗口</strong></li></ol><p>如果给 <code>window.open()</code> 传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。</p><p>第三个参数是一个 <strong>逗号分隔的设置字符串</strong>，表示在新窗口中都显示哪些特性。其中，名值对以<strong>等号</strong>表示（注意，整个特性字符串中 <u>不允许出现空格</u>）。</p><p><code>window.open()</code> 方法会返回一个指向新窗口的引用。</p><p>调用 <code>close()</code> 方法还可以关闭 <code>window.open()</code>  新打开的窗口。弹出窗口关闭之后，窗口的引用仍然还在，但除了检测其 <strong>closed 属性</strong>之外，已经没有其他用处了</p><p>新创建的window 对象有一个 <strong><code>opener</code></strong> 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window 对象（top）中有定义，而且指向调用 <code>window.open()</code> 的窗口或框架。</p><p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口。</p><blockquote><p>有些浏览器（如IE8 和Chrome）会在 <strong>独立的进程</strong> 中运行每个标签页。当一个标签页打开另一个标签页时，<strong>如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中</strong>。在Chrome中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页。</p></blockquote><ol><li><strong>弹出窗口屏蔽程序</strong></li></ol><p>如果是浏览器 <strong>内置的屏蔽程序</strong> 阻止的弹出窗口，那么 <strong>window.open()很可能会返回null</strong>。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line"><span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是 <strong>浏览器扩展或其他程序</strong> 阻止的弹出窗口，那么<code>window.open()</code>通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 <code>window.open()</code> 的调用封装在一个<code>try-catch</code> 块中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="间歇调用-amp-超时调用"><a href="#间歇调用-amp-超时调用" class="headerlink" title="间歇调用 &amp; 超时调用"></a>间歇调用 &amp; 超时调用</h4><blockquote><p>JavaScript 是一个<strong>单线程</strong>序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript <strong>任务队列</strong>。这些任务会按照将它们添加到队列的顺序执行。</p></blockquote><p>JavaScript 是 <strong>单线程</strong>语言，但它允许通过设置 <strong>超时值</strong> 和 <strong>间歇时间值</strong> 来调度代码 <u>在特定的时刻</u> 执行。</p><ol><li>超时调用</li></ol><p><strong>超时调用</strong> 需要使用window 对象的 <strong><code>setTimeout()</code></strong> 方法。setTimeout()的第二个参数告诉JavaScript 再过多长时间 <strong>把当前任务添加到 JavaScript任务队列</strong>中。<u>如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行</u>。</p><p>调用 <code>setTimeout()</code> 之后，该方法会返回一个<strong>数值ID</strong>，表示超时调用。这个超时调用ID 是<strong>计划执行代码的唯一标识符</strong>，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 <code>clearTimeout()</code> 方法并将相应的超时调用ID 作为参数传递给它。</p><ol><li>间歇调用</li></ol><p><strong>间歇调用</strong> 的方法是 <strong><code>setInterval()</code></strong> ，它会按照 <u>指定的时间间隔</u> <strong>重复执行</strong> 代码，直至<u><strong>间歇调用被取消</strong></u>或者<u><strong>页面被卸载</strong></u>。</p><p>调用 <code>setInterval()</code> 方法同样也会返回一个 <strong>间歇调用ID</strong>，该ID 可用于在将来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用 <strong><code>clearInterval()</code></strong> 方法并传入相应的间歇调用ID。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">//如果执行次数达到了max 设定的值，则取消后续尚未执行的调用</span></span><br><span class="line">    <span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">        clearInterval(intervalId);</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p><p>使用超时调用来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">//如果执行次数未达到max 设定的值，则设置另一次超时调用</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">        setTimeout(incrementNumber, <span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。</p></blockquote><p><br></p><h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><ul><li>浏览器通过 <code>alert()</code>、<code>confirm()</code> 和 <code>prompt()</code> 方法可以调用系统对话框向用户显示消息。</li><li>系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。</li><li>通过这几个方法打开的对话框都是 <strong>同步</strong> 和 <strong>模态</strong> 的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。</li></ul><p><br><br><br><br><br></p><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location 提供了与 <strong>当前窗口中加载的文档</strong> 有关的信息，还提供了一些导航功能。</p><p>location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document 对象的属性；换句话说，<code>window.location</code> 和 <code>document.location</code> 引用的是同一个对象。</p><p><strong>location 对象的作用：</strong><br>（1）保存着当前文档的信息；<br>（2）它将URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段</p><p><img src="en-resource://database/631:1" alt="1553e212e5f94576dba0e8d40aaa45c1.png"><br><img src="/2020/01/05/JavaScript-BOM/location对象.png" title="location对象"></p><p><br></p><h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//取得查询字符串并去掉开头的问号</span></span><br><span class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">        <span class="comment">//保存数据的对象</span></span><br><span class="line">        args = &#123;&#125;,</span><br><span class="line">        <span class="comment">//取得每一项</span></span><br><span class="line">        items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">        item = <span class="literal">null</span>,</span><br><span class="line">        name = <span class="literal">null</span>,</span><br><span class="line">        value = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">//在for 循环中使用</span></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = items.length;</span><br><span class="line">    <span class="comment">//逐个将每一项添加到args 对象中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><p>使用location 对象可以通过很多方式来改变浏览器的位置。</p><h5 id="assign-URL-方法"><a href="#assign-URL-方法" class="headerlink" title="assign(URL) 方法"></a>assign(URL) 方法</h5><p>立即打开新URL 并在浏览器的历史记录中生成一条记录。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure></p><h5 id="href-属性"><a href="#href-属性" class="headerlink" title="href 属性"></a>href 属性</h5><p>如果是将 <code>location.href</code> 或 <code>window.location</code> 设置为一个URL 值，也会以该值调用 <code>assign()</code>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.wrox.com"</span>;</span><br><span class="line">location.href = <span class="string">"http://www.wrox.com"</span>;</span><br></pre></td></tr></table></figure></p><h5 id="hash-、search、hostname、pathname、port-属性"><a href="#hash-、search、hostname、pathname、port-属性" class="headerlink" title="hash 、search、hostname、pathname、port 属性"></a>hash 、search、hostname、pathname、port 属性</h5><p>修改location 对象的属性也可以改变当前加载的页面，浏览器的历史记录中会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设初始URL 为http://www.wrox.com/WileyCDA/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/WileyCDA/"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/mydir/"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com:8080/WileyCDA/"</span></span><br><span class="line">location.port = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>每次修改location 的属性（hash 除外），页面都会以新URL 重新加载。</p><blockquote><p>在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome 中，修改hash 的值会在浏览器的历史记录中生成一条新记录。在IE 的早期版本中，hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash 的URL 时才会被更新。</p></blockquote><h5 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h5><ul><li>只接受一个参数，即要导航到的URL；</li><li>不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面。</li></ul><h5 id="reload-方法"><a href="#reload-方法" class="headerlink" title="reload() 方法"></a>reload() 方法</h5><p>重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location.reload(); <span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line"></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure></p><p>位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。</p><p><br><br><br><br><br></p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象：识别客户端浏览器的事实标准。</p><p><br></p><h4 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h4><p>检测浏览器中是否安装了特定的插件：</p><ul><li><p>对于 <strong>非IE浏览器</strong>：<br>使用 <strong><code>plugins</code></strong> 数组，该数组中每一项都包含下列属性：</p><ol><li><strong>name</strong> ：插件的名字；</li><li><strong>description</strong>：插件的描述；</li><li><strong>filename</strong>：插件的文件名；</li><li><strong>length</strong>：插件所处理的 MIME 类型数量。</li></ol></li></ul><blockquote><p>一般来说，name 属性中会包含检测插件必需的所有信息，但有时候也不完全如此。</p></blockquote><pre><code>在检测插件时，需要像下面这样循环迭代每个插件并将插件的name 与给定的名字进行比较：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测插件（在IE 中无效）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = name.toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasPlugin(<span class="string">"Flash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasPlugin(<span class="string">"QuickTime"</span>));</span><br></pre></td></tr></table></figure><ul><li>对于 <strong>IE浏览器</strong>：<br>在IE 中检测插件的唯一方式就是使用专有的 <strong>ActiveXObject</strong> 类型，并<strong>尝试创建一个特定插件的实例</strong>。IE 是以 COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其 <strong>COM标识符</strong>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测IE 中的插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>));</span><br></pre></td></tr></table></figure></li></ul><p>典型的做法是 <u>针对每个插件分别创建检测函数</u>，而不是使用前面介绍的通用检测方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测所有浏览器中的Flash</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"Flash"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测所有浏览器中的QuickTime</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasQuickTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"QuickTime"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasFlash());</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasQuickTime());</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h4><p>Firefox 2 为navigator 对象新增了 <strong>registerContentHandler()</strong> 和 <strong>registerProtocolHandler()</strong> 方法（这两个方法是在HTML5 中定义的）。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着RSS 阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。</p><p><br><br><br><br><br></p><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。</p><p><br><br><br><br><br></p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history 是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history 对象与特定的window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进。</p><p>使用 <strong>go()</strong> 方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个<strong>整数值</strong>。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。也可以给go()方法传递一个<strong>字符串参数</strong>，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做。</p><p>另外，还可以使用两个简写方法 <strong>back()</strong> 和 <strong>forward()</strong> 来代替go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。</p><p>history 对象还有一个 <strong>length 属性</strong>，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length 等于0。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;BOM&lt;/strong&gt; = browser Object Model 浏览器对象模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。其中，&lt;strong&gt;浏览器
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数表达式</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-01-05T14:12:00.000Z</published>
    <updated>2020-01-05T14:23:27.935Z</updated>
    
    <content type="html"><![CDATA[<p>定义函数的方式：<br>（1）函数声明：函数声明提升；<br>（2）函数表达式：创建的函数是 匿名函数，在使用前必须先赋值。</p><blockquote><p><strong>函数声明提升</strong>（function declaration hoisting）：在执行代码之前会先读取函数声明。<br>&emsp;&emsp;<strong>匿名函数</strong>（anonymous function）：匿名函数的 name 属性是空字符串。</p></blockquote><p><br><br><br><br><br></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数：一个函数通过 <strong>名字</strong> 调用自身。<br><strong><code>arguments.callee</code></strong>  是一个 <strong>指向正在执行的函数的指针</strong>，因此可以用它来实现对函数的递归调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但在严格模式下，不能通过脚本访问 <code>arguments.callee</code>，访问这个属性会导致错误。不过，可以使用 <strong>命名函数表达式</strong> 来达成相同的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以上代码创建了一个名为 <code>f()</code> 的命名函数表达式，然后将它赋值给变量 <code>factorial</code>。<strong>即便把函数赋值给了另一个变量，函数的名字f 仍然有效。</strong></p><p><br><br><br><br><br></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p><strong>闭包</strong>：有权访问 <strong>另一个函数 作用域中的变量</strong> 的函数。<br><strong>创建闭包</strong> 的常见方式：在一个函数内部 创建另一个函数。</p><p>闭包会携带包含它的函数的作用域，因此比其他函数 <strong>占用更多内存</strong>，可通过<strong>赋值 null</strong> 来解除对匿名函数的引用，以便释放内存（JS垃圾回收机制）。</p><p><strong>闭包的作用</strong>：（1）模仿块级作用域；（2）在对象中创建私有变量。</p></blockquote><p><strong>ABOUT 函数调用：</strong></p><blockquote><p>当某个<strong>函数被调用</strong>时：<br>（1）会创建一个 <strong>执行环境</strong>（execution context）及相应的 <strong>作用域链</strong>。<br>（2）使用 <u>arguments 和 其他命名参数的值</u> 来 <strong>初始化</strong> 函数的 <strong>活动对象</strong>（activation object）。</p><p> <em>注意</em>：在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为 <strong>作用域链终点</strong> 的 <strong>全局执行环境</strong>。</p></blockquote><p><strong>ABOUT 执行环境：</strong></p><blockquote><p>后台的每个 <strong>执行环境</strong> 都有一个表示变量的对象——<strong>变量对象</strong>。</p><ul><li><strong>全局环境</strong> 的变量对象 <u>始终存在</u>。</li><li><strong>局部环境</strong> 的变量对象，则只在 <u>函数执行的过程中</u> 存在。</li></ul></blockquote><p><strong>ABOUT 作用域链：</strong></p><blockquote><ul><li><strong>作用域链</strong> 本质上是一个 <strong>指向变量对象的指针列表</strong>，它 <strong>只引用</strong> 但不实际包含变量对象。</li><li>无论什么时候在函数中访问一个变量时，就会 <u>从作用域链中</u> 搜索具有相应名字的变量。</li><li>一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</li><li><strong>在另一个函数内部定义的函数（闭包）</strong> 会将包含函数（即外部函数）的活动对象添加到它的作用域链中。包含函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象（<em><u>换句话说，包含函数执行完毕后，其执行环境的<strong>作用域链会被销毁</strong>，但其 <strong>活动对象仍被保留在内存</strong>中，直到匿名函数被销毁</u></em>）。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数（闭包）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建函数</span></span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">var</span> result = compareNames(&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;);</span><br><span class="line"><span class="comment">//解除对匿名函数的引用（以便释放内存）</span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><img src="/2020/01/05/JavaScript-函数表达式/闭包.png" title="JavaScript闭包"><p><br></p><h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><p>作用域链 <strong>引发的问题</strong>：闭包只能取得 包含函数中任何变量的 <strong>最后一个值</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数会返回一个函数数组，每个函数都返回10。</p><blockquote><p>原因分析：因为每个函数的作用域链中都保存着createFunctions() 函数的活动对象， 所以它们引用的都是同一个变量i 。当createFunctions()函数返回后，变量i 的值是10，此时每个函数都引用着保存变量i 的同一个变量对象，所以在每个函数内部i 的值都是10。</p></blockquote><p>我们可以通过 <strong>创建另一个匿名函数</strong> 强制让闭包的行为符合预期：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述函数返回的函数数组中，每个函数会返回 各自不同的索引值。</p><blockquote><p>原因分析：在这个版本中，我们 <strong>没有直接把闭包赋值给数组</strong>，而是<br>（1）定义了一个<strong>匿名函数</strong>，并将 <strong>立即执行该匿名函数的结果</strong> 赋给数组。<br>（2）匿名函数有一个 <strong>参数num</strong>，也就是最终的函数要返回的值。<br>（3）在调用每个匿名函数时，我们传入了 <strong>变量i</strong>。<br>（4）由于 <strong>函数参数</strong> 是 <strong>按值传递</strong> 的，所以就会 <strong>将变量i 的当前值复制给参数num</strong>。<br>（5）而在这个<strong>匿名函数内部</strong>，又创建并返回了一个<strong>访问num 的闭包</strong>。</p><p>这样一来，result 数组中的每个函数 <u>都有自己num 变量的一个副本</u> ，因此就可以返回各自不同的数值了。</p></blockquote><p><br></p><h4 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h4><p>在闭包中使用 this对象 可能引发的问题：<br><strong>匿名函数</strong> 的<strong>执行环境具有全局性</strong>，其 this对象通常指向 <strong>window</strong>。</p><blockquote><p>this 对象是在运行时基于函数的执行环境绑定的：</p><ul><li>在全局函数中，this 等于window；</li><li>当函数被作为某个对象的方法调用时，this 等于那个对象。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下）</span></span><br></pre></td></tr></table></figure><p>为什么匿名函数没有取得其包含作用域（或外部作用域）的this 对象呢？<br>每个函数在被调用时都会自动取得两个特殊变量：<code>this</code> 和 <code>arguments</code> 。内部函数在搜索这两个变量时，只会搜索到其<strong>活动对象</strong>为止。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"My Object"</span></span><br></pre></td></tr></table></figure></p><p>在定义匿名函数之前，我们把 this对象 赋值给了一个名叫 <code>that</code> 的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。</p><p><br></p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>在低版本IE（<ie9）中，如果 闭包的作用域链中 保存着一个html 元素，那么就意味着该元素将无法被销毁。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(element.id);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></ie9）中，如果></p><p>以上代码创建了一个作为element 元素事件处理程序的闭包，而这个闭包则又创建了一个 <strong>循环引用</strong>。element 的引用数至少为1，因此它所占用的内存永远不会被回收。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id; <span class="comment">// 消除循环引用</span></span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 闭包会引用 包含函数的整个活动对象，其中包含element</span></span><br><span class="line">    element = <span class="literal">null</span>; <span class="comment">// 消除对 DOM对象的引用，以减少其引用数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><blockquote><ul><li>JavaScript 没有块级作用域；</li><li>JavaScript 中，多次声明了同一个变量，js会对后续的声明视而不见，但是会执行后续声明中的变量初始化。</li></ul></blockquote><p><strong>匿名函数</strong> 可以用来 <strong>模仿块级作用域</strong> 并 <strong>避免多次声明同一变量</strong>。<br>用作块级作用域（通常称为<strong>私有作用域</strong>）的匿名函数的语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p><strong>将函数声明包含在一对圆括号中，表示它实际上是一个<u>函数表达式</u>。而紧随其后的另一对圆括号会<u>立即调用</u>这个函数。</strong> </p><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    alert(i); <span class="comment">//导致一个错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在匿名函数中定义的任何变量，都会在执行结束时被销毁。</p><blockquote><p>这种技术经常 在全局作用域中被用在函数外部，从而 <strong>限制向全局作用域中添加过多的变量和函数</strong>。<br>这种做法可以 <strong>减少闭包占用的内存问题</strong>，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</p></blockquote><p><br><br><br><br><br></p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><blockquote><p><strong>私有变量</strong>：任何在函数中定义的变量，包括 <u>函数参数</u>、<u>局部变量</u>、<u>在函数内部定义的其他函数</u>。（不能在函数外部访问这些变量）<br><strong>特权方法</strong>（privileged method）：有权访问私有变量和私有函数的公有方法。</p><p>在对象上 <strong>创建特权方法</strong> 的方式：<br>（1）在构造函数中定义特权方法；<br>（2）静态私有变量。</p></blockquote><p>在构造函数中定义特权方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缺点：必须使用 <u><em>构造函数模式</em></u> 来达到这个目的。<br><strong>构造函数模式</strong> 的缺点：针对每个实例都会创建同样一组新方法。<br>使用 <em>静态私有变量</em> 来实现特权方法可以避免这个问题。</p><p><br></p><h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><blockquote><p><strong>静态私有变量</strong>：在 <u><strong>私有作用域</strong></u> 中定义私有变量或函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p></blockquote><p>在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。<br><u>注意点</u>：</p><ol><li>这个模式在定义构造函数时并没有使用函数声明，而是使用了 <strong>函数表达式</strong>；</li><li>定义构造函数时，没有使用 <code>var</code> 关键字。</li></ol><blockquote><p>（1）函数声明只能创建 局部函数；<br>（2）初始化未经声明的变量，总是会创建一个 全局变量；但在严格模式下，给未经声明的变量赋值会导致错误。</p></blockquote><p>这个模式 与 在构造函数中定义特权方法 的<strong>主要区别</strong>，就在于 私<u><strong>有变量和函数是由实例共享的</strong></u>。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。</p><p><br></p><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><blockquote><p><strong>模块模式</strong>（module pattern）：为 单例 创建私有变量和特权方法。<br><strong>单例</strong>（singleton）：只有一个实例的对象。</p><p>按照惯例，JavaScript 是以 <strong>对象字面量</strong> 的方式来创建单例对象的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>这个模块模式使用了一个 <u>返回对象的匿名函数</u>。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。</p><p>简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 <strong>Object 的实例</strong>，因为最终要<u>通过一个对象字面量来表示</u>它。</p><p><br></p><h4 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h4><blockquote><p> 增强的模块模式 适合：<br>（1）单例必须是 <strong>某种类型的实例</strong>；<br>（2）必须 <strong>添加</strong> 某些 <strong>属性或方法</strong> 对其加以增强。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">    <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">    object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><blockquote><p>实现<strong>自定义类型</strong>的特权方法：（1）构造函数模式；（2）原型模式。<br>实现<strong>单例</strong>的特权方法：（1）模块模式；（2）增强的模块模式。</p></blockquote><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定义函数的方式：&lt;br&gt;（1）函数声明：函数声明提升；&lt;br&gt;（2）函数表达式：创建的函数是 匿名函数，在使用前必须先赋值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;函数声明提升&lt;/strong&gt;（function declaration hoisting）
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 字符串的扩展</title>
    <link href="http://fujiafeng.com/2020/01/05/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://fujiafeng.com/2020/01/05/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</id>
    <published>2020-01-05T13:07:48.000Z</published>
    <updated>2020-01-05T13:30:53.499Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><p><br></p><h3 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h3><p>JavaScript 共有 6 种方法可以<strong>表示一个字符</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>ES6 加强了对 Unicode 的支持，允许采用 <code>\uxxxx</code> 形式表示一个字符，其中 <code>xxxx</code>表示字符的 <strong>Unicode 码点</strong>。</p><p>但是，这种表示法只限于码点在 <code>\u0000</code> ~ <code>\uFFFF</code> 之间的字符。超出这个范围的字符，必须用 <strong>两个双字节</strong> 的形式表示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br><span class="line"><span class="comment">// 如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</span></span><br></pre></td></tr></table></figure></p><p>ES6 对这一点做出了改进，只要 <strong>将码点放入大括号</strong>，就能正确解读该字符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span></span><br><span class="line"><span class="comment">// "ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;<span class="number">6</span>F&#125; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，最后一个例子表明，<strong>大括号表示法与四字节的 UTF-16 编码是等价</strong>的。</p><p><br><br><br><br><br></p><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>ES6 为字符串添加了遍历器接口，使得字符串可以被 <strong><code>for...of</code> 循环遍历</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "f"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br></pre></td></tr></table></figure></p><p>除了遍历字符串，这个遍历器最大的优点是 <strong>可以识别大于0xFFFF的码点</strong>，传统的for循环无法识别这样的码点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);&#125;</span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，字符串text只有一个字符，但是 <code>for</code> 循环会认为它包含两个字符（都不可打印），而 <code>for...of</code> 循环会正确识别出这一个字符。</p><p><br><br><br><br><br></p><h3 id="直接输入-U-2028-和-U-2029"><a href="#直接输入-U-2028-和-U-2029" class="headerlink" title="直接输入 U+2028 和 U+2029"></a>直接输入 U+2028 和 U+2029</h3><p>JavaScript 字符串允许 <strong>直接输入字符</strong>，以及 <strong>输入字符的转义形式</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'中'</span> === <span class="string">'\u4e2d'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，<strong>只能</strong> 使用 <strong>转义形式</strong>：</p><ol><li><strong>U+005C</strong>：反斜杠（reverse solidus)</li><li><strong>U+000D</strong>：回车（carriage return）</li><li><strong>U+2028</strong>：行分隔符（line separator）</li><li><strong>U+2029</strong>：段分隔符（paragraph separator）</li><li><strong>U+000A</strong>：换行符（line feed）</li></ol><blockquote><p><strong>JSON 格式</strong> 允许字符串里面 <strong>直接使用</strong> U+2028（行分隔符）和 U+2029（段分隔符）。</p></blockquote><p>服务器输出的 JSON 被 <code>JSON.parse</code> 解析，就有可能直接报错。</p><p><br><br><br><br><br></p><h3 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h3><p>根据标准，JSON 数据必须是 UTF-8 编码。</p><blockquote><p>UTF-8 标准规定，<strong><code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点，不能单独使用，必须配对使用</strong> 。比如，<code>\uD834\uDF06</code>是两个码点，但是必须放在一起配对使用，代表字符 𝌆。这是为了表示码点大于 <code>0xFFFF</code> 的字符的一种变通方法。单独使用 <code>\uD834</code> 和 <code>\uDFO6</code> 这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\uDF06\uD834</code>并没有对应的字符。</p></blockquote><p><code>JSON.stringify()</code> 的问题在于，它可能返回 <code>0xD800</code> 到 <code>0xDFFF</code> 之间的单个码点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// "\u&#123;D834&#125;"</span></span><br></pre></td></tr></table></figure></p><p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// ""\\uD834""</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\uDF06\uD834'</span>) <span class="comment">// ""\\udf06\\ud834""</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><blockquote><p><strong>模板字符串</strong>（template string）是增强版的字符串，用 <strong>反引号（`）</strong> 标识。它可以当作普通字符串使用，也可以用来定义 <strong>多行字符串</strong>，或者 <strong>在字符串中嵌入变量</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure></p><p>如果使用模板字符串表示多行字符串，<strong>所有的 空格 和 缩进 都会被保留</strong>在输出之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure></p><p>可以使用 <code>trim</code> 方法消除字符串首尾的空白字符（换行符、空格及连续空格、制表符tab）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#list&apos;).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure></p><p>模板字符串中 <strong>嵌入变量</strong>，需要将变量名写在 <code>${}</code> 之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="comment">// 传统写法为</span></span><br><span class="line">      <span class="comment">// 'User '</span></span><br><span class="line">      <span class="comment">// + user.name</span></span><br><span class="line">      <span class="comment">// + ' is not authorized to do '</span></span><br><span class="line">      <span class="comment">// + action</span></span><br><span class="line">      <span class="comment">// + '.'</span></span><br><span class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>大括号内部可以放入任意的 JavaScript 表达式，可以 <strong>进行运算</strong>，以及 <strong>引用对象属性</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "3"</span></span><br></pre></td></tr></table></figure></p><p>模板字符串之中还能 <strong>调用函数</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure></p><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。</p><p>模板字符串甚至还能嵌套：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法如下</span></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tmpl(data));</span><br><span class="line"><span class="comment">// &lt;table&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;/table&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。</p><p><br><br><br><br><br></p><h3 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h3><p>（待补充）</p><p><br><br><br><br><br></p><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>“标签模板”功能（tagged template）：“标签模板”可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`123`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert(<span class="number">123</span>)</span><br></pre></td></tr></table></figure></p><p>标签模板其实不是模板，而是 <strong>函数调用</strong> 的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 这是函数实际的调用方式</span></span><br></pre></td></tr></table></figure></p><p>函数tag依次会接收到多个参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。<code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure></p><p>passthru函数采用 rest 参数的写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += literals[index]</span><br><span class="line">  <span class="keyword">return</span> output;&#125;</span><br></pre></td></tr></table></figure></p><p>“标签模板”的重要应用：</p><p>（1） <strong>过滤 HTML 字符串，防止用户输入恶意内容</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。</span></span><br><span class="line"><span class="keyword">let</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p><p>（2）多语言转换（国际化处理）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// "欢迎访问xxx，您是第xxxx位访问者！"</span></span><br></pre></td></tr></table></figure></p><p>（3）模拟 Mustache 之类的模板库（添加条件判断、循环处理等功能）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p><p>（4）在 JavaScript 语言之中嵌入其他语言<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jsx<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      ref='input'</span></span><br><span class="line"><span class="string">      onChange='<span class="subst">$&#123;<span class="keyword">this</span>.handleChange&#125;</span>'</span></span><br><span class="line"><span class="string">      defaultValue='<span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span>' /&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">   &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>上面的代码通过 <code>jsx</code> 函数，<u>将一个 <strong>DOM 字符串</strong>转为 <strong>React 对象</strong></u>。</p><p>模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存转义后的原字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// strings.raw[0] 为 "First line\\nSecond line"</span></span><br><span class="line">  <span class="comment">// 打印输出 "First line\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[“First line\nSecond line”]，那么strings.raw数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符的-Unico
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 变量的解构赋值</title>
    <link href="http://fujiafeng.com/2019/11/21/ES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://fujiafeng.com/2019/11/21/ES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</id>
    <published>2019-11-21T15:23:18.000Z</published>
    <updated>2019-11-21T15:37:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><blockquote><p><strong>解构</strong>（Destructuring）：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p></blockquote><p><br></p><blockquote><p><strong>常见用途</strong>：<br>（1）交换变量的值；<br>（2）从函数返回多个值；<br>（3）函数参数的定义；<br>（4）提取 JSON 数据；<br>（5）函数参数的默认值；<br>（6）遍历 Map 结构；<br>（7）输入模块的指定方法。</p></blockquote><p><br></p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>本质上，这种写法属于“<strong>模式匹配</strong>”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p><p>另一种情况是 <strong>不完全解构</strong>，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>对于 <strong>Set 结构</strong>，也可以使用数组的解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure></p><p>事实上，只要某种数据结构具有 <strong>Iterator 接口</strong>，都可以采用数组形式的解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><p><br></p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p><p>只有当一个数组成员<strong>严格等于undefined</strong>，默认值才会生效。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码等价于</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。</p></blockquote><p><br><br><br></p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>对象的解构与数组有一个重要的不同。数组的元素是 <strong>按次序排列</strong> 的，变量的取值由它的位置决定；而对象的属性<strong>没有次序</strong>，<strong>变量必须与属性同名</strong>，才能取到正确的值。</p><p>如果解构失败，变量的值等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p><strong>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;log(<span class="string">'hello'</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></p><p>上面代码的例一将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将console.log赋值到log变量。</p><p>对象的解构赋值是下面形式的简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br></pre></td></tr></table></figure></p><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><p>与数组一样，解构也可以用于 嵌套结构的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure></p><p>解构赋值中，<code>：</code>前边的 loc、start 都是模式，不是变量。</p><p>注意，对象的解构赋值可以取到继承的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，对象obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性。</p><p><br></p><h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><p>默认值生效的条件是，对象的属性值严格等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>（1）<u>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</u><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure></p><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。</p><p>（2）<u>解构赋值允许等号左边的模式之中，不放置任何变量名。</u>因此，可以写出非常古怪的赋值表达式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br><span class="line"><span class="comment">// 以上表达式毫无意义，但语法合法</span></span><br></pre></td></tr></table></figure></p><p>（3）<u>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</u><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“<strong>属性名表达式</strong>”。（对象的扩展）</p><p><br><br><br></p><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个 <strong>类似数组的对象</strong>。</p><p>类似数组的对象都有一个 <strong>length属性</strong>，因此还可以对这个属性解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><blockquote><p><strong>解构赋值的规则</strong>：只要等号右边的值不是对象或数组，就先将其转为对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p><p>由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p><p><br><br><br></p><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是 <code>x</code> 和 <code>y</code> 。</p><p>函数参数的解构也可以使用默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></p><p>undefined就会触发函数参数的默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><blockquote><p>ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>建议只要有可能，就不要在模式中放置圆括号。</p></blockquote><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><ol><li><p>变量声明语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;<span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;<span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;<span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数参数（属于变量声明）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure></li><li><p>赋值语句的模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p><strong><u>赋值语句</u> 的 <u>非模式部分</u></strong>，可以使用圆括号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>（1）<strong>交换变量的值</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></p><p>（2）<strong>从函数返回多个值</strong><br>函数只能返回一个值，如果要返回多个值，只能将它们放在 <strong>数组</strong> 或 <strong>对象</strong> 里返回。有了解构赋值，取出这些值就非常方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></p><p>（3）<strong>函数参数的定义</strong><br>解构赋值可以方便地将 <strong>一组参数</strong> 与 <strong>变量名</strong> 对应起来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>（4）<strong>提取 JSON 数据</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure></p><p>（5）<strong>函数参数的默认值</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>指定参数的默认值，就避免了在函数体内部再写 <code>var foo = config.foo || &#39;default foo&#39;;</code> 这样的语句。</p><p>（6）<strong>遍历 Map 结构</strong><br>任何部署了 Iterator 接口的对象，都可以用 <code>for...of</code> 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，<strong>获取键名和键值</strong> 就非常方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（7）<strong>输入模块的指定方法</strong><br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;解构&lt;/s
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - let和const命令</title>
    <link href="http://fujiafeng.com/2019/11/21/ES6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>http://fujiafeng.com/2019/11/21/ES6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</id>
    <published>2019-11-21T15:07:06.000Z</published>
    <updated>2019-11-21T15:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><ul><li><code>let</code>声明的变量只在它所在的代码块有效；</li><li><code>for</code>循环 的计数器，适合使用 <code>let</code>命令（设置循环变量的那部分是 父作用域，循环体内部 是一个单独的自作用域）；</li><li><code>let</code> 命令<strong>不存在变量提升</strong>；</li><li><strong>暂时性死区</strong>（TDZ=temporal dead zone）：在代码块内，使用 <code>let</code>声明变量之前，该变量不可用；</li><li>暂时性死区 意味着 <code>typeof</code> 不再是一个百分之百安全的操作（作为比较，如果一个变量根本没有被声明，使用 <code>typeof</code> 反而不会报错）</li><li><code>let</code> <strong>不允许</strong>在相同作用域内，<strong>重复声明</strong>同一变量（不能在函数内部重新声明参数）；</li></ul><p><br><br><br></p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这会导致：</p><ol><li>内层变量可能会覆盖外层变量（变量提升）；</li><li>用来计数的循环变量泄露为全局变量。</li></ol><p><br></p><p>ES6块级作用域</p><p>let实际上为 JavaScript 新增了块级作用域。</p><p>ES6 允许块级作用域的任意嵌套。</p><p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...&#125;());</span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...&#125;</span><br></pre></td></tr></table></figure></p><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要， <strong>块级作用域内部，优先使用函数表达式</strong> 。</p><p><br><br><br></p><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ul><li>const声明 <strong>只读常量</strong>；</li><li>const一旦声明变量，就必须 <strong>立即初始化</strong>，不能留到以后赋值；</li><li>只在声明所在的 <strong>块级作用域</strong> 内有效；</li><li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用；</li><li>不可重复声明。</li></ul><blockquote><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>如果真的想将对象冻结，应该使用Object.freeze方法。</p><p><code>const foo = Object.freeze({});</code></p></blockquote><p><br><br><br></p><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><ul><li>var 命令</li><li>function 命令</li><li>let 命令</li><li>const 命令</li><li>import 命令</li><li>class 命令</li></ul><p>ES5 只有两种声明变量的方法：var命令和function命令。</p><p><br><br><br></p><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><blockquote><p><strong>顶层对象</strong>，在浏览器环境指的是<strong>window对象</strong>，在 Node 指的是<strong>global对象</strong>。</p></blockquote><p>ES5 之中，顶层对象的属性与全局变量是等价的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>这导致了几个问题：</p><ol><li>没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；</li><li>程序员很容易不知不觉地就创建了全局变量（比如打字出错）；</li><li>顶层对象的属性是到处可以读写的，这非常不利于模块化编程。</li></ol><p>从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩：</p><ol><li>为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；</li><li>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h3><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p><ul><li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window；</li><li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self；</li><li>Node 里面，顶层对象是global，但其他环境都不支持。</li></ul><p>同一段代码为了能够在各种环境，都能<strong>取到顶层对象</strong>，现在一般是使用 <strong>this变量</strong>，但是有局限性：</p><ul><li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块；</li><li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined；</li><li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</li></ul><p>暂时可用的解决方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);&#125;;</span><br></pre></td></tr></table></figure></p><p>现在有一个提案，在语言标准的层面，<u>引入 <strong>globalThis</strong> 作为 <strong>顶层对象</strong></u>。</p><p>也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</p><p><strong>垫片库global-this</strong> 模拟了这个提案，可以在所有环境拿到globalThis。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>大约在冬季</title>
    <link href="http://fujiafeng.com/2019/11/20/%E5%A4%A7%E7%BA%A6%E5%9C%A8%E5%86%AC%E5%AD%A3/"/>
    <id>http://fujiafeng.com/2019/11/20/%E5%A4%A7%E7%BA%A6%E5%9C%A8%E5%86%AC%E5%AD%A3/</id>
    <published>2019-11-19T16:00:06.000Z</published>
    <updated>2019-11-19T14:40:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>-26-</p><p>感谢爱过的人和事</p><p>经历过的美好瞬间</p><p>让我无惧年龄的增长</p><p>‴ Be soft, be powerful </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;-26-&lt;/p&gt;
&lt;p&gt;感谢爱过的人和事&lt;/p&gt;
&lt;p&gt;经历过的美好瞬间&lt;/p&gt;
&lt;p&gt;让我无惧年龄的增长&lt;/p&gt;
&lt;p&gt;‴ Be soft, be powerful &lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>侧耳倾听 Vol.5</title>
    <link href="http://fujiafeng.com/2019/11/07/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-5/"/>
    <id>http://fujiafeng.com/2019/11/07/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-5/</id>
    <published>2019-11-07T15:38:26.000Z</published>
    <updated>2019-11-19T14:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>#抄句子#</em></p><blockquote><p>「我所有的自負皆來自我的自卑；<br>&emsp;&emsp;&emsp;所有的英雄氣概都來自於我的軟弱。<br>&emsp;&emsp;&emsp;嘴裡振振有詞是因為心裡滿是懷疑，<br>&emsp;&emsp;&emsp;深情是因為痛恨自己無情。<br>&emsp;&emsp;&emsp;這世界沒有一件事情是虛空而生的，<br>&emsp;&emsp;&emsp;站在光里，背後就會有陰影；<br>&emsp;&emsp;&emsp;這深夜裡一片寂靜，<br>&emsp;&emsp;&emsp;是因為你還沒有聽見聲音。」<br>&emsp;&emsp;&emsp;—— 馬良 《坦白書》</p></blockquote><p><br></p><blockquote><p>「世界要妳努力考取功名<br>&emsp;&emsp;&emsp;但真誠才是最大的本領」</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;#抄句子#&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「我所有的自負皆來自我的自卑；&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;所有的英雄氣概都來自於我的軟弱。&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;嘴裡振振有詞是因為心裡滿是懷疑，&lt;br&gt;&amp;emsp;&amp;
      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="侧耳倾听" scheme="http://fujiafeng.com/tags/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC/"/>
    
  </entry>
  
</feed>
