<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FU&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/73cc2ea2ef5bc47deb559bec0ea4d367</icon>
  <subtitle>Fashion passes ,   style remains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fujiafeng.com/"/>
  <updated>2020-01-09T06:19:18.582Z</updated>
  <id>http://fujiafeng.com/</id>
  
  <author>
    <name>Jiafeng Fu</name>
    <email>jiafengfu@github.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 入门</title>
    <link href="http://fujiafeng.com/2020/01/09/Docker-%E5%85%A5%E9%97%A8/"/>
    <id>http://fujiafeng.com/2020/01/09/Docker-%E5%85%A5%E9%97%A8/</id>
    <published>2020-01-09T05:48:21.000Z</published>
    <updated>2020-01-09T06:19:18.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h3><blockquote><p><strong>虚拟化</strong>：在硬件性能过剩的前提下，为不同应用提供某个级别的 <strong>运行环境隔离</strong>。（虚拟机是 硬件虚拟化，容器是 操作系统虚拟化）</p><p><strong>微服务</strong> 带来的两个问题：<br>（1）微服务拆分，使需要 <strong>打包、测试、上线</strong> 的量级信息大量增加；<br>（2）进行 <strong>服务器扩容</strong>，需要对 <strong>环境初始化</strong>，使其与原先的环境一致，部署工作繁重。</p></blockquote><p><strong>容器</strong> 完全使用 <strong>沙箱机制</strong>，相互之间不会有任何接口（类似 iPhone 的 app），性能开销极低。</p><p>Docker 是一个开源的 <strong>应用容器引擎</strong>：</p><ul><li>可以让开发者打包他们的应用以及依赖包到一个 <u><em>轻量级、可移植的容器</em></u> 中，然后发布到任何流行的 Linux 机器上；</li><li>也可以实现 <em><u>虚拟化</u></em>。</li></ul><blockquote><p><strong>Docker</strong><br>（1）解决了 应用程序 <strong>运行时隔离</strong> 的问题；<br>（2）Docker镜像 解决了 DevOps中 微服务运行的环境 难以在本地环境、测试环境及线上环境保持一致的问题（ <strong>运行环境迁移</strong> 问题）。<br>Docker 镜像可以打包： <u>应用程序 及其所有依赖</u>、<strong><u>整个操作系统</u></strong>。</p></blockquote><p><strong>应用场景</strong>：</p><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><p><br><br><br><br><br></p><h3 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h3><p>三个基本概念：</p><ul><li><strong>镜像</strong>（Image）：相当于一个 root 文件系统；</li><li><strong>容器</strong>（Container）：镜像运行时的实体，可以被创建、启动、停止、删除、暂停等；</li><li><strong>仓库</strong>（Repository）：代码控制中心，用来保存镜像。</li></ul><p>Docker 使用 <strong>客户端-服务器(C/S)架构模式</strong>，使用远程API 来管理和创建Docker 容器。</p><p>Docker 容器通过 Docker 镜像来创建。</p><blockquote><p>镜像和容器的关系，类似于面向对象编程中的类与对象，镜像是静态的定义。</p></blockquote><p><br><br><br><br><br></p><h3 id="Win10系统-Docker-安装"><a href="#Win10系统-Docker-安装" class="headerlink" title="Win10系统 Docker 安装"></a>Win10系统 Docker 安装</h3><h4 id="开启-Hyper-v"><a href="#开启-Hyper-v" class="headerlink" title="开启 Hyper-v"></a>开启 Hyper-v</h4><p>Windows【开始菜单】 -&gt; 右键菜单，选择【应用和功能】-&gt; 相关设置，点击【程序和功能】-&gt; 左侧菜单，点击【启用或关闭 Windows 功能】-&gt; 选中 Hyper-v，点击【确定】</p><p><br></p><h4 id="安装-Toolbox"><a href="#安装-Toolbox" class="headerlink" title="安装 Toolbox"></a>安装 Toolbox</h4><p>最新版 Toolbox 下载地址： <a href="https://www.docker.com/get-docker" target="_blank" rel="noopener">Docker 官方下载</a></p><p>点击【Download Desktop and Take a Tutorial】，下载Windows相应版本。<br><img src="/2020/01/09/Docker-入门/docker_download.png" title="docker_download"></p><p><br></p><h4 id="运行安装文件"><a href="#运行安装文件" class="headerlink" title="运行安装文件"></a>运行安装文件</h4><p>安装时，勾选 <u>使用 Windows容器</u>：<br><img src="/2020/01/09/Docker-入门/docker_install.png" title="docker_install"></p><p>安装完成后，查看版本信息：</p><img src="/2020/01/09/Docker-入门/docker_version.png" title="docker_version"><p><br></p><h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><p>在 【Settings -&gt; Daemon -&gt; Registry mirrors】中填写 镜像加速地址：<br><img src="/2020/01/09/Docker-入门/docker_speed.png" title="docker_speed"></p><p>参考可用的地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//dockerhub.azk8s.cn        #Azure 中国镜像 </span></span><br><span class="line">https:<span class="comment">//reg-mirror.qiniu.com      #七牛云加速器 </span></span><br><span class="line">https:<span class="comment">//registry.docker-cn.com　　 #Docker中国区</span></span><br><span class="line">http:<span class="comment">//hub-mirror.c.163.com　　　　 #网易</span></span><br><span class="line">https:<span class="comment">//docker.mirrors.ustc.edu.cn       #USTC</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="修改镜像文件存储地址"><a href="#修改镜像文件存储地址" class="headerlink" title="修改镜像文件存储地址"></a>修改镜像文件存储地址</h4><p>执行 <code>docker info</code> 查看Docker 系统信息：<br><img src="/2020/01/09/Docker-入门/docker_info.png" title="docker_info"></p><p>Windows 系统默认的镜像地址是 <code>C:\ProgramData\Docker</code> ，由于Docker 使用过程中可能会拉取很多镜像文件，建议将Docker 的镜像文件存储地址修改到其他盘。</p><h5 id="通过Docker-GUI-界面修改"><a href="#通过Docker-GUI-界面修改" class="headerlink" title="通过Docker GUI 界面修改"></a>通过Docker GUI 界面修改</h5><p>在 【Settings -&gt; Daemon】中勾选【Advanced】选项，添加 <strong>graph属性</strong> 配置自定义路径：<br><img src="/2020/01/09/Docker-入门/docker_graph.png" title="docker_graph"></p><p>配置后点击【Apply】Docker 将自动重启，再查看 <code>Root Dir</code> 显示如下：<br><img src="/2020/01/09/Docker-入门/docker_info_changed.png" title="docker_info_changed"></p><h5 id="使用-命令行-修改"><a href="#使用-命令行-修改" class="headerlink" title="使用 命令行 修改"></a>使用 命令行 修改</h5><p>停止运行 Docker：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl stop docker</span></span><br></pre></td></tr></table></figure></p><p>修改 daemon.json 文件，添加 graph属性配置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/docker/daemon.json</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Windows 上配置文件的默认位置： <code>%programdata%\docker\config\daemon.json</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是-Docker&quot;&gt;&lt;a href=&quot;#什么是-Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是 Docker&quot;&gt;&lt;/a&gt;什么是 Docker&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;：在硬件性
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://fujiafeng.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 简介</title>
    <link href="http://fujiafeng.com/2020/01/06/Vuex-%E7%AE%80%E4%BB%8B/"/>
    <id>http://fujiafeng.com/2020/01/06/Vuex-%E7%AE%80%E4%BB%8B/</id>
    <published>2020-01-06T07:55:21.000Z</published>
    <updated>2020-01-06T09:56:04.012Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex 官方文档</a></p><p><br></p><h3 id="Vuex是什么"><a href="#Vuex是什么" class="headerlink" title="Vuex是什么"></a>Vuex是什么</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的 <strong>状态管理模式</strong> 。它采用 <strong>集中式存储</strong> 管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><img src="/2020/01/06/Vuex-简介/vuex.png" title="vuex状态管理"><p>每一个 Vuex 应用的核心就是 <strong>store（仓库）</strong>。“store”基本上就是一个容器，它包含着你的应用中大部分的 <strong>状态 (state)</strong> 。</p><p>Vuex 和单纯的全局对象有以下两点不同：</p><ol><li>Vuex 的状态存储是 <strong>响应式</strong> 的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地 <strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ol><p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要<strong>在计算属性中返回</strong>即可。触发变化也仅仅是<strong>在组件的 methods 中提交 mutation</strong>。</p><p><br><br><br><br><br></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><h5 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h5><p>用一个对象就包含了全部的应用层级状态，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><h5 id="在Vue-组件中获取Vuex-状态"><a href="#在Vue-组件中获取Vuex-状态" class="headerlink" title="在Vue 组件中获取Vuex 状态"></a>在Vue 组件中获取Vuex 状态</h5><p>Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">    store,</span><br><span class="line">    components: &#123; Counter &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">        &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h5><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 </span></span><br><span class="line"><span class="comment">// Vuex.mapStateimport &#123; mapState &#125; from 'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span>])</span><br></pre></td></tr></table></figure></p><h5 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h5><p>mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="组件仍保有-局部状态"><a href="#组件仍保有-局部状态" class="headerlink" title="组件仍保有 局部状态"></a>组件仍保有 局部状态</h5><p><br></p><h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br>Getter 接受 state 作为其第一个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h5 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h5><p>Getter 也可以接受其他 getter 作为第二个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">store.getters.doneTodosCount <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure></p><p>我们可以在任何组件中使用它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>注意，getter 在通过属性访问时是<strong>作为Vue 的响应式系统的一部分缓存其中</strong> 的。</p><h5 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h5><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> (id) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.getTodoById(<span class="number">2</span>) <span class="comment">// -&gt; &#123; id: 2, text: '...', done: false &#125;</span></span><br></pre></td></tr></table></figure><p>注意，getter 在通过方法访问时，<strong>每次都会去进行调用，而不会缓存结果</strong>。</p><h5 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h5><p>将 store 中的 getter 映射到局部计算属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong> 。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <strong><code>store.commit</code></strong> 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure></p><h5 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h5><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>在大多数情况下，载荷应该是一个<strong>对象</strong>，这样可以<strong>包含多个字段</strong>并且记录的 mutation 会更易读：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h5><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Mutation-需遵守Vue-的响应规则"><a href="#Mutation-需遵守Vue-的响应规则" class="headerlink" title="Mutation 需遵守Vue 的响应规则"></a>Mutation 需遵守Vue 的响应规则</h5><p> Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p><ol><li>最好提前在 store 中<strong>初始化</strong>好所有所需属性。</li><li>当需要在对象上添加新属性时，你应该<ul><li>使用 Vue.set(obj, ‘newProp’, 123), 或者</li><li>以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h5 id="使用常量替代Mutation-事件类型"><a href="#使用常量替代Mutation-事件类型" class="headerlink" title="使用常量替代Mutation 事件类型"></a>使用常量替代Mutation 事件类型</h5><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h5><h5 id="在组件中提交Mutation"><a href="#在组件中提交Mutation" class="headerlink" title="在组件中提交Mutation"></a>在组件中提交Mutation</h5><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意 <strong>异步</strong>操作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p><p>实践中，我们会经常用到 ES2015 的 <strong>参数解构</strong> 来简化代码（特别是我们需要调用 commit 很多次的时候）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'increment'</span>)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h5><p>Action 通过 <strong><code>store.dispatch</code></strong> 方法触发：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure></p><p>可以在 action 内部执行 <strong>异步操作</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>Actions 支持同样的 <strong>载荷方式</strong> 和 <strong>对象方式</strong> 进行分发：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>购物车示例，涉及到 <strong>调用异步 API</strong> 和 <strong>分发多重 mutation</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h5><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <strong><code>mapActions</code></strong>  辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h5><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？如何才能组合多个 action，以处理更加复杂的异步流程？</p><p><code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另外一个 action 中也可以：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>利用 <strong>async / await</strong>，我们可以如下组合 action：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>一个 store.dispatch 在不同模块中可以<strong>触发多个 action 函数</strong>。在这种情况下，只有当<strong>所有</strong>触发函数<strong>完成后</strong>，返回的 <strong>Promise 才会执行</strong>。</p></blockquote><p><br></p><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。<br>为了解决以上问题，Vuex 允许我们<strong>将store 分割成模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure></p><h5 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h5><p>对于模块内部的 mutation 和 getter，接收的第一个参数是 <strong>模块的局部状态对象</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p><strong>默认</strong>情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局</strong>命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <strong><code>namespaced: true</code></strong> 的方式使其成为 <strong>带命名空间的模块</strong>。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容（module assets）</span></span><br><span class="line">      state: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters['account/isAdmin']</span></span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit('account/login')</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters['account/profile']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters['account/posts/popular']</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。</p><h6 id="在-带命名空间的模块内-访问全局内容（Global-Assets）"><a href="#在-带命名空间的模块内-访问全局内容（Global-Assets）" class="headerlink" title="在 带命名空间的模块内 访问全局内容（Global Assets）"></a>在 带命名空间的模块内 访问全局内容（Global Assets）</h6><ul><li><p>如果你希望使用全局 state 和 getter，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p></li><li><p>若需要在全局命名空间内分发 action 或提交 mutation，将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块的 getter 中，`getters` 被局部化了</span></span><br><span class="line">      <span class="comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span></span><br><span class="line">      someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter <span class="comment">// -&gt; 'foo/someOtherGetter'</span></span><br><span class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; 'someOtherGetter'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    actions: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span></span><br><span class="line">      <span class="comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span></span><br><span class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">        getters.someGetter <span class="comment">// -&gt; 'foo/someGetter'</span></span><br><span class="line">        rootGetters.someGetter <span class="comment">// -&gt; 'someGetter'</span></span><br><span class="line"></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>) <span class="comment">// -&gt; 'foo/someOtherAction'</span></span><br><span class="line">        dispatch(<span class="string">'someOtherAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someOtherAction'</span></span><br><span class="line"></span><br><span class="line">        commit(<span class="string">'someMutation'</span>) <span class="comment">// -&gt; 'foo/someMutation'</span></span><br><span class="line">        commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someMutation'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="在-带命名空间的模块-注册全局action"><a href="#在-带命名空间的模块-注册全局action" class="headerlink" title="在 带命名空间的模块 注册全局action"></a>在 带命名空间的模块 注册全局action</h6><p>若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  actions: &#123;</span><br><span class="line">    someOtherAction (&#123;dispatch&#125;) &#123;</span><br><span class="line">      dispatch(<span class="string">'someAction'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: <span class="literal">true</span>,</span><br><span class="line">          handler (namespacedContext, payload) &#123; ... &#125; <span class="comment">// -&gt; 'someAction'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h6><p>当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.some.nested.module.b</span><br><span class="line">  &#125;)&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'some/nested/module/foo'</span>, <span class="comment">// -&gt; this['some/nested/module/foo']()</span></span><br><span class="line">    <span class="string">'some/nested/module/bar'</span> <span class="comment">// -&gt; this['some/nested/module/bar']()</span></span><br><span class="line">  ])&#125;</span><br></pre></td></tr></table></figure></p><p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">'some/nested/module'</span>, &#123;</span><br><span class="line">    a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">    b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">  &#125;)&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions(<span class="string">'some/nested/module'</span>, [</span><br><span class="line">    <span class="string">'foo'</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">    <span class="string">'bar'</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">  ])&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过使用 <strong>createNamespacedHelpers</strong> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">'some/nested/module'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapState(&#123;</span><br><span class="line">      a: <span class="function"><span class="params">state</span> =&gt;</span> state.a,</span><br><span class="line">      b: <span class="function"><span class="params">state</span> =&gt;</span> state.b</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'foo'</span>,</span><br><span class="line">      <span class="string">'bar'</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h5><p>在 store 创建 <strong>之后</strong>，你可以使用 <code>store.registerModule</code> 方法注册模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.registerModule(<span class="string">'myModule'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)<span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.registerModule([<span class="string">'nested'</span>, <span class="string">'myModule'</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p><ul><li>模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，<code>vuex-router-sync</code> 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</li><li>可以使用 <code>store.unregisterModule(moduleName)</code> 来<strong>动态卸载模块</strong>。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。</li><li>在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 preserveState 选项将其归档：<code>store.registerModule(&#39;a&#39;, module, { preserveState: true })</code>。</li><li>当你设置 <code>preserveState: true</code> 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。</li></ul><h5 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h5><p>有时我们可能需要创建一个模块的多个实例，例如：</p><ul><li>创建多个 store，他们公用同一个模块 (例如当 runInNewContext 选项是 false 或 ‘once’ 时，为了在服务端渲染中避免有状态的单例)</li><li>在一个 store 中多次注册同一个模块</li></ul><p>使用一个函数来声明模块状态（仅 2.3.0+ 支持）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyReusableModule = &#123;</span><br><span class="line">  state () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// mutation, action 和 getter 等等...&#125;</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>一些需要遵守的规则：</p><ul><li>应用层级的状态应该集中到单个 store 对象中。</li><li>提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 action 里面。</li></ul><p><br><br><br><br><br></p><h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><p>严格模式中，表单元素使用 v-modal 可能导致错误：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"obj.message"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>假设 obj 是在计算属性中返回的 Vuex store的对象，则有两种解决方案：</p><p><br></p><h4 id="用-value-和-input-change-替代-v-modal"><a href="#用-value-和-input-change-替代-v-modal" class="headerlink" title="用 :value 和 @input/@change 替代 v-modal"></a>用 <code>:value</code> 和 <code>@input/@change</code> 替代 <code>v-modal</code></h4><p>给 <code>&lt;input&gt;</code> 中绑定 <code>value</code>，然后侦听 <code>input</code> 或 <code>change</code> 事件，在事件回调中调用 action ：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"message"</span> @<span class="attr">input</span>=<span class="string">"updateMessage"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(&#123;</span><br><span class="line">    message: <span class="function"><span class="params">state</span> =&gt;</span> state.obj.message</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  updateMessage (e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex 的 mutation 函数...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  updateMessage (state, message) &#123;</span><br><span class="line">    state.obj.message = message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="双向绑定-计算属性"><a href="#双向绑定-计算属性" class="headerlink" title="双向绑定 计算属性"></a>双向绑定 计算属性</h4><p>使用带有 <code>setter</code> 的双向绑定计算属性：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  message: &#123;</span><br><span class="line">    get () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.obj.message</span><br><span class="line">    &#125;,</span><br><span class="line">    set (value) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'updateMessage'</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://vuex.vuejs.org/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vuex 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;Vuex是什么&quot;&gt;&lt;a href=&quot;#Vuex是什么&quot; cla
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://fujiafeng.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面向对象的程序设计</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-01-05T14:40:37.000Z</published>
    <updated>2020-01-05T14:56:33.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p><strong>特性</strong>：为了实现JavaScript 引擎的，只有内部才用的特性（attribute），描述了属性（property）的各种特征。</p><ul><li>在JavaScript 中不能直接访问它们。</li><li>放在两对儿方括号中，例如[[Enumerable]]。</li></ul><p>ECMAScript 中有两种 <strong>属性</strong>：<u><strong>数据属性</strong></u> 和 <u><strong>访问器属性</strong></u>。</p><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>包含 <strong>一个数据值的位置</strong>。在这个位置可以读取和写入值。数据属性有4 个描述其行为的特性：</p><ul><li><strong>[[Configurable]]</strong> ：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><strong>[[Enumerable]]</strong> ：表示能否通过for-in 循环返回属性。</li><li><strong>[[Writable]]</strong> ：表示能否修改属性的值。</li><li><strong>[[Value]]</strong> ：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为 undefined。</li></ul><p><u><strong>修改属性默认的特性</strong></u>：使用ES5 的 <code>Object.defineProperty()</code> 方法（接收三个参数：属性所在的对象、属性名 和 一个描述符对象）：</p><ul><li>如果不指定，<code>configurable</code>、<code>enumerable</code> 和 <code>writable</code> 特性的默认值都是 false。</li><li>一旦把属性定义为不可配置的，就不能再把它变回可配置了。</li></ul><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>包含一对儿 getter 和setter 函数（非必需）：</p><ul><li>在读取访问器属性时，会调用<strong>getter 函数</strong>，这个函数负责返回有效的值；</li><li>在写入访问器属性时，会调用<strong>setter 函数</strong>并传入新值，这个函数负责决定如何处理数据。</li></ul><p>访问器属性有如下4 个特性：</p><ul><li><strong>[[Configurable]]</strong> ：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</li><li><strong>[[Enumerable]]</strong> ：表示能否通过for-in 循环返回属性。</li><li><strong>[[Get]]</strong> ：在读取属性时调用的函数。默认值为undefined。</li><li><strong>[[Set]]</strong> ：在写入属性时调用的函数。默认值为undefined。</li></ul><p><br></p><h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p>ES 5 定义了 <code>Object.defineProperties()</code> 方法，利用这个方法可以通过描述符一次定义多个属性。</p><p><br></p><h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p>使用ECMAScript 5 的 <code>Object.getOwnPropertyDescriptor()</code> 方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable 和value。</p><p><br><br><br><br><br></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>Object 构造函数 或 对象字面量 创建单个对象，有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p><p><br></p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式抽象了 创建具体对象的过程，在 JavaScript 中用函数来封装 以特定接口创建对象的细节：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></p><p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p><p><br></p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>按照惯例，<strong>构造函数</strong> 始终都应该以一个 <strong>大写字母开头</strong>，而非构造函数则应该以一个小写字母开头。</li><li>下划线开头是一种常用的记号，用于表示 <strong>只能通过对象方法访问</strong> 的属性。</li></ul></blockquote><p>使用 <strong>new 操作符</strong> 调用构造函数实际上会经历以下 4 个步骤：</p><p>(1) 创建一个新对象；<br>(2) 将构造函数的作用域赋给新对象（因此this 就指向了这个新对象）；<br>(3) 执行构造函数中的代码（为这个新对象添加属性）；<br>(4) 返回新对象。</p><p>对象的constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 <strong>instanceof</strong> 操作符要更可靠一些。</p><p><strong>创建自定义的构造函数</strong> 意味着将来可以将它的实例标识为一种特定的类型。</p><ol><li>将构造函数 当做函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当作构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">person.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到window</span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName(); <span class="comment">//"Kristen"</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>当在全局作用域中调用一个函数时，this 对象总是指向Global 对象（在浏览器中就是window 对象）</strong>。</p></blockquote><ol><li>构造函数的问题</li></ol><p>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</p><blockquote><p>ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><p>把sayName()函数的定义转移到了 构造函数外部。而在构造函数内部，我们将sayName 属性设置成等于全局的sayName 函数。由于sayName 包含的是一个指向函数的指针，因此person1 和person2 对象就共享了在全局作用域中定义的同一个sayName()函数。</p><p>这样做确实解决了两个函数做同一件事的问题，可是新问题又来了：</p><ol><li>在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。</li><li>如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</li></ol><p>这些问题可以通过使用 原型模式 来解决。</p><p><br></p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个 <strong>指针</strong>，指向一个对象，而这个对象的用途是 <strong>包含可以由特定类型的所有实例共享的属性和方法</strong>。使用原型对象的好处是 可以让所有对象实例共享它所包含的属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h5 id="1-理解原型对象"><a href="#1-理解原型对象" class="headerlink" title="1. 理解原型对象"></a>1. 理解原型对象</h5><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype 属性所在函数的指针。</p><p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 <strong><code>[[Prototype]]</code></strong> （内部属性），指向构造函数的原型对象。虽然在脚本中没有标准的方式访问 <code>[[Prototype]]</code> ，但Firefox、Safari 和Chrome 在每个对象上都支持一个属性 <code>__proto__</code> ；而在其他实现中，这个属性对脚本则是完全不可见的。需要明确的是，这个连接存在于 <strong>实例</strong> 与 <strong>构造函数的<u>原型对象</u></strong> 之间，而不是存在于实例与构造函数之间。</p><img src="/2020/01/05/JavaScript-面向对象的程序设计/理解原型对象.png" title="理解原型对象"><p>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 <strong>isPrototypeOf()</strong> 方法来确定对象之间是否存在这种关系。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>ECMAScript 5 增加了一个新方法，叫 <strong>Object.getPrototypeOf()</strong> ，在所有支持的实现中，这个方法返回 <code>[[Prototype]]</code> 的值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>读取对象属性：</p><ol><li>搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；</li><li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</li></ol></blockquote><ul><li>通过对象实例，可以访问保存在原型中的值，不能重写原型中的值；</li><li>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；</li><li>使用<code>delete</code> 操作符则可以完全删除实例属性，从而可以重新访问原型中的属性；</li></ul><p>使用 <strong>hasOwnProperty()</strong> 方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（它是从Object 继承来的）只在给定属性存在于对象实例中时，才会返回true。</p><h5 id="2-原型与-in-操作符"><a href="#2-原型与-in-操作符" class="headerlink" title="2. 原型与 in 操作符"></a>2. 原型与 in 操作符</h5><p>有两种方式使用in 操作符：</p><ul><li><strong>单独使用</strong>：in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中；</li><li><strong>在 <code>for-in</code> 循环中使用</strong>：返回的是所有能够 <strong>通过对象访问的</strong>、<strong>可枚举的</strong>（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。</li></ul><p>同时使用 <code>hasOwnProperty()</code> 方法和 <code>in</code> 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>要取得对象上<strong>所有<u>可枚举</u>的实例属性</strong>，可以使用ES5 的 <strong>Object.keys()</strong> 方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组；</li><li>如果你想要得到<strong>所有实例属性</strong>，无论它是否可枚举，都可以使用<strong>Object.getOwnPropertyNames()</strong> 方法。</li></ul><h5 id="3-更简单的原型语法"><a href="#3-更简单的原型语法" class="headerlink" title="3. 更简单的原型语法"></a>3. 更简单的原型语法</h5><p>为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是：用一个包含所有属性和方法的 <strong>对象字面量</strong> 来重写整个原型对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上述代码本质上完全 <strong>重写了默认的prototype 对象</strong>，因此 <strong>constructor</strong> 属性也就变成了新对象的constructor 属性（<strong>指向Object 构造函数</strong>），不再指向Person 函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor 已经无法确定对象的类型了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重设构造函数，只适用于ECMAScript 5 兼容的浏览器</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="4-原型的动态性"><a href="#4-原型的动态性" class="headerlink" title="4. 原型的动态性"></a>4. 原型的动态性</h5><p><strong>可以随时为原型添加属性和方法</strong>，并且修改能够<strong>立即在所有对象实例中反映</strong>出来；但如果是 <strong>重写整个原型对象</strong>，那么情况就不一样了：调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。</p><blockquote><p>请记住：实例中的指针 [[Prototype]] 仅指向原型，而不指向构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Nicholas",</span><br><span class="line">    age: 29,</span><br><span class="line">    job: "Software Engineer",</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">friend.sayName(); <span class="comment">//error</span></span><br></pre></td></tr></table></figure><img src="/2020/01/05/JavaScript-面向对象的程序设计/原型的动态性.png" title="原型的动态性"><p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。</p><h5 id="5-原生对象的原型"><a href="#5-原生对象的原型" class="headerlink" title="5. 原生对象的原型"></a>5. 原生对象的原型</h5><p>所有原生引用类型（Object、Array、String，等等）都在其 <strong>构造函数的原型</strong> 上定义了方法。</p><p>通过原生对象的原型，不仅可以 <strong>取得所有默认方法的引用</strong>，而且也可以 <strong>定义新方法</strong>。</p><h5 id="6-原型对象的问题"><a href="#6-原型对象的问题" class="headerlink" title="6. 原型对象的问题"></a>6. 原型对象的问题</h5><ol><li>它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值；</li><li>原型中所有属性是被很多实例共享的，对于 <strong>包含<u>引用类型值</u>的属性</strong> 来说，问题就比较突出了：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Nicholas",</span><br><span class="line">    age: 29,</span><br><span class="line">    job: "Software Engineer",</span><br><span class="line">    friends: ["Shelby", "Court"],</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="组合使用-构造函数模式-和-原型模式"><a href="#组合使用-构造函数模式-和-原型模式" class="headerlink" title="组合使用 构造函数模式 和 原型模式"></a>组合使用 构造函数模式 和 原型模式</h4><p><strong>创建自定义类型</strong> 的最常见方式。</p><ul><li>构造函数模式：定义 <strong>实例属性</strong>；</li><li>原型模式：定义 <strong>方法</strong> 和 <strong>共享属性</strong>；</li><li>支持向构造函数 <strong>传递参数</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">//"Shelby,Count"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><br></p><h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure></p><p><strong>if 语句</strong> 检查的可以是 <strong>初始化之后应该存在的任何属性或方法</strong> ——不必用一大堆if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用instanceof 操作符确定它的类型。</p><p><br></p><h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><p>寄生（parasitic）构造函数模式的基本思想是：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p><p>构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return 语句，可以重写调用构造函数时返回的值。</p><p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array 构造函数，因此可以使用这个模式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="comment">//添加值</span></span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回数组</span></span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line">alert(colors.toPipedString());   <span class="comment">//"red|blue|green"</span></span><br></pre></td></tr></table></figure></p><ul><li>返回的对象与构造函数或者与构造函数的原型属性之间没有关系；</li><li>不能依赖instanceof 操作符来确定对象类型。</li></ul><p><br></p><h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><p>稳妥对象（durable objects）指的是 <strong>没有公共属性</strong>，而且 <strong>其方法也不引用this</strong> 的对象。</p><p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：<br>一是新创建对象的实例方法不引用this；<br>二是不使用new 操作符调用构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回对象</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName(); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>OO语言支持两种继承方式：<br>（1）接口继承：只继承 方法签名；<br>（2）实现继承：继承 实际的方法。</p></blockquote><p>ECMAScript 只支持 <strong>实现继承</strong>，而且其实现继承主要是依靠 <strong>原型链</strong> 来实现的。</p><p><br></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><blockquote><p>构造函数、原型和实例的关系：<br>每个构造函数都有一个原型对象，<br>原型对象都包含一个指向构造函数的指针，<br>而实例都包含一个指向原型对象的内部指针。</p></blockquote><p>实现原型链的一种基本模式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>实现的本质是重写原型对象，代之以一个新类型的实例。实例以及构造函数和原型之间的关系如图：</p><img src="/2020/01/05/JavaScript-面向对象的程序设计/原型链.png" title="原型链"><p>通过实现原型链，本质上是扩展了 原型搜索机制。调用 <code>instance.getSuperValue()</code> 会经历三个搜索步骤：1）搜索实例；2）搜索 <code>SubType.prototype</code>；3）搜索 <code>SuperType.prototype</code>，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p><h5 id="1-别忘记默认的原型"><a href="#1-别忘记默认的原型" class="headerlink" title="1. 别忘记默认的原型"></a>1. 别忘记默认的原型</h5><blockquote><ul><li>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。</li><li>所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向 <code>Object.prototype</code> 。</li></ul></blockquote><p>上述代码完整的原型链如下：</p><img src="/2020/01/05/JavaScript-面向对象的程序设计/完整原型链.png" title="完整原型链"><h5 id="2-确定原型和实例的关系"><a href="#2-确定原型和实例的关系" class="headerlink" title="2. 确定原型和实例的关系"></a>2. 确定原型和实例的关系</h5><ul><li>使用 <strong><code>instanceof</code></strong> 操作符：测试实例与原型链中出现过的构造函数，结果就会返回true。</li><li>使用 <strong><code>isPrototypeOf()</code></strong> 方法：只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此 <code>isPrototypeOf()</code> 方法也会返回true。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="3-谨慎地定义方法"><a href="#3-谨慎地定义方法" class="headerlink" title="3. 谨慎地定义方法"></a>3. 谨慎地定义方法</h5><ul><li>给原型添加方法的代码一定要放在 <strong>替换原型的语句之后</strong>。</li><li>在通过原型链实现继承时，<strong>不能</strong> 使用 <strong>对象字面量</strong> 创建原型方法，因为这样做就会重写原型链。</li></ul><h5 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4. 原型链的问题"></a>4. 原型链的问题</h5><ul><li><strong>最主要的问题</strong>：包含引用类型值的原型。</li></ul><p>包含引用类型值的原型属性会被所有实例共享。</p><p>要在构造函数中，而不是在原型对象中定义属性。</p><ul><li><strong>第二个问题</strong>：在创建子类型的实例时，不能向超类型的构造函数中传递参数。</li></ul><blockquote><p>注：被继承的类一般称为“<strong>超类 / 父类</strong>”，继承的类称为“<strong>子类</strong>”。</p></blockquote><p><br></p><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>借用构造函数（constructor stealing）的技术（伪造对象 / 经典继承）：在<strong>子类型</strong>构造函数的内部调用<strong>超类型</strong>构造函数。</p><blockquote><p>函数只不过是 <strong>在特定环境中执行代码的对象</strong>，因此通过使用 <strong><code>apply()</code></strong> 和 <strong><code>call()</code></strong> 方法也可以在（将来）新创建的对象上执行构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);   <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors);   <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure><p>在新建的SubType 实例的环境下调用了SuperType 构造函数。这样一来，就会在新SubType 对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的colors 属性的副本了。</p><p>借用构造函数，就可以 在子类型构造函数中向超类型构造函数 <strong>传递参数</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType，同时还传递了参数</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">    <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name); <span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age); <span class="comment">//29</span></span><br></pre></td></tr></table></figure></p><p>为了确保 超类型构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p><p><strong>借用构造函数的问题</strong>：如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</p><p><br></p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承（combination inheritance）（伪经典继承）的思路是：使用 <strong>原型链</strong> 实现对原型属性和方法的继承，而通过 <strong>借用构造函数</strong> 来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);    <span class="comment">//  第二次调用 SuperType()</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();     <span class="comment">// 第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code> 和 <code>isPrototypeOf()</code> 能够用于识别基于组合继承创建的对象。</p><p><strong>组合继承的问题</strong>：无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p><p><br></p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure><p>从本质上讲，object()对传入其中的对象执行了一次 <strong>浅拷贝</strong>。</p><p>ECMAScript 5 通过新增 <strong><code>Object.create()</code></strong> 方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象 和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create() 与 object() 方法的行为相同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式（parasitic）继承：创建一个仅用于 <strong>封装继承过程</strong> 的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();   <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p></blockquote><p><br></p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>组合继承的问题如下：</p><img src="/2020/01/05/JavaScript-面向对象的程序设计/组合继承的问题.png" title="组合继承的问题"><p>所谓 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是 使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上例中只调用了一次 SuperType 构造函数，并且因此避免了在<code>SubType.prototype</code> 上面创建不必要的、多余的属性。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h3&gt;&lt;h4 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 客户端检测</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/</id>
    <published>2020-01-05T14:40:12.000Z</published>
    <updated>2020-01-05T14:42:45.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h3><p>又称 <strong>特性检测</strong>，指在 <strong>编写代码之前</strong> 先检测 <strong>特定浏览器的能力</strong>。</p><p>例如，脚本在调用某个函数之前，可能要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出来，让他们把注意力集中到相应的能力是否存在上。</p><p>采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。能力检测的基本模式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object.propertyInQuestion)&#123;</span><br><span class="line">    <span class="comment">//使用object.propertyInQuestion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意：</p><ul><li>先检测达成目的的最常用的特性</li><li>必须测试实际要用到的特性（检测某个或某几个特性并不能够确定浏览器）</li><li>能力检测无法精确地检测特定的浏览器和版本</li></ul><p>想知道某个特性是否会 <strong>按照适当方式行事</strong>（而不仅仅是某个特性存在），要尽量使用 <strong>typeof</strong> 进行能力检测。</p><p>由于 typeof 的行为不标准，在浏览器环境下测试任何对象的某个特性是否存在，可以使用下面这个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作者：Peter Michaux</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isHostMethod</span>(<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> object[property];</span><br><span class="line">    <span class="keyword">return</span> t == <span class="string">'function'</span> ||</span><br><span class="line">        (!!(t == <span class="string">'object'</span> &amp;&amp; object[property])) ||</span><br><span class="line">        t == <span class="string">'unknown'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果知道自己的应用程序需要使用某些特定的浏览器特性，那么最好是 <strong>一次性检测</strong> <strong>所有相关特性</strong>，而不要分别检测：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定浏览器是否支持Netscape 风格的插件</span></span><br><span class="line"><span class="keyword">var</span> hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);</span><br><span class="line"><span class="comment">//确定浏览器是否具有DOM1 级规定的能力</span></span><br><span class="line"><span class="keyword">var</span> hasDOM1 = !!(<span class="built_in">document</span>.getElementById &amp;&amp; <span class="built_in">document</span>.createElement &amp;&amp;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName);</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h3><p>怪癖检测（quirks detection）的目标是 <strong>识别浏览器的特殊行为</strong>。</p><p>怪癖 = <strong>浏览器实现中存在的bug</strong>，例如早期的WebKit 中就存在一个怪癖，即它会在for-in 循环中返回被隐藏的属性。</p><ul><li>建议仅检测那些对你有直接影响的“怪癖”</li><li>最好在脚本一开始就执行此类检测，以便尽早解决问题</li><li>怪癖检测无法精确地检测特定的浏览器和版本</li></ul><p><br><br><br><br><br></p><h3 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h3><p>通过检测 <strong>用户代理字符串</strong> 来识别浏览器。</p><ol><li>识别<strong>呈现引擎</strong></li></ol><p>主要检测五大呈现引擎：<br><strong>IE</strong>、<strong>Gecko</strong>、<strong>WebKit</strong>、<strong>KHTML</strong> 和 <strong>Opera</strong>。</p><p>要正确地识别呈现引擎，关键是 <strong>检测顺序</strong> 要正确：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opera<span class="function"> -&gt;</span> WebKit <span class="function"><span class="params">( 关键字 AppleWebKit )</span> -&gt;</span> KHTML<span class="function"> -&gt;</span> Gecko<span class="function"> -&gt;</span> IE</span><br></pre></td></tr></table></figure></p><ol><li>识别<strong>浏览器</strong></li></ol><p>苹果公司的Safari 浏览器和谷歌公司的Chrome 浏览器都使用WebKit 作为呈现引擎，但它们的 <strong>JavaScript 引擎</strong> 却不一样。</p><ol><li>识别<strong>平台</strong></li></ol><p>目前的三大主流平台是<br><strong>Windows</strong>、<strong>Mac</strong> 和 <strong>Unix</strong>（包括各种 <strong>Linux</strong>）。</p><p>在确定平台时，检测 <strong><code>navigator.platform</code></strong> ：可能的值包括”Win32”、”Win64”、<br>“MacPPC”、”MacIntel”、”X11”和”Linux i686”，这些值在不同的浏览器中都是一致的。</p><ol><li>识别<strong>Windows 操作系统</strong></li></ol><blockquote><p>在Windows XP 之前，Windows 有两种版本，分别针对家庭用户和商业用户。针对家庭用户的版本分别是Windows 95、98 和Windows ME。而针对商业用户的版本则一直叫做Window NT，最后由于市场原因改名为Windows 2000。这两个产品线后来又合并成一个由Windows NT 发展而来的公共的代码基，代表产品就是Windows XP。随后，微软在Windows XP 基础上又构建了Windows Vista。</p></blockquote><ol><li>识别<strong>移动设备</strong></li></ol><p>四种主要的移动设备平台：<br><strong>iOS设备</strong>、<strong>Android操作系统</strong>、<strong>诺基亚N系列</strong>、<strong>Windows Mobile</strong>。</p><ol><li>识别<strong>游戏系统</strong></li></ol><p>任天堂Wii 和Playstation 3 或者内置Web 浏览器，或者提供了浏览器下载。Wii 中的浏览器实际上是定制版的Opera，是专门为Wii Remote 设计的。Playstation 的浏览器是自己开发的，没有基于前面提到的任何呈现引擎。这两个浏览器中的用户代理字符串如下所示：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Opera/<span class="number">9.10</span> (Nintendo Wii;U; ; <span class="number">1621</span>; en)</span><br><span class="line"></span><br><span class="line">Mozilla/<span class="number">5.0</span> (PLAYSTATION <span class="number">3</span>; <span class="number">2.00</span>)</span><br></pre></td></tr></table></figure></p><p><br></p><p>完整的用户代理字符串检测脚本（包括检测呈现引擎、平台、Windows 操作系统、移动设备和游戏系统）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//呈现引擎</span></span><br><span class="line">    <span class="keyword">var</span> engine = &#123;</span><br><span class="line">        ie: <span class="number">0</span>,</span><br><span class="line">        gecko: <span class="number">0</span>,</span><br><span class="line">        webkit: <span class="number">0</span>,</span><br><span class="line">        khtml: <span class="number">0</span>,</span><br><span class="line">        opera: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">//完整的版本号</span></span><br><span class="line">        ver: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//浏览器</span></span><br><span class="line">    <span class="keyword">var</span> browser = &#123;</span><br><span class="line">        <span class="comment">//主要浏览器</span></span><br><span class="line">        ie: <span class="number">0</span>,</span><br><span class="line">        firefox: <span class="number">0</span>,</span><br><span class="line">        safari: <span class="number">0</span>,</span><br><span class="line">        konq: <span class="number">0</span>,</span><br><span class="line">        opera: <span class="number">0</span>,</span><br><span class="line">        chrome: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">//具体的版本号</span></span><br><span class="line">        ver: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//平台、设备和操作系统</span></span><br><span class="line">    <span class="keyword">var</span> system = &#123;</span><br><span class="line">        win: <span class="literal">false</span>,</span><br><span class="line">        mac: <span class="literal">false</span>,</span><br><span class="line">        x11: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">//移动设备</span></span><br><span class="line">        iphone: <span class="literal">false</span>,</span><br><span class="line">        ipod: <span class="literal">false</span>,</span><br><span class="line">        ipad: <span class="literal">false</span>,</span><br><span class="line">        ios: <span class="literal">false</span>,</span><br><span class="line">        android: <span class="literal">false</span>,</span><br><span class="line">        nokiaN: <span class="literal">false</span>,</span><br><span class="line">        winMobile: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">//游戏系统</span></span><br><span class="line">        wii: <span class="literal">false</span>,</span><br><span class="line">        ps: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测呈现引擎和浏览器</span></span><br><span class="line">    <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.opera) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">window</span>.opera.version();</span><br><span class="line">        engine.opera = browser.opera = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/AppleWebKit\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.webkit = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">        <span class="comment">//确定是Chrome 还是Safari</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Chrome\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.chrome = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/Version\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.safari = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//近似地确定版本号</span></span><br><span class="line">            <span class="keyword">var</span> safariVersion = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (engine.webkit &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">312</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1.2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (engine.webkit &lt; <span class="number">412</span>) &#123;</span><br><span class="line">                safariVersion = <span class="number">1.3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                safariVersion = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            browser.safari = browser.ver = safariVersion;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/KHTML\/(\S+)/</span>.test(ua) || <span class="regexp">/Konqueror\/([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.khtml = browser.konq = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.gecko = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">        <span class="comment">//确定是不是Firefox</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Firefox\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">            browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            browser.firefox = <span class="built_in">parseFloat</span>(browser.ver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/MSIE ([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">        engine.ver = browser.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">        engine.ie = browser.ie = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测浏览器</span></span><br><span class="line">    browser.ie = engine.ie;</span><br><span class="line">    browser.opera = engine.opera;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测平台</span></span><br><span class="line">    <span class="keyword">var</span> p = navigator.platform;</span><br><span class="line">    system.win = p.indexOf(<span class="string">"Win"</span>) == <span class="number">0</span>;</span><br><span class="line">    system.mac = p.indexOf(<span class="string">"Mac"</span>) == <span class="number">0</span>;</span><br><span class="line">    system.x11 = (p == <span class="string">"X11"</span>) || (p.indexOf(<span class="string">"Linux"</span>) == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测Windows 操作系统</span></span><br><span class="line">    <span class="keyword">if</span> (system.win) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/</span>.test(ua)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">RegExp</span>[<span class="string">"$1"</span>] == <span class="string">"NT"</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">RegExp</span>[<span class="string">"$2"</span>]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"5.0"</span>:</span><br><span class="line">                        system.win = <span class="string">"2000"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"5.1"</span>:</span><br><span class="line">                        system.win = <span class="string">"XP"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"6.0"</span>:</span><br><span class="line">                        system.win = <span class="string">"Vista"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"6.1"</span>:</span><br><span class="line">                        system.win = <span class="string">"7"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        system.win = <span class="string">"NT"</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">RegExp</span>[<span class="string">"$1"</span>] == <span class="string">"9x"</span>) &#123;</span><br><span class="line">                system.win = <span class="string">"ME"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                system.win = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移动设备</span></span><br><span class="line">    system.iphone = ua.indexOf(<span class="string">"iPhone"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    system.ipod = ua.indexOf(<span class="string">"iPod"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    system.ipad = ua.indexOf(<span class="string">"iPad"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    system.nokiaN = ua.indexOf(<span class="string">"NokiaN"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//windows mobile</span></span><br><span class="line">    <span class="keyword">if</span> (system.win == <span class="string">"CE"</span>) &#123;</span><br><span class="line">        system.winMobile = system.win;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (system.win == <span class="string">"Ph"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/Windows Phone OS (\d+.\d+)/</span>.test(ua)) &#123;</span><br><span class="line">            ;</span><br><span class="line">            system.win = <span class="string">"Phone"</span>;</span><br><span class="line">            system.winMobile = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>[<span class="string">"$1"</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//检测iOS 版本</span></span><br><span class="line">    <span class="keyword">if</span> (system.mac &amp;&amp; ua.indexOf(<span class="string">"Mobile"</span>) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/CPU (?:iPhone )?OS (\d+_\d+)/</span>.test(ua)) &#123;</span><br><span class="line">            system.ios = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>.$<span class="number">1.</span>replace(<span class="string">"_"</span>, <span class="string">"."</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            system.ios = <span class="number">2</span>; <span class="comment">//不能真正检测出来，所以只能猜测</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测Android 版本</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/Android (\d+\.\d+)/</span>.test(ua)) &#123;</span><br><span class="line">        system.android = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//游戏系统</span></span><br><span class="line">    system.wii = ua.indexOf(<span class="string">"Wii"</span>) &gt; <span class="number">-1</span>;</span><br><span class="line">    system.ps = <span class="regexp">/playstation/i</span>.test(ua);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回这些对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        engine: engine,</span><br><span class="line">        browser: browser,</span><br><span class="line">        system: system</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p><p>用户代理检测是客户端检测的 <strong>最后一个选择</strong>，一般适用于下列情形：</p><ul><li>不能直接准确地使用能力检测或怪癖检测</li><li>同一款浏览器在不同平台下具备不同的能力</li><li>为了跟踪分析等目的需要知道确切的浏览器</li></ul><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;能力检测&quot;&gt;&lt;a href=&quot;#能力检测&quot; class=&quot;headerlink&quot; title=&quot;能力检测&quot;&gt;&lt;/a&gt;能力检测&lt;/h3&gt;&lt;p&gt;又称 &lt;strong&gt;特性检测&lt;/strong&gt;，指在 &lt;strong&gt;编写代码之前&lt;/strong&gt; 先检测 &lt;stron
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript BOM</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-BOM/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-BOM/</id>
    <published>2020-01-05T14:27:23.000Z</published>
    <updated>2020-01-05T15:00:31.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>BOM</strong> = browser Object Model 浏览器对象模型</p></blockquote><p>BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。其中，<strong>浏览器之间共有的对象</strong> 成为了事实标准。</p><p>W3C 为了把浏览器中JavaScript 最基本的部分标准化，已经将 <strong>BOM的主要方面</strong> 纳入了 <strong>HTML5 的规范</strong>中。</p><p><br><br><br><br><br></p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>BOM 的核心对象是window，它表示 <strong>浏览器的一个实例</strong>。<br>在浏览器中，window 对象有双重角色：</p><ol><li>通过JavaScript 访问浏览器窗口的一个接口；</li><li>ECMAScript 规定的Global 对象。</li></ol><p><br></p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>由于window 对象同时扮演着ECMAScript 中Global 对象的角色，因此 <strong>所有在全局作用域中声明的变量、函数 都会变成window 对象的属性和方法</strong>。</p><blockquote><p><u>定义全局变量</u> 与 <u>在window 对象上直接定义属性</u> 的差别：<br>全局变量不能通过delete 操作符删除，而直接在window 对象上定义的属性可以。</p></blockquote><ul><li>使用<code>var</code> 语句添加的window 属性有一个名为 <code>[[Configurable]]</code> 的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。</li><li>IE8及更早版本 在遇到使用delete删除window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。</li><li>尝试访问未声明的变量会抛出错误，但是<strong>通过 <u>查询window 对象</u>，可以知道某个可能未声明的变量是否存在</strong>。</li></ul><p><br></p><h4 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h4><ul><li>如果页面中包含框架，则每个框架都拥有自己的window 对象，并且保存在 <strong>frames 集合</strong>中。</li><li>在frames集合中，可以通过 <strong>数值索引</strong>（从0 开始，从左至右，从上到下）或者 <strong>框架名称</strong> 来访问相应的window 对象。</li><li>每个window 对象都有一个 <strong>name 属性</strong>，其中包含框架的名称（注意，除非最高层窗口是通过 <code>window.open()</code> 打开的，否则其window 对象的 <code>name</code> 属性不会包含任何值）。</li></ul><blockquote><p>对于 <u>在一个框架中</u> 编写的任何代码来说，其中的 <u>window 对象</u> 指向的都是 <u>那个框架的特定实例</u>，而非最高层的框架。</p></blockquote><p><strong>与框架有关的对象</strong>（window对象）：</p><ul><li><strong>top 对象</strong>：始终指向 <strong>最高（最外）层的框架</strong>，也就是浏览器窗口（使用它可以确保在一个框架中正确地访问另一个框架）；</li><li><strong>parent（父）对象</strong>：始终指向当前框架的 <strong>直接上层框架</strong>（在某些情况下，parent 有可能等于top；在没有框架的情况下，parent 一定等于top，此时它们都等于window）；</li><li><strong>self 对象</strong>：<strong>始终指向window</strong>；实际上，self 和window 对象可以互换使用（引入self 对象的目的只是为了与top 和parent 对象相对应）。</li></ul><p>以下是一个包含框架的页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"160,*"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在 <strong>最高层窗口</strong> 中，通过代码来访问上述代码中每个框架的不同方式如下：</p><img src="/2020/01/05/JavaScript-BOM/窗口关系.png" title="窗口关系"><p><br></p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><blockquote><p>窗口相对于屏幕左边和上边的位置：</p><ul><li><strong>screenLeft</strong> 和 <strong>screenTop</strong> —— Safari、Chrome、IE、Opera；</li><li><strong>screenX</strong> 和 <strong>screenY</strong> —— Firefox、Safari、Chrome。</li></ul></blockquote><p><strong>跨浏览器获取 窗口左边和上边的位置</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：</p><p>在IE、Opera 中，screenLeft 和screenTop 中保存的是 <strong>从屏幕左边和上边到由window 对象表示的<u>页面可见区域</u>的距离</strong>。换句话说，如果window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox 和Safari 中，screenY 或screenTop中保存的是 <strong><u>整个浏览器窗口</u>相对于屏幕的坐标值</strong>，即在窗口的y 轴坐标为0 时返回0。</p><p>Firefox、Safari 和Chrome <strong>始终返回页面中每个框架的top.screenX 和top.screenY 值</strong>。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX 和screenY 每次也都会返回相同的值。而IE 和Opera 则会给出框架相对于屏幕边界的精确坐标值。</p><p>最终结果，就是 <strong>无法</strong> 在跨浏览器的条件下取得窗口左边和上边的精确坐标值。</p></blockquote><p>将窗口精确地移动到一个新位置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将窗口移动到屏幕左上角</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//将窗向下移动100 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//将窗口移动到(200,300)</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">//将窗口向左移动50 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">-50</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7（及更高版本）中默认就<br>是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。</p><p><br></p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><blockquote><p>跨浏览器确定一个窗口的大小不是一件简单的事。<br>IE9+、Firefox、Safari、Opera 和Chrome 均为此提供了4 个属性：<strong>innerWidth</strong>、<strong>innerHeight</strong>、<strong>outerWidth</strong> 和<strong>outerHeight</strong>。在IE9+、Safari 和Firefox中，outerWidth 和outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的window 对象还是从某个框架访问）。在Opera 中，这两个属性的值表示页面视图容器①的大小。而innerWidth 和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome 中，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。</p><p>IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM 提供了页面可见区域的相关信息。</p><p>在IE、Firefox、Safari、Opera 和Chrome 中，<strong>document.documentElement.clientWidth</strong> 和<strong>document.documentElement.clientHeight</strong> 中保存了页面视口的信息。在IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过 <strong>document.body.clientWidth</strong> 和 <strong>document.body.clientHeight</strong> 取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentElement还是document.body 中的clientWidth 和clientHeight 属性，都可以取得视口的大小。</p></blockquote><p>虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123; <span class="comment">// 标准模式</span></span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>resizeTo()</code> 和 <code>resizeBy()</code> 方法可以调整浏览器窗口的大小：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整到100×100</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//调整到200×150</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//调整到 300×300</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">300</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure></p><p>在Opera和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window 对象使用。</p><p><br></p><h4 id="导航-amp-打开窗口"><a href="#导航-amp-打开窗口" class="headerlink" title="导航 &amp; 打开窗口"></a>导航 &amp; 打开窗口</h4><p><strong><code>window.open()</code></strong> 方法：<br>（1）导航到一个特定的URL；<br>（2）打开一个新的浏览器窗口。</p><blockquote><p>这个方法可以接收4 个参数：</p><ol><li>要加载的URL；</li><li>窗口目标；</li><li>一个特性字符串；</li><li>一个表示 <u>新页面是否取代浏览器历史记录中当前加载页面</u> 的布尔值。</li></ol></blockquote><p>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top 或_blank。</p><ol><li><strong>弹出窗口</strong></li></ol><p>如果给 <code>window.open()</code> 传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。</p><p>第三个参数是一个 <strong>逗号分隔的设置字符串</strong>，表示在新窗口中都显示哪些特性。其中，名值对以<strong>等号</strong>表示（注意，整个特性字符串中 <u>不允许出现空格</u>）。</p><p><code>window.open()</code> 方法会返回一个指向新窗口的引用。</p><p>调用 <code>close()</code> 方法还可以关闭 <code>window.open()</code>  新打开的窗口。弹出窗口关闭之后，窗口的引用仍然还在，但除了检测其 <strong>closed 属性</strong>之外，已经没有其他用处了</p><p>新创建的window 对象有一个 <strong><code>opener</code></strong> 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window 对象（top）中有定义，而且指向调用 <code>window.open()</code> 的窗口或框架。</p><p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口。</p><blockquote><p>有些浏览器（如IE8 和Chrome）会在 <strong>独立的进程</strong> 中运行每个标签页。当一个标签页打开另一个标签页时，<strong>如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中</strong>。在Chrome中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页。</p></blockquote><ol><li><strong>弹出窗口屏蔽程序</strong></li></ol><p>如果是浏览器 <strong>内置的屏蔽程序</strong> 阻止的弹出窗口，那么 <strong>window.open()很可能会返回null</strong>。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line"><span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是 <strong>浏览器扩展或其他程序</strong> 阻止的弹出窗口，那么<code>window.open()</code>通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 <code>window.open()</code> 的调用封装在一个<code>try-catch</code> 块中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="间歇调用-amp-超时调用"><a href="#间歇调用-amp-超时调用" class="headerlink" title="间歇调用 &amp; 超时调用"></a>间歇调用 &amp; 超时调用</h4><blockquote><p>JavaScript 是一个<strong>单线程</strong>序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript <strong>任务队列</strong>。这些任务会按照将它们添加到队列的顺序执行。</p></blockquote><p>JavaScript 是 <strong>单线程</strong>语言，但它允许通过设置 <strong>超时值</strong> 和 <strong>间歇时间值</strong> 来调度代码 <u>在特定的时刻</u> 执行。</p><ol><li>超时调用</li></ol><p><strong>超时调用</strong> 需要使用window 对象的 <strong><code>setTimeout()</code></strong> 方法。setTimeout()的第二个参数告诉JavaScript 再过多长时间 <strong>把当前任务添加到 JavaScript任务队列</strong>中。<u>如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行</u>。</p><p>调用 <code>setTimeout()</code> 之后，该方法会返回一个<strong>数值ID</strong>，表示超时调用。这个超时调用ID 是<strong>计划执行代码的唯一标识符</strong>，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 <code>clearTimeout()</code> 方法并将相应的超时调用ID 作为参数传递给它。</p><ol><li>间歇调用</li></ol><p><strong>间歇调用</strong> 的方法是 <strong><code>setInterval()</code></strong> ，它会按照 <u>指定的时间间隔</u> <strong>重复执行</strong> 代码，直至<u><strong>间歇调用被取消</strong></u>或者<u><strong>页面被卸载</strong></u>。</p><p>调用 <code>setInterval()</code> 方法同样也会返回一个 <strong>间歇调用ID</strong>，该ID 可用于在将来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用 <strong><code>clearInterval()</code></strong> 方法并传入相应的间歇调用ID。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">//如果执行次数达到了max 设定的值，则取消后续尚未执行的调用</span></span><br><span class="line">    <span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">        clearInterval(intervalId);</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p><p>使用超时调用来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">//如果执行次数未达到max 设定的值，则设置另一次超时调用</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">        setTimeout(incrementNumber, <span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。</p></blockquote><p><br></p><h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><ul><li>浏览器通过 <code>alert()</code>、<code>confirm()</code> 和 <code>prompt()</code> 方法可以调用系统对话框向用户显示消息。</li><li>系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。</li><li>通过这几个方法打开的对话框都是 <strong>同步</strong> 和 <strong>模态</strong> 的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。</li></ul><p><br><br><br><br><br></p><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location 提供了与 <strong>当前窗口中加载的文档</strong> 有关的信息，还提供了一些导航功能。</p><p>location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document 对象的属性；换句话说，<code>window.location</code> 和 <code>document.location</code> 引用的是同一个对象。</p><p><strong>location 对象的作用：</strong><br>（1）保存着当前文档的信息；<br>（2）它将URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段</p><p><img src="en-resource://database/631:1" alt="1553e212e5f94576dba0e8d40aaa45c1.png"><br><img src="/2020/01/05/JavaScript-BOM/location对象.png" title="location对象"></p><p><br></p><h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//取得查询字符串并去掉开头的问号</span></span><br><span class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">        <span class="comment">//保存数据的对象</span></span><br><span class="line">        args = &#123;&#125;,</span><br><span class="line">        <span class="comment">//取得每一项</span></span><br><span class="line">        items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">        item = <span class="literal">null</span>,</span><br><span class="line">        name = <span class="literal">null</span>,</span><br><span class="line">        value = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">//在for 循环中使用</span></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = items.length;</span><br><span class="line">    <span class="comment">//逐个将每一项添加到args 对象中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><p>使用location 对象可以通过很多方式来改变浏览器的位置。</p><h5 id="assign-URL-方法"><a href="#assign-URL-方法" class="headerlink" title="assign(URL) 方法"></a>assign(URL) 方法</h5><p>立即打开新URL 并在浏览器的历史记录中生成一条记录。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure></p><h5 id="href-属性"><a href="#href-属性" class="headerlink" title="href 属性"></a>href 属性</h5><p>如果是将 <code>location.href</code> 或 <code>window.location</code> 设置为一个URL 值，也会以该值调用 <code>assign()</code>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.wrox.com"</span>;</span><br><span class="line">location.href = <span class="string">"http://www.wrox.com"</span>;</span><br></pre></td></tr></table></figure></p><h5 id="hash-、search、hostname、pathname、port-属性"><a href="#hash-、search、hostname、pathname、port-属性" class="headerlink" title="hash 、search、hostname、pathname、port 属性"></a>hash 、search、hostname、pathname、port 属性</h5><p>修改location 对象的属性也可以改变当前加载的页面，浏览器的历史记录中会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设初始URL 为http://www.wrox.com/WileyCDA/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/WileyCDA/"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/mydir/"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com:8080/WileyCDA/"</span></span><br><span class="line">location.port = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>每次修改location 的属性（hash 除外），页面都会以新URL 重新加载。</p><blockquote><p>在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome 中，修改hash 的值会在浏览器的历史记录中生成一条新记录。在IE 的早期版本中，hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash 的URL 时才会被更新。</p></blockquote><h5 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h5><ul><li>只接受一个参数，即要导航到的URL；</li><li>不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面。</li></ul><h5 id="reload-方法"><a href="#reload-方法" class="headerlink" title="reload() 方法"></a>reload() 方法</h5><p>重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location.reload(); <span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line"></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure></p><p>位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。</p><p><br><br><br><br><br></p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象：识别客户端浏览器的事实标准。</p><p><br></p><h4 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h4><p>检测浏览器中是否安装了特定的插件：</p><ul><li><p>对于 <strong>非IE浏览器</strong>：<br>使用 <strong><code>plugins</code></strong> 数组，该数组中每一项都包含下列属性：</p><ol><li><strong>name</strong> ：插件的名字；</li><li><strong>description</strong>：插件的描述；</li><li><strong>filename</strong>：插件的文件名；</li><li><strong>length</strong>：插件所处理的 MIME 类型数量。</li></ol></li></ul><blockquote><p>一般来说，name 属性中会包含检测插件必需的所有信息，但有时候也不完全如此。</p></blockquote><pre><code>在检测插件时，需要像下面这样循环迭代每个插件并将插件的name 与给定的名字进行比较：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测插件（在IE 中无效）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = name.toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasPlugin(<span class="string">"Flash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasPlugin(<span class="string">"QuickTime"</span>));</span><br></pre></td></tr></table></figure><ul><li>对于 <strong>IE浏览器</strong>：<br>在IE 中检测插件的唯一方式就是使用专有的 <strong>ActiveXObject</strong> 类型，并<strong>尝试创建一个特定插件的实例</strong>。IE 是以 COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其 <strong>COM标识符</strong>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测IE 中的插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>));</span><br></pre></td></tr></table></figure></li></ul><p>典型的做法是 <u>针对每个插件分别创建检测函数</u>，而不是使用前面介绍的通用检测方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测所有浏览器中的Flash</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"Flash"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测所有浏览器中的QuickTime</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasQuickTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"QuickTime"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasFlash());</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasQuickTime());</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h4><p>Firefox 2 为navigator 对象新增了 <strong>registerContentHandler()</strong> 和 <strong>registerProtocolHandler()</strong> 方法（这两个方法是在HTML5 中定义的）。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着RSS 阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。</p><p><br><br><br><br><br></p><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。</p><p><br><br><br><br><br></p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history 是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history 对象与特定的window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进。</p><p>使用 <strong>go()</strong> 方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个<strong>整数值</strong>。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。也可以给go()方法传递一个<strong>字符串参数</strong>，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做。</p><p>另外，还可以使用两个简写方法 <strong>back()</strong> 和 <strong>forward()</strong> 来代替go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。</p><p>history 对象还有一个 <strong>length 属性</strong>，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length 等于0。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;BOM&lt;/strong&gt; = browser Object Model 浏览器对象模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。其中，&lt;strong&gt;浏览器
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数表达式</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-01-05T14:12:00.000Z</published>
    <updated>2020-01-05T14:23:27.935Z</updated>
    
    <content type="html"><![CDATA[<p>定义函数的方式：<br>（1）函数声明：函数声明提升；<br>（2）函数表达式：创建的函数是 匿名函数，在使用前必须先赋值。</p><blockquote><p><strong>函数声明提升</strong>（function declaration hoisting）：在执行代码之前会先读取函数声明。<br>&emsp;&emsp;<strong>匿名函数</strong>（anonymous function）：匿名函数的 name 属性是空字符串。</p></blockquote><p><br><br><br><br><br></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数：一个函数通过 <strong>名字</strong> 调用自身。<br><strong><code>arguments.callee</code></strong>  是一个 <strong>指向正在执行的函数的指针</strong>，因此可以用它来实现对函数的递归调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但在严格模式下，不能通过脚本访问 <code>arguments.callee</code>，访问这个属性会导致错误。不过，可以使用 <strong>命名函数表达式</strong> 来达成相同的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以上代码创建了一个名为 <code>f()</code> 的命名函数表达式，然后将它赋值给变量 <code>factorial</code>。<strong>即便把函数赋值给了另一个变量，函数的名字f 仍然有效。</strong></p><p><br><br><br><br><br></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p><strong>闭包</strong>：有权访问 <strong>另一个函数 作用域中的变量</strong> 的函数。<br><strong>创建闭包</strong> 的常见方式：在一个函数内部 创建另一个函数。</p><p>闭包会携带包含它的函数的作用域，因此比其他函数 <strong>占用更多内存</strong>，可通过<strong>赋值 null</strong> 来解除对匿名函数的引用，以便释放内存（JS垃圾回收机制）。</p><p><strong>闭包的作用</strong>：（1）模仿块级作用域；（2）在对象中创建私有变量。</p></blockquote><p><strong>ABOUT 函数调用：</strong></p><blockquote><p>当某个<strong>函数被调用</strong>时：<br>（1）会创建一个 <strong>执行环境</strong>（execution context）及相应的 <strong>作用域链</strong>。<br>（2）使用 <u>arguments 和 其他命名参数的值</u> 来 <strong>初始化</strong> 函数的 <strong>活动对象</strong>（activation object）。</p><p> <em>注意</em>：在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为 <strong>作用域链终点</strong> 的 <strong>全局执行环境</strong>。</p></blockquote><p><strong>ABOUT 执行环境：</strong></p><blockquote><p>后台的每个 <strong>执行环境</strong> 都有一个表示变量的对象——<strong>变量对象</strong>。</p><ul><li><strong>全局环境</strong> 的变量对象 <u>始终存在</u>。</li><li><strong>局部环境</strong> 的变量对象，则只在 <u>函数执行的过程中</u> 存在。</li></ul></blockquote><p><strong>ABOUT 作用域链：</strong></p><blockquote><ul><li><strong>作用域链</strong> 本质上是一个 <strong>指向变量对象的指针列表</strong>，它 <strong>只引用</strong> 但不实际包含变量对象。</li><li>无论什么时候在函数中访问一个变量时，就会 <u>从作用域链中</u> 搜索具有相应名字的变量。</li><li>一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</li><li><strong>在另一个函数内部定义的函数（闭包）</strong> 会将包含函数（即外部函数）的活动对象添加到它的作用域链中。包含函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象（<em><u>换句话说，包含函数执行完毕后，其执行环境的<strong>作用域链会被销毁</strong>，但其 <strong>活动对象仍被保留在内存</strong>中，直到匿名函数被销毁</u></em>）。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数（闭包）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建函数</span></span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">var</span> result = compareNames(&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;);</span><br><span class="line"><span class="comment">//解除对匿名函数的引用（以便释放内存）</span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><img src="/2020/01/05/JavaScript-函数表达式/闭包.png" title="JavaScript闭包"><p><br></p><h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><p>作用域链 <strong>引发的问题</strong>：闭包只能取得 包含函数中任何变量的 <strong>最后一个值</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数会返回一个函数数组，每个函数都返回10。</p><blockquote><p>原因分析：因为每个函数的作用域链中都保存着createFunctions() 函数的活动对象， 所以它们引用的都是同一个变量i 。当createFunctions()函数返回后，变量i 的值是10，此时每个函数都引用着保存变量i 的同一个变量对象，所以在每个函数内部i 的值都是10。</p></blockquote><p>我们可以通过 <strong>创建另一个匿名函数</strong> 强制让闭包的行为符合预期：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述函数返回的函数数组中，每个函数会返回 各自不同的索引值。</p><blockquote><p>原因分析：在这个版本中，我们 <strong>没有直接把闭包赋值给数组</strong>，而是<br>（1）定义了一个<strong>匿名函数</strong>，并将 <strong>立即执行该匿名函数的结果</strong> 赋给数组。<br>（2）匿名函数有一个 <strong>参数num</strong>，也就是最终的函数要返回的值。<br>（3）在调用每个匿名函数时，我们传入了 <strong>变量i</strong>。<br>（4）由于 <strong>函数参数</strong> 是 <strong>按值传递</strong> 的，所以就会 <strong>将变量i 的当前值复制给参数num</strong>。<br>（5）而在这个<strong>匿名函数内部</strong>，又创建并返回了一个<strong>访问num 的闭包</strong>。</p><p>这样一来，result 数组中的每个函数 <u>都有自己num 变量的一个副本</u> ，因此就可以返回各自不同的数值了。</p></blockquote><p><br></p><h4 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h4><p>在闭包中使用 this对象 可能引发的问题：<br><strong>匿名函数</strong> 的<strong>执行环境具有全局性</strong>，其 this对象通常指向 <strong>window</strong>。</p><blockquote><p>this 对象是在运行时基于函数的执行环境绑定的：</p><ul><li>在全局函数中，this 等于window；</li><li>当函数被作为某个对象的方法调用时，this 等于那个对象。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下）</span></span><br></pre></td></tr></table></figure><p>为什么匿名函数没有取得其包含作用域（或外部作用域）的this 对象呢？<br>每个函数在被调用时都会自动取得两个特殊变量：<code>this</code> 和 <code>arguments</code> 。内部函数在搜索这两个变量时，只会搜索到其<strong>活动对象</strong>为止。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"My Object"</span></span><br></pre></td></tr></table></figure></p><p>在定义匿名函数之前，我们把 this对象 赋值给了一个名叫 <code>that</code> 的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。</p><p><br></p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>在低版本IE（<ie9）中，如果 闭包的作用域链中 保存着一个html 元素，那么就意味着该元素将无法被销毁。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(element.id);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></ie9）中，如果></p><p>以上代码创建了一个作为element 元素事件处理程序的闭包，而这个闭包则又创建了一个 <strong>循环引用</strong>。element 的引用数至少为1，因此它所占用的内存永远不会被回收。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id; <span class="comment">// 消除循环引用</span></span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 闭包会引用 包含函数的整个活动对象，其中包含element</span></span><br><span class="line">    element = <span class="literal">null</span>; <span class="comment">// 消除对 DOM对象的引用，以减少其引用数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><blockquote><ul><li>JavaScript 没有块级作用域；</li><li>JavaScript 中，多次声明了同一个变量，js会对后续的声明视而不见，但是会执行后续声明中的变量初始化。</li></ul></blockquote><p><strong>匿名函数</strong> 可以用来 <strong>模仿块级作用域</strong> 并 <strong>避免多次声明同一变量</strong>。<br>用作块级作用域（通常称为<strong>私有作用域</strong>）的匿名函数的语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p><strong>将函数声明包含在一对圆括号中，表示它实际上是一个<u>函数表达式</u>。而紧随其后的另一对圆括号会<u>立即调用</u>这个函数。</strong> </p><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    alert(i); <span class="comment">//导致一个错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在匿名函数中定义的任何变量，都会在执行结束时被销毁。</p><blockquote><p>这种技术经常 在全局作用域中被用在函数外部，从而 <strong>限制向全局作用域中添加过多的变量和函数</strong>。<br>这种做法可以 <strong>减少闭包占用的内存问题</strong>，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</p></blockquote><p><br><br><br><br><br></p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><blockquote><p><strong>私有变量</strong>：任何在函数中定义的变量，包括 <u>函数参数</u>、<u>局部变量</u>、<u>在函数内部定义的其他函数</u>。（不能在函数外部访问这些变量）<br><strong>特权方法</strong>（privileged method）：有权访问私有变量和私有函数的公有方法。</p><p>在对象上 <strong>创建特权方法</strong> 的方式：<br>（1）在构造函数中定义特权方法；<br>（2）静态私有变量。</p></blockquote><p>在构造函数中定义特权方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缺点：必须使用 <u><em>构造函数模式</em></u> 来达到这个目的。<br><strong>构造函数模式</strong> 的缺点：针对每个实例都会创建同样一组新方法。<br>使用 <em>静态私有变量</em> 来实现特权方法可以避免这个问题。</p><p><br></p><h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><blockquote><p><strong>静态私有变量</strong>：在 <u><strong>私有作用域</strong></u> 中定义私有变量或函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p></blockquote><p>在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。<br><u>注意点</u>：</p><ol><li>这个模式在定义构造函数时并没有使用函数声明，而是使用了 <strong>函数表达式</strong>；</li><li>定义构造函数时，没有使用 <code>var</code> 关键字。</li></ol><blockquote><p>（1）函数声明只能创建 局部函数；<br>（2）初始化未经声明的变量，总是会创建一个 全局变量；但在严格模式下，给未经声明的变量赋值会导致错误。</p></blockquote><p>这个模式 与 在构造函数中定义特权方法 的<strong>主要区别</strong>，就在于 私<u><strong>有变量和函数是由实例共享的</strong></u>。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。</p><p><br></p><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><blockquote><p><strong>模块模式</strong>（module pattern）：为 单例 创建私有变量和特权方法。<br><strong>单例</strong>（singleton）：只有一个实例的对象。</p><p>按照惯例，JavaScript 是以 <strong>对象字面量</strong> 的方式来创建单例对象的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>这个模块模式使用了一个 <u>返回对象的匿名函数</u>。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。</p><p>简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 <strong>Object 的实例</strong>，因为最终要<u>通过一个对象字面量来表示</u>它。</p><p><br></p><h4 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h4><blockquote><p> 增强的模块模式 适合：<br>（1）单例必须是 <strong>某种类型的实例</strong>；<br>（2）必须 <strong>添加</strong> 某些 <strong>属性或方法</strong> 对其加以增强。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">    <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">    object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><blockquote><p>实现<strong>自定义类型</strong>的特权方法：（1）构造函数模式；（2）原型模式。<br>实现<strong>单例</strong>的特权方法：（1）模块模式；（2）增强的模块模式。</p></blockquote><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定义函数的方式：&lt;br&gt;（1）函数声明：函数声明提升；&lt;br&gt;（2）函数表达式：创建的函数是 匿名函数，在使用前必须先赋值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;函数声明提升&lt;/strong&gt;（function declaration hoisting）
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 字符串的扩展</title>
    <link href="http://fujiafeng.com/2020/01/05/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://fujiafeng.com/2020/01/05/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</id>
    <published>2020-01-05T13:07:48.000Z</published>
    <updated>2020-01-05T13:30:53.499Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><p><br></p><h3 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h3><p>JavaScript 共有 6 种方法可以<strong>表示一个字符</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>ES6 加强了对 Unicode 的支持，允许采用 <code>\uxxxx</code> 形式表示一个字符，其中 <code>xxxx</code>表示字符的 <strong>Unicode 码点</strong>。</p><p>但是，这种表示法只限于码点在 <code>\u0000</code> ~ <code>\uFFFF</code> 之间的字符。超出这个范围的字符，必须用 <strong>两个双字节</strong> 的形式表示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br><span class="line"><span class="comment">// 如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</span></span><br></pre></td></tr></table></figure></p><p>ES6 对这一点做出了改进，只要 <strong>将码点放入大括号</strong>，就能正确解读该字符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span></span><br><span class="line"><span class="comment">// "ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;<span class="number">6</span>F&#125; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，最后一个例子表明，<strong>大括号表示法与四字节的 UTF-16 编码是等价</strong>的。</p><p><br><br><br><br><br></p><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>ES6 为字符串添加了遍历器接口，使得字符串可以被 <strong><code>for...of</code> 循环遍历</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "f"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br></pre></td></tr></table></figure></p><p>除了遍历字符串，这个遍历器最大的优点是 <strong>可以识别大于0xFFFF的码点</strong>，传统的for循环无法识别这样的码点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);&#125;</span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，字符串text只有一个字符，但是 <code>for</code> 循环会认为它包含两个字符（都不可打印），而 <code>for...of</code> 循环会正确识别出这一个字符。</p><p><br><br><br><br><br></p><h3 id="直接输入-U-2028-和-U-2029"><a href="#直接输入-U-2028-和-U-2029" class="headerlink" title="直接输入 U+2028 和 U+2029"></a>直接输入 U+2028 和 U+2029</h3><p>JavaScript 字符串允许 <strong>直接输入字符</strong>，以及 <strong>输入字符的转义形式</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'中'</span> === <span class="string">'\u4e2d'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，<strong>只能</strong> 使用 <strong>转义形式</strong>：</p><ol><li><strong>U+005C</strong>：反斜杠（reverse solidus)</li><li><strong>U+000D</strong>：回车（carriage return）</li><li><strong>U+2028</strong>：行分隔符（line separator）</li><li><strong>U+2029</strong>：段分隔符（paragraph separator）</li><li><strong>U+000A</strong>：换行符（line feed）</li></ol><blockquote><p><strong>JSON 格式</strong> 允许字符串里面 <strong>直接使用</strong> U+2028（行分隔符）和 U+2029（段分隔符）。</p></blockquote><p>服务器输出的 JSON 被 <code>JSON.parse</code> 解析，就有可能直接报错。</p><p><br><br><br><br><br></p><h3 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h3><p>根据标准，JSON 数据必须是 UTF-8 编码。</p><blockquote><p>UTF-8 标准规定，<strong><code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点，不能单独使用，必须配对使用</strong> 。比如，<code>\uD834\uDF06</code>是两个码点，但是必须放在一起配对使用，代表字符 𝌆。这是为了表示码点大于 <code>0xFFFF</code> 的字符的一种变通方法。单独使用 <code>\uD834</code> 和 <code>\uDFO6</code> 这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\uDF06\uD834</code>并没有对应的字符。</p></blockquote><p><code>JSON.stringify()</code> 的问题在于，它可能返回 <code>0xD800</code> 到 <code>0xDFFF</code> 之间的单个码点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// "\u&#123;D834&#125;"</span></span><br></pre></td></tr></table></figure></p><p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// ""\\uD834""</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\uDF06\uD834'</span>) <span class="comment">// ""\\udf06\\ud834""</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><blockquote><p><strong>模板字符串</strong>（template string）是增强版的字符串，用 <strong>反引号（`）</strong> 标识。它可以当作普通字符串使用，也可以用来定义 <strong>多行字符串</strong>，或者 <strong>在字符串中嵌入变量</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure></p><p>如果使用模板字符串表示多行字符串，<strong>所有的 空格 和 缩进 都会被保留</strong>在输出之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure></p><p>可以使用 <code>trim</code> 方法消除字符串首尾的空白字符（换行符、空格及连续空格、制表符tab）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#list&apos;).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure></p><p>模板字符串中 <strong>嵌入变量</strong>，需要将变量名写在 <code>${}</code> 之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="comment">// 传统写法为</span></span><br><span class="line">      <span class="comment">// 'User '</span></span><br><span class="line">      <span class="comment">// + user.name</span></span><br><span class="line">      <span class="comment">// + ' is not authorized to do '</span></span><br><span class="line">      <span class="comment">// + action</span></span><br><span class="line">      <span class="comment">// + '.'</span></span><br><span class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>大括号内部可以放入任意的 JavaScript 表达式，可以 <strong>进行运算</strong>，以及 <strong>引用对象属性</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "3"</span></span><br></pre></td></tr></table></figure></p><p>模板字符串之中还能 <strong>调用函数</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure></p><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。</p><p>模板字符串甚至还能嵌套：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法如下</span></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tmpl(data));</span><br><span class="line"><span class="comment">// &lt;table&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;/table&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。</p><p><br><br><br><br><br></p><h3 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h3><p>（待补充）</p><p><br><br><br><br><br></p><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>“标签模板”功能（tagged template）：“标签模板”可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`123`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert(<span class="number">123</span>)</span><br></pre></td></tr></table></figure></p><p>标签模板其实不是模板，而是 <strong>函数调用</strong> 的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 这是函数实际的调用方式</span></span><br></pre></td></tr></table></figure></p><p>函数tag依次会接收到多个参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。<code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure></p><p>passthru函数采用 rest 参数的写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += literals[index]</span><br><span class="line">  <span class="keyword">return</span> output;&#125;</span><br></pre></td></tr></table></figure></p><p>“标签模板”的重要应用：</p><p>（1） <strong>过滤 HTML 字符串，防止用户输入恶意内容</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。</span></span><br><span class="line"><span class="keyword">let</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p><p>（2）多语言转换（国际化处理）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// "欢迎访问xxx，您是第xxxx位访问者！"</span></span><br></pre></td></tr></table></figure></p><p>（3）模拟 Mustache 之类的模板库（添加条件判断、循环处理等功能）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p><p>（4）在 JavaScript 语言之中嵌入其他语言<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jsx<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      ref='input'</span></span><br><span class="line"><span class="string">      onChange='<span class="subst">$&#123;<span class="keyword">this</span>.handleChange&#125;</span>'</span></span><br><span class="line"><span class="string">      defaultValue='<span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span>' /&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">   &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>上面的代码通过 <code>jsx</code> 函数，<u>将一个 <strong>DOM 字符串</strong>转为 <strong>React 对象</strong></u>。</p><p>模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存转义后的原字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// strings.raw[0] 为 "First line\\nSecond line"</span></span><br><span class="line">  <span class="comment">// 打印输出 "First line\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[“First line\nSecond line”]，那么strings.raw数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符的-Unico
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 变量的解构赋值</title>
    <link href="http://fujiafeng.com/2019/11/21/ES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://fujiafeng.com/2019/11/21/ES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</id>
    <published>2019-11-21T15:23:18.000Z</published>
    <updated>2019-11-21T15:37:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><blockquote><p><strong>解构</strong>（Destructuring）：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p></blockquote><p><br></p><blockquote><p><strong>常见用途</strong>：<br>（1）交换变量的值；<br>（2）从函数返回多个值；<br>（3）函数参数的定义；<br>（4）提取 JSON 数据；<br>（5）函数参数的默认值；<br>（6）遍历 Map 结构；<br>（7）输入模块的指定方法。</p></blockquote><p><br></p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>本质上，这种写法属于“<strong>模式匹配</strong>”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p><p>另一种情况是 <strong>不完全解构</strong>，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>对于 <strong>Set 结构</strong>，也可以使用数组的解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure></p><p>事实上，只要某种数据结构具有 <strong>Iterator 接口</strong>，都可以采用数组形式的解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><p><br></p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p><p>只有当一个数组成员<strong>严格等于undefined</strong>，默认值才会生效。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码等价于</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。</p></blockquote><p><br><br><br></p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>对象的解构与数组有一个重要的不同。数组的元素是 <strong>按次序排列</strong> 的，变量的取值由它的位置决定；而对象的属性<strong>没有次序</strong>，<strong>变量必须与属性同名</strong>，才能取到正确的值。</p><p>如果解构失败，变量的值等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p><strong>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;log(<span class="string">'hello'</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></p><p>上面代码的例一将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将console.log赋值到log变量。</p><p>对象的解构赋值是下面形式的简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br></pre></td></tr></table></figure></p><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><p>与数组一样，解构也可以用于 嵌套结构的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure></p><p>解构赋值中，<code>：</code>前边的 loc、start 都是模式，不是变量。</p><p>注意，对象的解构赋值可以取到继承的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，对象obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性。</p><p><br></p><h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><p>默认值生效的条件是，对象的属性值严格等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>（1）<u>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</u><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure></p><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。</p><p>（2）<u>解构赋值允许等号左边的模式之中，不放置任何变量名。</u>因此，可以写出非常古怪的赋值表达式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br><span class="line"><span class="comment">// 以上表达式毫无意义，但语法合法</span></span><br></pre></td></tr></table></figure></p><p>（3）<u>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</u><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“<strong>属性名表达式</strong>”。（对象的扩展）</p><p><br><br><br></p><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个 <strong>类似数组的对象</strong>。</p><p>类似数组的对象都有一个 <strong>length属性</strong>，因此还可以对这个属性解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><blockquote><p><strong>解构赋值的规则</strong>：只要等号右边的值不是对象或数组，就先将其转为对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p><p>由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p><p><br><br><br></p><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是 <code>x</code> 和 <code>y</code> 。</p><p>函数参数的解构也可以使用默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></p><p>undefined就会触发函数参数的默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><blockquote><p>ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>建议只要有可能，就不要在模式中放置圆括号。</p></blockquote><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><ol><li><p>变量声明语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;<span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;<span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;<span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数参数（属于变量声明）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure></li><li><p>赋值语句的模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p><strong><u>赋值语句</u> 的 <u>非模式部分</u></strong>，可以使用圆括号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>（1）<strong>交换变量的值</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></p><p>（2）<strong>从函数返回多个值</strong><br>函数只能返回一个值，如果要返回多个值，只能将它们放在 <strong>数组</strong> 或 <strong>对象</strong> 里返回。有了解构赋值，取出这些值就非常方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></p><p>（3）<strong>函数参数的定义</strong><br>解构赋值可以方便地将 <strong>一组参数</strong> 与 <strong>变量名</strong> 对应起来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>（4）<strong>提取 JSON 数据</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure></p><p>（5）<strong>函数参数的默认值</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>指定参数的默认值，就避免了在函数体内部再写 <code>var foo = config.foo || &#39;default foo&#39;;</code> 这样的语句。</p><p>（6）<strong>遍历 Map 结构</strong><br>任何部署了 Iterator 接口的对象，都可以用 <code>for...of</code> 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，<strong>获取键名和键值</strong> 就非常方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（7）<strong>输入模块的指定方法</strong><br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;解构&lt;/s
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - let和const命令</title>
    <link href="http://fujiafeng.com/2019/11/21/ES6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>http://fujiafeng.com/2019/11/21/ES6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</id>
    <published>2019-11-21T15:07:06.000Z</published>
    <updated>2019-11-21T15:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><ul><li><code>let</code>声明的变量只在它所在的代码块有效；</li><li><code>for</code>循环 的计数器，适合使用 <code>let</code>命令（设置循环变量的那部分是 父作用域，循环体内部 是一个单独的自作用域）；</li><li><code>let</code> 命令<strong>不存在变量提升</strong>；</li><li><strong>暂时性死区</strong>（TDZ=temporal dead zone）：在代码块内，使用 <code>let</code>声明变量之前，该变量不可用；</li><li>暂时性死区 意味着 <code>typeof</code> 不再是一个百分之百安全的操作（作为比较，如果一个变量根本没有被声明，使用 <code>typeof</code> 反而不会报错）</li><li><code>let</code> <strong>不允许</strong>在相同作用域内，<strong>重复声明</strong>同一变量（不能在函数内部重新声明参数）；</li></ul><p><br><br><br></p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这会导致：</p><ol><li>内层变量可能会覆盖外层变量（变量提升）；</li><li>用来计数的循环变量泄露为全局变量。</li></ol><p><br></p><p>ES6块级作用域</p><p>let实际上为 JavaScript 新增了块级作用域。</p><p>ES6 允许块级作用域的任意嵌套。</p><p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...&#125;());</span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...&#125;</span><br></pre></td></tr></table></figure></p><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要， <strong>块级作用域内部，优先使用函数表达式</strong> 。</p><p><br><br><br></p><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ul><li>const声明 <strong>只读常量</strong>；</li><li>const一旦声明变量，就必须 <strong>立即初始化</strong>，不能留到以后赋值；</li><li>只在声明所在的 <strong>块级作用域</strong> 内有效；</li><li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用；</li><li>不可重复声明。</li></ul><blockquote><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>如果真的想将对象冻结，应该使用Object.freeze方法。</p><p><code>const foo = Object.freeze({});</code></p></blockquote><p><br><br><br></p><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><ul><li>var 命令</li><li>function 命令</li><li>let 命令</li><li>const 命令</li><li>import 命令</li><li>class 命令</li></ul><p>ES5 只有两种声明变量的方法：var命令和function命令。</p><p><br><br><br></p><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><blockquote><p><strong>顶层对象</strong>，在浏览器环境指的是<strong>window对象</strong>，在 Node 指的是<strong>global对象</strong>。</p></blockquote><p>ES5 之中，顶层对象的属性与全局变量是等价的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>这导致了几个问题：</p><ol><li>没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；</li><li>程序员很容易不知不觉地就创建了全局变量（比如打字出错）；</li><li>顶层对象的属性是到处可以读写的，这非常不利于模块化编程。</li></ol><p>从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩：</p><ol><li>为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；</li><li>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h3><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p><ul><li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window；</li><li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self；</li><li>Node 里面，顶层对象是global，但其他环境都不支持。</li></ul><p>同一段代码为了能够在各种环境，都能<strong>取到顶层对象</strong>，现在一般是使用 <strong>this变量</strong>，但是有局限性：</p><ul><li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块；</li><li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined；</li><li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</li></ul><p>暂时可用的解决方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);&#125;;</span><br></pre></td></tr></table></figure></p><p>现在有一个提案，在语言标准的层面，<u>引入 <strong>globalThis</strong> 作为 <strong>顶层对象</strong></u>。</p><p>也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</p><p><strong>垫片库global-this</strong> 模拟了这个提案，可以在所有环境拿到globalThis。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>大约在冬季</title>
    <link href="http://fujiafeng.com/2019/11/20/%E5%A4%A7%E7%BA%A6%E5%9C%A8%E5%86%AC%E5%AD%A3/"/>
    <id>http://fujiafeng.com/2019/11/20/%E5%A4%A7%E7%BA%A6%E5%9C%A8%E5%86%AC%E5%AD%A3/</id>
    <published>2019-11-19T16:00:06.000Z</published>
    <updated>2019-11-19T14:40:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>-26-</p><p>感谢爱过的人和事</p><p>经历过的美好瞬间</p><p>让我无惧年龄的增长</p><p>‴ Be soft, be powerful </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;-26-&lt;/p&gt;
&lt;p&gt;感谢爱过的人和事&lt;/p&gt;
&lt;p&gt;经历过的美好瞬间&lt;/p&gt;
&lt;p&gt;让我无惧年龄的增长&lt;/p&gt;
&lt;p&gt;‴ Be soft, be powerful &lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>侧耳倾听 Vol.5</title>
    <link href="http://fujiafeng.com/2019/11/07/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-5/"/>
    <id>http://fujiafeng.com/2019/11/07/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-5/</id>
    <published>2019-11-07T15:38:26.000Z</published>
    <updated>2019-11-19T14:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>#抄句子#</em></p><blockquote><p>「我所有的自負皆來自我的自卑；<br>&emsp;&emsp;&emsp;所有的英雄氣概都來自於我的軟弱。<br>&emsp;&emsp;&emsp;嘴裡振振有詞是因為心裡滿是懷疑，<br>&emsp;&emsp;&emsp;深情是因為痛恨自己無情。<br>&emsp;&emsp;&emsp;這世界沒有一件事情是虛空而生的，<br>&emsp;&emsp;&emsp;站在光里，背後就會有陰影；<br>&emsp;&emsp;&emsp;這深夜裡一片寂靜，<br>&emsp;&emsp;&emsp;是因為你還沒有聽見聲音。」<br>&emsp;&emsp;&emsp;—— 馬良 《坦白書》</p></blockquote><p><br></p><blockquote><p>「世界要妳努力考取功名<br>&emsp;&emsp;&emsp;但真誠才是最大的本領」</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;#抄句子#&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「我所有的自負皆來自我的自卑；&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;所有的英雄氣概都來自於我的軟弱。&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;嘴裡振振有詞是因為心裡滿是懷疑，&lt;br&gt;&amp;emsp;&amp;
      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="侧耳倾听" scheme="http://fujiafeng.com/tags/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC/"/>
    
  </entry>
  
  <entry>
    <title>【大数据组件】YARN简介</title>
    <link href="http://fujiafeng.com/2019/10/24/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E3%80%91YARN%E7%AE%80%E4%BB%8B/"/>
    <id>http://fujiafeng.com/2019/10/24/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E3%80%91YARN%E7%AE%80%E4%BB%8B/</id>
    <published>2019-10-24T15:33:53.000Z</published>
    <updated>2019-10-24T15:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Apache YARN</strong> ( Yet Another Resource Negotiator ) 是 hadoop 2.0 引入的 <strong>集群资源管理系统</strong> 。用户可以将各种服务框架部署在 YARN 上，由 YARN 进行统一地管理和资源分配。<br></p><p><br></p><h2 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h2><p>YARN 的基本思想是：</p><p>将 MapReduce 1 中的 JobTracker的 <strong>资源管理</strong> 和 <strong>作业调度</strong> 两个功能分开，分别由 <strong>ResourceManager</strong> 和 <strong>ApplicationMaster</strong> 进程来实现。</p><p>YARN 支持多种计算框架 运行在一个集群当中，比如 MapReduce（批处理）、Strom（在线处理）、Spark、Flink 等。</p><p>下图展示了 YARN 资源调度的流程：<br><img src="/2019/10/24/【大数据组件】YARN简介/yarn资源调度流程.png" title="yarn资源调度流程"></p><ul><li><strong>ResourceManager</strong> ：<strong>全局</strong>，负责整个集群的资源管理和调度；</li><li><strong>ApplicationMaster</strong> ：每个 job 有一个 ApplicationMaster，负责应用程序相关的事务，比如 任务调度、任务监控和容错等；</li><li><strong>NodeManager</strong> ：客户端框架，负责containers，监控他们的 资源使用（CPU、内存、磁盘、网络）并上报给 ResourceManager.</li></ul><hr><p><br></p><h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p><code>ResourceManager</code> 通常在独立的机器上以后台进程的形式运行，它是整个集群资源的主要协调者和管理者。</p><p><code>ResourceManager</code> 负责给用户提交的所有应用程序分配资源，它根据应用程序优先级、队列容量、ACLs、数据位置等信息，做出决策，然后以共享的、安全的、多租户的方式制定分配策略，调度集群资源。</p><p><strong>主要功能</strong>：</p><ol><li>与客户端交互，处理来自客户端的请求；</li><li>启动和管理 ApplicationMaster，并在它失败时 进行重启；</li><li>管理 NodeManager，接受来自 NM的资源汇报信息，下达管理指令；</li><li>资源调度和管理，接受 来自 AM的资源申请请求，并让 NM为之分配资源。</li></ol><p><br></p><h3 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h3><p><code>NodeManager</code> 是 YARN 集群中的单个计算节点的管理者。主要负责该节点内所有容器Container 的生命周期的管理，监视资源和跟踪节点健康。具体如下：</p><ul><li>启动时向 <code>ResourceManager</code> 注册并定时发送心跳消息，等待 <code>ResourceManager</code> 的指令；</li><li>维护 <code>Container</code> 的生命周期，监控 <code>Container</code> 的资源使用情况；</li><li>管理任务运行时的相关依赖，根据 <code>ApplicationMaster</code> 的需要，在启动 <code>Container</code> 之前将需要的程序及其依赖拷贝到本地。</li></ul><p><br></p><h3 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h3><p>在用户提交一个应用程序时，YARN 会启动一个轻量级的进程 <code>ApplicationMaster</code>。<code>ApplicationMaster</code> 负责协调来自 <code>ResourceManager</code> 的资源，并通过 <code>NodeManager</code> 监视容器内资源的使用情况，同时还负责任务的监控与容错。具体如下：</p><ul><li>根据应用的运行状态来决定动态计算资源需求；</li><li>向 <code>ResourceManager</code> 申请资源，监控申请的资源的使用情况；</li><li>跟踪任务状态和进度，报告资源的使用情况和应用的进度信息；</li><li>负责任务的容错。</li></ul><p><br></p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><code>Container</code> 是 YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等。当 AM 向 RM 申请资源时，RM 为 AM 返回的资源是用 <code>Container</code> 表示的。YARN 会为每个任务分配一个 <code>Container</code>，该任务只能使用该 <code>Container</code> 中描述的资源。<code>ApplicationMaster</code> 可在 <code>Container</code> 内运行任何类型的任务。例如，<code>MapReduce ApplicationMaster</code> 请求一个容器来启动 map 或 reduce 任务，而 <code>Giraph ApplicationMaster</code> 请求一个容器来运行 Giraph 任务。</p><p><br><br><br><br><br></p><h2 id="YARN工作原理简述"><a href="#YARN工作原理简述" class="headerlink" title="YARN工作原理简述"></a>YARN工作原理简述</h2><img src="/2019/10/24/【大数据组件】YARN简介/yarn工作原理简述.png" title="yarn工作原理简述"><ol><li><code>Client</code> 提交作业到 YARN 上；</li><li><code>Resource Manager</code> 选择一个 <code>Node Manager</code>，启动一个 <code>Container</code> 并运行 <code>Application Master</code> 实例；</li><li><code>Application Master</code> 根据实际需要向 <code>Resource Manager</code> 请求更多的 <code>Container</code> 资源（如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务）；</li><li><code>Application Master</code> 通过获取到的 <code>Container</code> 资源执行分布式计算。</li></ol><p><br><br><br><br><br></p><h2 id="YARN工作原理详述"><a href="#YARN工作原理详述" class="headerlink" title="YARN工作原理详述"></a>YARN工作原理详述</h2><img src="/2019/10/24/【大数据组件】YARN简介/yarn工作原理详述.png" title="yarn工作原理详述"><ol><li><strong>作业提交</strong></li></ol><p>client 调用 job.waitForCompletion 方法，向整个集群提交 MapReduce 作业 (第 1 步) 。新的作业 ID(应用 ID) 由资源管理器分配 (第 2 步)。作业的 client 核实作业的输出, 计算输入的 split, 将作业的资源 (包括 Jar 包，配置文件, split 信息) 拷贝给 HDFS(第 3 步)。 最后, 通过调用资源管理器的 submitApplication() 来提交作业 (第 4 步)。</p><ol><li><strong>作业初始化</strong></li></ol><p>当资源管理器收到 submitApplciation() 的请求时, 就将该请求发给调度器 (scheduler), 调度器分配 container, 然后资源管理器在该 container 内启动应用管理器进程, 由节点管理器监控 (第 5 步)。</p><p>MapReduce 作业的应用管理器是一个主类为 MRAppMaster 的 Java 应用，其通过创造一些 bookkeeping 对象来监控作业的进度, 得到任务的进度和完成报告 (第 6 步)。然后其通过分布式文件系统得到由客户端计算好的输入 split(第 7 步)，然后为每个输入 split 创建一个 map 任务, 根据 mapreduce.job.reduces 创建 reduce 任务对象。</p><ol><li><strong>任务分配</strong></li></ol><p>如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务。</p><p>如果不是小作业, 那么应用管理器向资源管理器请求 container 来运行所有的 map 和 reduce 任务 (第 8 步)。这些请求是通过心跳来传输的, 包括每个 map 任务的数据位置，比如存放输入 split 的主机名和机架 (rack)，调度器利用这些信息来调度任务，尽量将任务分配给存储数据的节点, 或者分配给和存放输入 split 的节点相同机架的节点。</p><ol><li><strong>任务运行</strong></li></ol><p>当一个任务由资源管理器的调度器分配给一个 container 后，应用管理器通过联系节点管理器来启动 container(第 9 步)。任务由一个主类为 YarnChild 的 Java 应用执行， 在运行任务之前首先本地化任务需要的资源，比如作业配置，JAR 文件, 以及分布式缓存的所有文件 (第 10 步。 最后, 运行 map 或 reduce 任务 (第 11 步)。</p><p>YarnChild 运行在一个专用的 JVM 中, 但是 YARN 不支持 JVM 重用。</p><ol><li><strong>进度和状态更新</strong></li></ol><p>YARN 中的任务将其进度和状态 (包括 counter) 返回给应用管理器, 客户端每秒 (通 mapreduce.client.progressmonitor.pollinterval 设置) 向应用管理器请求进度更新, 展示给用户。</p><ol><li><strong>作业完成</strong></li></ol><p>除了向应用管理器请求作业进度外, 客户端每 5 分钟都会通过调用 waitForCompletion() 来检查作业是否完成，时间间隔可以通过 mapreduce.client.completion.pollinterval 来设置。作业完成之后, 应用管理器和 container 会清理工作状态， OutputCommiter 的作业清理方法也会被调用。作业的信息会被作业历史服务器存储以备之后用户核查。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Apache YARN&lt;/strong&gt; ( Yet Another Resource Negotiator ) 是 hadoop 2.0 引入的 &lt;strong&gt;集群资源管理系统&lt;/strong&gt; 。用户可以将各种服务框架部署在 YARN 上，由 YARN
      
    
    </summary>
    
    
    
      <category term="大数据" scheme="http://fujiafeng.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>【大数据组件】HDFS简介</title>
    <link href="http://fujiafeng.com/2019/10/21/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E3%80%91HDFS%E7%AE%80%E4%BB%8B/"/>
    <id>http://fujiafeng.com/2019/10/21/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E3%80%91HDFS%E7%AE%80%E4%BB%8B/</id>
    <published>2019-10-21T14:49:48.000Z</published>
    <updated>2019-10-21T15:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>HDFS</strong> = Hadoop Distributed File System</p><p><strong>Hadoop 分布式文件系统</strong></p><p>分布式文件系统：统一管理 分布在集群上 的文件系统。</p></blockquote><p><br><br><br></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><h3 id="HDFS-优点与局限"><a href="#HDFS-优点与局限" class="headerlink" title="HDFS 优点与局限"></a>HDFS 优点与局限</h3><p>优点：</p><ol><li><strong>高度容错性</strong>，适合部署在 廉价的机器上；</li><li>提供 <strong>高吞吐量</strong> 的数据访问，适用于 <strong>大规模数据集（Large Data Set）</strong>；</li><li><strong>流式读取</strong> 文件系统数据，一次写入，多次读取，不能修改，只能追加。能保证数据的一致性。</li></ol><blockquote><p>注：大规模数据集，指 10^2 MB/GB/TB/PB 级别。</p></blockquote><p>局限：</p><ol><li>不支持 低延迟访问（毫秒级）；</li><li>不适合 大量的小文件存储；</li><li>不支持 并发写入；</li><li>不支持修改。</li></ol><p><br></p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p><strong>分而治之</strong> — 将大文件、大批量文件，分布式存放在大量服务器上，以便于采取 分而治之 的方式对海量数据进行分析运算。</p><p><br></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在 大数据系统 中，为各类分布式运算框架（如：MapReduce、spark、tez 等），提供 <strong>数据存储</strong> 服务。</p><p><br></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>一个分布式文件系统，用于存储文件，通过统一的 <u><strong>命名空间（目录树）</strong></u> 来定位文件。</p><p>HDFS是一个 <strong>主/从（Mater/Slave）体系结构</strong> ，HDFS集群拥有一个NameNode和一些DataNode。NameNode管理文件系统的元数据，DataNode存储实际的数据。</p><p>从用户角度看，HDFS 通过 <strong>目录路径</strong> 对文件执行 <strong>CRUD</strong> 操作（Create、Read、Update、Delete）。</p><hr><p><u><strong>HDFS客户端</strong></u>：就是客户端。<br>1、提供一些命令来管理、访问 HDFS，比如启动或者关闭HDFS。<br>2、与 DataNode 交互，读取或者写入数据；读取时，要与 NameNode 交互，获取文件的位置信息；写入 HDFS 的时候，Client 将文件切分成 一个一个的Block，然后进行存储。<br>3、文件切分。文件上传 HDFS 时，Client 将文件切分成一个个的 Block，然后进行存储。</p><p><u><strong>NameNode</strong></u>：即Master，<br>1、管理 HDFS 的名称空间。<br>2、管理数据块（Block）映射信息<br>3、配置副本策略<br>4、处理客户端读写请求。</p><p><u><strong>DataNode</strong></u>：就是Slave。NameNode 下达命令，DataNode 执行实际的操作。<br>1、存储实际的数据块。<br>2、执行数据块的读/写操作。</p><p><u><strong>Secondary NameNode</strong></u>：并非 NameNode 的热备。当NameNode 挂掉的时候，它并不能马上替换 NameNode 并提供服务。<br>1、辅助 NameNode，分担其工作量。<br>2、定期合并 fsimage和fsedits，并推送给NameNode。<br>3、在紧急情况下，可辅助恢复 NameNode。</p><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs架构.png" title="hdfs架构"><p><br></p><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs架构2.png" title="hdfs架构2"><hr><p><br><br><br></p><h3 id="从HDFS读取内容"><a href="#从HDFS读取内容" class="headerlink" title="从HDFS读取内容"></a>从HDFS读取内容</h3><p>1、首先调用DistributedFileSystem对象的open方法，其实获取的是一个DistributedFileSystem的实例。</p><p>2、DistributedFileSystem通过RPC(远程过程调用)获得文件的第一批block的locations，同一block按照重复数会返回多个locations，这些locations按照hadoop拓扑结构排序，距离客户端近的排在前面。</p><p>3、前两步会返回一个FSDataInputStream对象，该对象会被封装成 DFSInputStream 对象，DFSInputStream可以方便的管理DataNode和NameNode数据流。客户端调用read方法，DFSInputStream就会找出离客户端最近的DataNode并连接DataNode。</p><p>4、数据从DataNode源源不断的流向客户端。</p><p>5、如果第一个block块的数据读完了，就会关闭指向第一个block块的DataNode连接，接着读取下一个block块。这些操作对客户端来说是透明的，从客户端的角度来看只是读一个持续不断的流。</p><p>6、如果第一批block都读完了，DFSInputStream就会去NameNode拿下一批blocks的location，然后继续读，如果所有的block块都读完，这时就会关闭掉所有的流。<br><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs读取数据.png" title="hdfs读取数据"></p><p><br><br><br></p><h3 id="向HDFS写入内容"><a href="#向HDFS写入内容" class="headerlink" title="向HDFS写入内容"></a>向HDFS写入内容</h3><p>1.客户端通过调用DistributedFileSystem的create方法，创建一个新的文件。</p><p>2.DistributedFileSystem通过RPC（远程过程调用）调用NameNode，去创建一个没有blocks关联的新文件。创建前，NameNode会做各种校验，比如文件是否存在，客户端有无权限去创建等。如果校验通过，NameNode 就会记录下新文件，否则就会抛出IO异常。</p><p>3.前两步结束后会返回 FSDataOutputStream 的对象，和读文件的时候相似，FSDataOutputStream 被封装成 DFSOutputStream，DFSOutputStream 可以协调NameNode和 DataNode。客户端开始写数据到DFSOutputStream，DFSOutputStream会把数据切成一个个小packet，然后排成队列data queue。</p><p>4.DataStreamer 会去处理接受 data queue，它先问询 NameNode 这个新的 block 最适合存储的在哪几个DataNode里，比如重复数是3，那么就找到3个最适合的DataNode，把它们排成一个 pipeline。DataStreamer 把 packet 按队列输出到管道的第一个 DataNode 中，第一个 DataNode又把 packet 输出到第二个 DataNode 中，以此类推。</p><p>5.DFSOutputStream 还有一个队列叫 ack queue，也是由 packet 组成，等待DataNode的收到响应，当pipeline中的所有DataNode都表示已经收到的时候，这时akc queue才会把对应的packet包移除掉。</p><p>6.客户端完成写数据后，调用close方法关闭写入流。</p><p>7.DataStreamer 把剩余的包都刷到 pipeline 里，然后等待 ack 信息，收到最后一个ack 后，通知 DataNode 把文件标示为已完成。<br><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs写入数据.png" title="hdfs写入数据"></p><p><br><br><br></p><h3 id="副本存放策略"><a href="#副本存放策略" class="headerlink" title="副本存放策略"></a>副本存放策略</h3><p>一般情况下副本系数为3，HDFS的副本放置策略是：将第一个副本放在本地节点，将第二个副本放在本地机架上的另一个节点，而第三个副本放到不同机架上的节点。</p><p>这种方式减少了机架间的写流量，从而提高了写的性能。机架故障的机率远小于节点故障。这种方式并不影响数据可靠性和可用性的限制，并且它确实减少了读操作的网络聚合带宽，因为文件块仅存在两个不同的机架，而不是三个。</p><p>文件的副本不是均匀的分布在机架当中，1/3的副本在同一个节点上，1/3副本在同一个机架上，另外1/3个副本均匀地分布在其他机架上。</p><p><br></p><p><strong>流水线复制</strong></p><p>假设HDFS副本系数为3，当本地暂时文件积累到一个数据块大小时，client会从NameNode获取一个列表用于存放副本。然后client开始向第一个DataNode数据传输，第一个DataNode一小部分一小部分地接收数据，将每一部分写入本地仓库，并同一时间传输该部分到列表中的第二个DataNode节点。第二个DataNode也是这样，一小部分一小部分地接收数据，写入本地仓库，并同一时候转发给下一个节点，数据以流水线的方式从前一个DataNode拷贝到下一个DataNode。最后，第三个DataNode接收数据并存储到本地。因此，DataNode能流水线地从前一个节点接收数据，并同一时间转发给下一个节点，数据以流水线的方式从前一个DataNode拷贝到下一个DataNode，并以相反的方向Ack前一个Node。<br><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs副本存放策略.png" title="hdfs副本存放策略"></p><p><br><br><br></p><h3 id="HA机制"><a href="#HA机制" class="headerlink" title="HA机制"></a>HA机制</h3><p><strong>HA = high availability 高可用性</strong></p><p>背景：NameNode 单点故障（SPOF=single point of failure）。</p><p>在 HA 机制下，可以运行一个 <strong>Hot Standby</strong>，作为 <strong>热备份</strong>（待机状态），在 Active NameNode 故障时，替代原有的 NN 成为新的 NN 提供服务。这一过程对用户透明，由客户端库完成。</p><p><u><strong>主要实现逻辑</strong></u>：</p><ol><li>主备需 共享 edit log 存储；</li><li>DataNode 需要同时往 主备NN 发送 Block Report；</li><li>客户端需要配置 failover 模式（失效备援模式，对用户透明）；</li><li>Standby 替代 Secondary NameNode.</li></ol><p>NameNode的切换通过代failover controller来实现。failover controller有多种实现，默认实现使用ZooKeeper来保证只有一个Namenode处于active状态。</p><p>每个Namenode运行一个轻量级的failover controller进程，该进程使用简单的心跳机制来监控Namenode的存活状态并在Namenode失败时触发failover。Failover可以由运维手动触发，例如在日常维护中需要切换主Namenode，这种情况graceful(优雅的) failover，非手动触发的failover称为ungraceful failover。</p><p>在ungraceful failover的情况下，没有办法确定失败（被判定为失败）的节点是否停止运行，也就是说触发failover后，之前的主Namenode可能还在运行。QJM一次只允许一个Namenode写edit log，但是之前的主Namenode仍然可以接受读请求。Hadoop使用fencing来杀掉之前的Namenode。Fencing通过收回之前Namenode对共享的edit log的访问权限、关闭其网络端口使得原有的Namenode不能再继续接受服务请求。使用STONITH技术也可以将之前的主Namenode关机。</p><hr><p><br><br><strong>扩展：大数据存储生态圈简介</strong></p><p>Hive与Hbase的数据一般都存储在HDFS上。HDFS为他们提供了高可靠性的底层存储支持。</p><p><strong>Hive</strong></p><p>Hive不支持更改数据的操作，Hive基于数据仓库，提供静态数据的动态查询。其使用类SQL语言，底层经过编译转为MapReduce程序，在Hadoop上运行，数据存储在HDFS上。</p><p><strong>HBase</strong></p><p>Hbase是Hadoop database，即Hadoop数据库。它是一个适合于非结构化数据存储的数据库，HBase基于列的而不是基于行的模式。</p><p>HBase是Google Bigtable的开源实现，类似Google Bigtable利用GFS作为其文件存储系统，HBase利用HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt; = Hadoop Distributed File System&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hadoop 分布式文件系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分布式文件系统：统一管理 分布在集群上 的文件
      
    
    </summary>
    
    
    
      <category term="大数据" scheme="http://fujiafeng.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 插件</title>
    <link href="http://fujiafeng.com/2019/10/20/Vue-js-%E6%8F%92%E4%BB%B6/"/>
    <id>http://fujiafeng.com/2019/10/20/Vue-js-%E6%8F%92%E4%BB%B6/</id>
    <published>2019-10-20T15:51:58.000Z</published>
    <updated>2019-10-21T14:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>插件的使用方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(MyPlugin)</span><br><span class="line">Vue.use(MyPlugin, &#123;</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="前端路由-与-vue-router"><a href="#前端路由-与-vue-router" class="headerlink" title="前端路由 与 vue-router"></a>前端路由 与 vue-router</h2><p><strong>单页面富应用（SPA）</strong>= <strong>前后端分离</strong> +  <strong>前端路由</strong>。<br><strong><u>前后端分离</u></strong> 的开发模式是：后端只提供 API 来返回数据，前端通过 Ajax 获取数据后，再用一定的方式渲染到页面里（后端专注于 数据，前端专注于 交互和可视化；web与移动端可共享一套 API ；首屏渲染 需要加载 js 和 css ）。<br><strong><u>前端路由</u></strong> ：由前端来维护一个路由规则。有两种实现：</p><ol><li><strong>利用 url 的 hash</strong>，即锚点（#）：JavaScript 通过 hashChange 事件监听 url 的变化，IE7 及以下需要用轮询；</li><li><strong>利用 HTML5 的 History 模式</strong>：需要服务端支持。</li></ol><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>路由不同的页面，实际上是 <strong>动态加载不同的组件</strong>。其中，每个页面对应一个组件，也就是对应一个 <code>.vue</code> 文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld'</span></span><br><span class="line"><span class="keyword">import</span> First <span class="keyword">from</span> <span class="string">'@/components/views/First'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [ &#123;</span><br><span class="line">      path: <span class="string">'/first'</span>,</span><br><span class="line">      name: <span class="string">'First'</span>,</span><br><span class="line">      component: First</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'*'</span>,  <span class="comment">// 访问的路径不存在，则重定向到 HelloWorld</span></span><br><span class="line">      name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Routers 里每一项的 <code>path</code> 属性就是指定 当前匹配的路径，可以带参数； <code>component</code> 是映射的组件。webpack 会把每一个路由都打包为一个 js 文件，在请求到该页面时，才去加载这个页面的 js，即异步实现的 <strong>懒加载（按需加载）</strong>。</p><p>在 new Router() 的参数中，设置 <code>mode: &#39;history&#39;</code> 会开启 HTML5 的 history 模式；默认使用 <code>‘#’</code>来设置路径。</p><p>在 Vue 根实例中，通过 <strong><router-view></router-view></strong> 来挂载所有的路由组件。运行网页时，<router-view> 会根据当前路由 动态渲染 不同的页面组件。网页中一些公共部分，如顶部导航栏、侧边导航栏、底部版权信息等，可以直接写在 根实例 中，与 <router-view> 同级。<br>通过 <code>this.$route</code> 可以访问当前路由的具体信息。</router-view></router-view></p><h3 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h3><p>vue-router 有两种跳转页面的方法：</p><ol><li>使用内置的 <code>&lt;router-link&gt;</code> 组件，它默认会被渲染成 <a>；</a></li><li>使用 router 实例的事件方法，如 <code>this.$router.push(targetUrl)</code> ；</li></ol><p>其中，使用 <router-link> 在 HTML5 的 history 模式下会被拦截点击，避免浏览器重新加载页面。<router-link> 的常用 prop 有：</router-link></router-link></p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>to</td><td>指定要跳转的路径</td></tr><tr><td>tag</td><td>指定渲染成什么标签</td></tr><tr><td>replace</td><td>不会留下 History 记录</td></tr><tr><td>active-class</td><td>修改默认的 路由匹配成功时的类名（router-link-active）</td></tr></tbody></table><p><br></p><p>$router 的常用方法：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>push</td><td>添加要跳转到的新路径，会产生新的 history 记录</td></tr><tr><td>replace</td><td>替换当前的 history 记录</td></tr><tr><td>go</td><td>在 history 记录中向前或后退多少步，参数是整数</td></tr></tbody></table><h3 id="vue-router-导航钩子"><a href="#vue-router-导航钩子" class="headerlink" title="vue-router 导航钩子"></a>vue-router 导航钩子</h3><p>vue-router 提供了 导航钩子 <strong>beforeEach</strong> 和 <strong>afterEach</strong> ，分别在路由即将改变前和改变后触发。通过这两个钩子，可以做一些事情来提升用户体验：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * beforeEach 在路由即将改变前触发</span></span><br><span class="line"><span class="comment"> * @param to, 即将要进入的目标的路由对象</span></span><br><span class="line"><span class="comment"> * @param from, 当前导航即将要离开的路由对象</span></span><br><span class="line"><span class="comment"> * @param next, 调用该方法后，才能进入下一个钩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在页面路由改变时，统一设置网页标题</span></span><br><span class="line">  <span class="built_in">window</span>.document.title = to.meta.title;</span><br><span class="line">  <span class="comment">// 网页登录校验，未登录则跳转至登录页</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">'token'</span>)) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="string">'/login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * afterEach 在路由改变后触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 切换页面后，滚动条返回顶端（滚动条默认保持上一个页面停留的位置）</span></span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="状态管理-与-Vuex"><a href="#状态管理-与-Vuex" class="headerlink" title="状态管理 与 Vuex"></a>状态管理 与 Vuex</h2><h3 id="状态管理与使用场景"><a href="#状态管理与使用场景" class="headerlink" title="状态管理与使用场景"></a>状态管理与使用场景</h3><p>一个组件可以分为 数据（model）和 视图（view），其基本的运行模式是：数据更新时，视图也会自动更新；在视图中又可以绑定一些事件，触发 methods 里指定的方法，从而可以改变数据、更新视图。</p><p>在实际业务中，会有 <strong>跨组件共享数据</strong> 的需求（非父子组件：跨级组件、兄弟组件），而 <strong>Vuex</strong> 的设计，就是用来 <strong>统一管理组件状态</strong> 的。</p><h3 id="Vuex-基本用法"><a href="#Vuex-基本用法" class="headerlink" title="Vuex 基本用法"></a>Vuex 基本用法</h3><p>npm安装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vuex</span><br></pre></td></tr></table></figure></p><p>在项目入口文件 main.js 里，通过 Vue.use() 使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// vuex 的配置</span></span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span>,</span><br><span class="line">        list: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">35</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increament(state, n=<span class="number">1</span>) &#123;</span><br><span class="line">            state.count += n;</span><br><span class="line">        &#125;,</span><br><span class="line">        decrease(state) &#123;</span><br><span class="line">            state.count --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        filteredList: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.list.filter( <span class="function"><span class="params">item</span> =&gt;</span> item &lt; <span class="number">10</span> );</span><br><span class="line">        &#125;,</span><br><span class="line">        listCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getters.filteredList.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    actions: &#123;</span><br><span class="line">        increment (context) &#123;</span><br><span class="line">            context.commit(<span class="string">'increment'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">store,  <span class="comment">// 使用 vuex</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>仓库 store 包含了应用的数据（状态）和操作过程。Vuex 里的数据都是响应式的，任何组件使用同一 store 的数据时，只要 store 的数据变化，对应的组件就会立即更新。</p><p>数据保存在 Vuex 选项的 <strong>state</strong> 字段内，在任何组件内，可以直接通过 <code>$store.state.</code> 读取（注意：来自 store 的数据只能读取，不能手动改变）。</p><p>改变 store 中数据的唯一途径就是 显示地提交 <strong>mutations</strong>，它是 Vuex的第二个选项，用来<strong>直接修改 state 里的数据</strong>。</p><ol><li>在组件内，通过 this.$store.commit 方法来执行 mutations（组件只负责提交一个事件名， Vuex 对应的 mutations 来完成业务逻辑）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handleIncrement () &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store.commit( <span class="string">'increment'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutations 的第二个参数 可以是 数字、字符串或对象等类型，当一个参数不够用时，可以传入一个对象，无限扩展。</p><ol><li>提交 mutation 的另一种方式是：直接使用包含 type 属性的对象：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">    increment (state, params) &#123;</span><br><span class="line">        state.count += params.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">    type: <span class="string">'increment'</span>,</span><br><span class="line">    count: <span class="number">10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>注意：mutation 里尽量不要 异步操作数据。</p><h3 id="Vuex-高级用法"><a href="#Vuex-高级用法" class="headerlink" title="Vuex 高级用法"></a>Vuex 高级用法</h3><h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><p>将获取 store 中的数据的方法提取出来，放在 getters 中，便于统一管理。getter 可以依赖其他的 getter，把 getter 作为第二个参数即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123; list &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;&#123; listCount &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        computed: &#123;</span><br><span class="line">            list () &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.filteredList;</span><br><span class="line">            &#125;,</span><br><span class="line">            listCount () &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.listCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><p>actions 里面提交的是 mutation，并且可以 <strong>异步操作</strong> 业务逻辑。</p><p>action 在组件内通过 <strong>$store.dispatch</strong> 触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handleActionIncrement () &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store.dispatch( <span class="string">'increment'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们通过 Promise 异步方案 来模拟一次 延迟提交mutation：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    actions: &#123;</span><br><span class="line">        asyncIncrement (context) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    context.commit(<span class="string">'increment'</span>);</span><br><span class="line">                    resolve();</span><br><span class="line">                &#125;, <span class="number">1000</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; count &#125;&#125;</span><br><span class="line">        &lt;button @click=<span class="string">"handleAsyncIncrement"</span>&gt;<span class="keyword">async</span> +<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        computed: &#123;</span></span><br><span class="line"><span class="regexp">            count () &#123;</span></span><br><span class="line"><span class="regexp">                return this.$store.state.count;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        methods: &#123;</span></span><br><span class="line"><span class="regexp">            handleAsyncIncrement () &#123;</span></span><br><span class="line"><span class="regexp">                this.$store.dispatch('asyncIncrement').then( () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                    console.log(this.$store.state.count); /</span><span class="regexp">/ 1</span></span><br><span class="line"><span class="regexp">                &#125;);</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>建议：<br>&emsp;&emsp;涉及改变数据的，就使用 mutations；<br>&emsp;&emsp;存在业务逻辑的，就用 actions。</p></blockquote><p><br></p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p><strong>modules</strong> 用来 <strong>将 store 分割到不同模块</strong>。当你的项目足够大时，store 里的 state、getters、mutations、actions 会非常多，都放在 main.js 里显得不是很友好，而使用 modules 可以将它们写到不同的文件中。<strong>每个 module 拥有自己的 state、getters、mutations、actions</strong> ，而且可以 <strong>多层嵌套</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state: &#123; ... &#125;,</span><br><span class="line">    mutations: &#123; ... &#125;,</span><br><span class="line">    actions: &#123; ... &#125;,</span><br><span class="line">    getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">    state: &#123; ... &#125;,</span><br><span class="line">    mutations: &#123; ... &#125;,</span><br><span class="line">    actions: &#123; ... &#125;,</span><br><span class="line">    getters: &#123; </span><br><span class="line">        sumCount (state, getters, rootState) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.count + rootState.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        a: moduleA,</span><br><span class="line">        b: moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a   <span class="comment">// moduleA 的状态 </span></span><br><span class="line">store.state.b   <span class="comment">// moduleB 的状态</span></span><br></pre></td></tr></table></figure><p>module 的 mutation 和 getter 接收的第一个参数 state 是 <strong>当前模块的状态</strong>。在 actions 和 getters 中，可以接受第三个参数 <strong>rootState</strong>，来访问 <strong>根节点的状态</strong>。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;插件的使用方式：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue.js实战" scheme="http://fujiafeng.com/tags/Vue-js%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 使用webpack</title>
    <link href="http://fujiafeng.com/2019/10/20/Vue-js-%E4%BD%BF%E7%94%A8webpack/"/>
    <id>http://fujiafeng.com/2019/10/20/Vue-js-%E4%BD%BF%E7%94%A8webpack/</id>
    <published>2019-10-20T15:51:45.000Z</published>
    <updated>2019-10-21T14:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端工程化-与-webpack"><a href="#前端工程化-与-webpack" class="headerlink" title="前端工程化 与 webpack"></a>前端工程化 与 webpack</h2><p>在webpack 的世界里，一张图片、一个 css 甚至一个字体，<strong>每个文件</strong>都是一个 <strong>模块（Module）</strong>，彼此存在依赖关系；webpack 就是用来处理 <strong>模块间的依赖关系</strong>，并把它们进行<strong>打包</strong>的。<br>&emsp;&emsp;webpack 的主要适用场景是 <strong>单页面富应用</strong>（SPA）。SPA 通常是由一个 html 文件和一堆按需加载的 js 组成。<br>&emsp;&emsp;ES6 语法中的 <strong>export</strong> 和 <strong>import</strong> 是用来 <strong>导出和导入模块</strong>的。一个模块就是一个 js 文件，它拥有独立的作用域，里面定义的变量外部无法获取。如果使用 npm 安装了一些库，在 webpack 中可以直接导入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="webpack-基础配置"><a href="#webpack-基础配置" class="headerlink" title="webpack 基础配置"></a>webpack 基础配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>初始化项目配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p><p>本地局部安装 webpack：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p><p>本地局部安装 webpack-dev-server：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure></p><p><code>--save-dev</code> 指 <strong>作为开发依赖</strong> 来安装。<br>&emsp;&emsp;webpack-dev-server 提供的服务有：启动一个服务器、热更新、接口代理 等。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>webpack 就是一个 <code>.js</code> 配置文件，即 webpack.config.js 。<br>&emsp;&emsp;在 <code>package.json</code> 文件的 scripts 选项中添加快速启动 webpack-dev-server 服务的脚本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><p>当运行 <code>npm run dev</code> 命令时，就会执行 <code>webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</code>  命令。</p><p>webpack 核心配置项：</p><ul><li>入口（Entry）：webpack 从哪里开始寻找依赖；</li><li>出口（Output）：配置编译后的 文件存储位置 和 文件名；</li><li>加载器（Loaders）：module对象的rules属性中，可以指定一系列 loaders，每个loader 都必须包含 test 和 use 两个选项。use 选项的值可以是 数组（编译顺序：从后往前）或 字符串；</li><li>插件（Plugins）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/main.js'</span>  <span class="comment">// 单入口</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot, <span class="comment">// 打包后，文件的输出目录</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath <span class="comment">// 资源文件的引用目录</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>打包命令：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --progress --hide-modules</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><p>在使用 webpack 构建 Vue 项目的时候，可以使用一种新的构建模式：<strong>.vue 单文件组件</strong> 。在 webpack 中使用 <code>vue-loader</code> 就可以对 <code>.vue</code> 格式的文件进行处理。</p><p>为了支持图片、文字等文件，需要安装 <code>url-loader</code> 和 <code>file-loader</code> ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader?limit=1024'</span>,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p><code>&quot;?limit=1024&quot;</code> 是指如果文件小于 <code>1kb</code>，就以 <code>base64</code> 的形式加载，不会生成一个文件。</p><p>使用 单页面富应用（SPA）技术，即最终只有<strong>一个 html 文件</strong>，其余都是 <strong>静态资源</strong>。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端工程化-与-webpack&quot;&gt;&lt;a href=&quot;#前端工程化-与-webpack&quot; class=&quot;headerlink&quot; title=&quot;前端工程化 与 webpack&quot;&gt;&lt;/a&gt;前端工程化 与 webpack&lt;/h2&gt;&lt;p&gt;在webpack 的世界里，一张图片
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue.js实战" scheme="http://fujiafeng.com/tags/Vue-js%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js Render函数</title>
    <link href="http://fujiafeng.com/2019/10/20/Vue-js-Render%E5%87%BD%E6%95%B0/"/>
    <id>http://fujiafeng.com/2019/10/20/Vue-js-Render%E5%87%BD%E6%95%B0/</id>
    <published>2019-10-20T15:50:58.000Z</published>
    <updated>2019-10-21T14:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>Virtual DOM 是一个轻量级的 Javascript 对象，在状态发生变化时，Virtual DOM 会进行 Diff 运算，只更新需要被替换的 DOM，而不是重绘。<br>&emsp;&emsp;在Vue.js 2.0 中，Virtual DOM 是通过一种 <strong>VNode 类</strong> 表达的，每个 DOM 元素或组件 都对应一个 VNode 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> interface VNode &#123;</span><br><span class="line">    tag?: string; <span class="comment">// 当前节点的标签名</span></span><br><span class="line">    data?: VNodeData; <span class="comment">// 当前节点的数据对象</span></span><br><span class="line">    children?: VNode[]; <span class="comment">// 子节点数组</span></span><br><span class="line">    text?: string; <span class="comment">// 当前节点的文本</span></span><br><span class="line">    elm?: Node; <span class="comment">// 当前虚拟节点 对应的真实的 DOM 节点</span></span><br><span class="line">    ns?: string; <span class="comment">// 节点的 namespace</span></span><br><span class="line">    context?: Vue; <span class="comment">// 编译作用域</span></span><br><span class="line">    key?: string | number; <span class="comment">// 节点的标识，有利于 patch 的优化</span></span><br><span class="line">    componentOptions?: VNodeComponentOptions; <span class="comment">// 创建组件实例时，用到的选项信息</span></span><br><span class="line">    componentInstance?: Vue; <span class="comment">//</span></span><br><span class="line">    parent?: VNode; <span class="comment">// 组件的占位节点</span></span><br><span class="line">    raw?: boolean; <span class="comment">// 原始 html</span></span><br><span class="line">    isStatic?: boolean; <span class="comment">// 静态节点的标识</span></span><br><span class="line">    isRootInsert: boolean; <span class="comment">// 是否作为根节点插入</span></span><br><span class="line">    isComment: boolean; <span class="comment">// 是否是 注释节点</span></span><br><span class="line">    isCloned?: boolean; <span class="comment">// 是否是 克隆节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> interface VNodeData &#123;</span><br><span class="line">    key?: string | number;</span><br><span class="line">    slot?: string;</span><br><span class="line">    scopedSlots?: &#123; [key: string]: scopedSlot &#125;;</span><br><span class="line">    ref?: string;</span><br><span class="line">    tag?: string;</span><br><span class="line">    staticClass?: string;</span><br><span class="line">    class?: any;</span><br><span class="line">    staticStyle?: &#123; [key: string]: any &#125;;</span><br><span class="line">    style?: <span class="built_in">Object</span>[] | <span class="built_in">Object</span>;</span><br><span class="line">    props?: &#123; [key: string]: any &#125;;</span><br><span class="line">    attrs?: &#123; [key: string]: any &#125;;</span><br><span class="line">    domProps?: &#123; [key: string]: any &#125;;</span><br><span class="line">    hook?: &#123; [key: string]: Funcion &#125;;</span><br><span class="line">    on?: &#123; [key: string]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">    nativeOn?: &#123; [key: string]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">    transition?: <span class="built_in">Object</span>;</span><br><span class="line">    show?: boolean;</span><br><span class="line">    inlineTemplate?: &#123;</span><br><span class="line">        render: <span class="built_in">Function</span>;</span><br><span class="line">        staticRenderFns: <span class="built_in">Function</span>[];</span><br><span class="line">    &#125;;</span><br><span class="line">    directives?: VNodeDirective[];</span><br><span class="line">    keepAlive?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VNode 主要可分为如下5类：</p><ul><li><strong>TextVNode</strong> 文本节点</li><li><strong>ElementVNode</strong> 普通元素节点</li><li><strong>ComponentVNode</strong> 组件节点</li><li><strong>EmptyVNode</strong> 没有内容的注释节点</li><li><strong>CloneVNode</strong> 克隆节点（可以为以上任意类型）</li></ul><p><br><br><br><br><br></p><h2 id="Render-函数"><a href="#Render-函数" class="headerlink" title="Render 函数"></a>Render 函数</h2><p>Render 函数通过 <code>createElement</code> 参数来创建 Virtual DOM，有利于精简代码结构。</p><p><br><br><br><br><br></p><h2 id="createElement-用法"><a href="#createElement-用法" class="headerlink" title="createElement 用法"></a>createElement 用法</h2><h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><p>createElement 构成了 Vue Virtual DOM 的模板，它有 3 个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">createElement(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;String | Object | Function&#125; 一个HTML标签 / 组件选项 / 一个函数</span></span><br><span class="line"><span class="comment">     * 必须 Return 上述其中一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;Object&#125; 一个对应属性的数据对象（可选）</span></span><br><span class="line"><span class="comment">     * 可以在 template 中使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;String | Array&#125; 子节点（VNode）（可选）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [</span><br><span class="line">        createElement(<span class="string">'h1'</span>, <span class="string">'hello world'</span>),</span><br><span class="line">        createElement(MyComponent, &#123;</span><br><span class="line">            props: &#123; <span class="attr">someProp</span>: <span class="string">'foo'</span> &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="string">'bar'</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中，第 2 个参数 “数据对象” 的具体选项如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 和 v-bind: class 一样的API</span></span><br><span class="line">    <span class="string">'class'</span>: &#123;</span><br><span class="line">        foo: <span class="literal">true</span>,</span><br><span class="line">        bar: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 和 v-bind: style 一样的API</span></span><br><span class="line">    style: &#123;</span><br><span class="line">        color: <span class="string">'red'</span>,</span><br><span class="line">        fontSize: <span class="string">'14px'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 正常的 HTML 特性</span></span><br><span class="line">    attrs: &#123;</span><br><span class="line">        id: <span class="string">'foo'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 组件props</span></span><br><span class="line">    props: &#123;</span><br><span class="line">        myProp: <span class="string">'bar'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// DOM 属性</span></span><br><span class="line">    domProps: &#123;</span><br><span class="line">        innerHTML: <span class="string">'baz'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义事件监听器“on”</span></span><br><span class="line">    <span class="comment">// 不支持如 v-on: keyup.enter 的修饰器</span></span><br><span class="line">    <span class="comment">// 需要手动匹配 keyCode</span></span><br><span class="line">    on: &#123;</span><br><span class="line">        click: <span class="keyword">this</span>.clickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 仅对于组件，用于监听原生事件</span></span><br><span class="line">    <span class="comment">// 而不是组件使用 vm.$emit 触发的自定义事件]</span></span><br><span class="line">    nativeOn: &#123;</span><br><span class="line">        click: <span class="keyword">this</span>.nativeClickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义指令</span></span><br><span class="line">    directives: [&#123;</span><br><span class="line">        name: <span class="string">'my-custom-directive'</span>,</span><br><span class="line">        value: <span class="string">'2'</span>,</span><br><span class="line">        expression: <span class="string">'1 + 1'</span>,</span><br><span class="line">        arg: <span class="string">'foo'</span>,</span><br><span class="line">        modifiers: &#123;</span><br><span class="line">            bar: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="comment">// 作用域 slot</span></span><br><span class="line">    <span class="comment">// &#123;name: props =&gt; VNode | Array&lt;VNode&gt;&#125;</span></span><br><span class="line">    scopedSlots: &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> h(<span class="string">'span'</span>, props.text)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 具名slot</span></span><br><span class="line">    slot: <span class="string">'name-of-slot'</span>,</span><br><span class="line">    <span class="comment">// 其他特殊顶层属性</span></span><br><span class="line">    key: <span class="string">'myKey'</span>,</span><br><span class="line">    ref: <span class="string">'myRef'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>所有的组件树中，如果 VNode 是 <strong>组件</strong> 或 <strong>含有组件的 slot</strong>，那么 <strong>VNode 必须唯一</strong>。<br>&emsp;&emsp;重复渲染多个组件的方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重复渲染多个组件 */</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ele&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ele</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 局部声明组件</span></span><br><span class="line"><span class="regexp">var Child = &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        return createElement('p', 'text');</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">Vue.component('ele', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        return createElement('div', </span></span><br><span class="line"><span class="regexp">            Array.apply(null, &#123;</span></span><br><span class="line"><span class="regexp">                length: 5</span></span><br><span class="line"><span class="regexp">            &#125;).map(function() &#123;</span></span><br><span class="line"><span class="regexp">                return createElement(Child);</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#app'</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><p>对于含有组件的 slot，复用时 需要将 slot 的每个子节点都克隆一份（深度克隆）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 复用含有组件的slot，需要将slot的每个子节点都clone一份 */</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ele&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Child&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ele&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 全局注册组件</span></span><br><span class="line"><span class="regexp">Vue.component('Child', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        return createElement('p', 'text');</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">Vue.component('ele', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 克隆 slot 节点的方法</span></span><br><span class="line"><span class="regexp">        function cloneVNode(vnode) &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 递归遍历所有子节点，并克隆(工厂函数)</span></span><br><span class="line"><span class="regexp">            const clonedChildren = vnode.children &amp;&amp; </span></span><br><span class="line"><span class="regexp">            vnode.children.map(function(v) &#123;</span></span><br><span class="line"><span class="regexp">                return cloneVNode(v);</span></span><br><span class="line"><span class="regexp">            &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            const cloned = createElement(</span></span><br><span class="line"><span class="regexp">                vnode.tag,</span></span><br><span class="line"><span class="regexp">                vnode.data,</span></span><br><span class="line"><span class="regexp">                clonedChildren</span></span><br><span class="line"><span class="regexp">            );</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ VNode 关键属性</span></span><br><span class="line"><span class="regexp">            cloned.text = vnode.text;</span></span><br><span class="line"><span class="regexp">            cloned.isComment = vnode.isComment;</span></span><br><span class="line"><span class="regexp">            cloned.componentOptions = vnode.componentOptions;</span></span><br><span class="line"><span class="regexp">            cloned.elm = vnode.elm;</span></span><br><span class="line"><span class="regexp">            cloned.context = vnode.context;</span></span><br><span class="line"><span class="regexp">            cloned.ns = vnode.ns;</span></span><br><span class="line"><span class="regexp">            cloned.isStatic = vnode.isStatic;</span></span><br><span class="line"><span class="regexp">            cloned.key = vnode.key;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            return cloned;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        const vNodes = this.$slots.default;</span></span><br><span class="line"><span class="regexp">        const clonedVNodes = vNodes.map(function(vnode) &#123;</span></span><br><span class="line"><span class="regexp">            return cloneVNode(vnode);</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        return createElement('div', [</span></span><br><span class="line"><span class="regexp">            vNodes,</span></span><br><span class="line"><span class="regexp">            clonedVNodes</span></span><br><span class="line"><span class="regexp">        ]);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#app'</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="使用-JavaScript-代替模板功能"><a href="#使用-JavaScript-代替模板功能" class="headerlink" title="使用 JavaScript 代替模板功能"></a>使用 JavaScript 代替模板功能</h3><p>在 Render 函数中，<strong>不能使用 Vue 内置的指令</strong>，无论要实现什么功能，都可以用原生 JavaScript。<br>例如，使用 JS 的for 循环来实现 v-for 如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* JS 实现 v-for */</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ele :list=<span class="string">"list"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ele</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('ele', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        var nodes = [];</span></span><br><span class="line"><span class="regexp">        for(var i = 0; i &lt; this.list.length; i++) &#123;</span></span><br><span class="line"><span class="regexp">            nodes.push(createElement('p', this.list[i]));</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        return createElement('div', nodes);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    props: &#123;</span></span><br><span class="line"><span class="regexp">        list: &#123;</span></span><br><span class="line"><span class="regexp">            type: Array</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#app',</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        list: [</span></span><br><span class="line"><span class="regexp">            '《Vue.js 实战》',</span></span><br><span class="line"><span class="regexp">            '《JavaScript 高级程序设计》',</span></span><br><span class="line"><span class="regexp">            '《JavaScript 语言精粹》'</span></span><br><span class="line"><span class="regexp">        ]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><p>Render 函数里也没有与 <strong>v-model</strong> 对应的API；对于 <strong>事件修饰符</strong> 和 <strong>按键修饰符</strong>，基本也需要自己实现。下面给出一个简单的发送聊天内容的场景模拟：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 聊天发送内容的简单模拟 */</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ele&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ele</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('ele', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        var _this = this;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 渲染聊天内容列表</span></span><br><span class="line"><span class="regexp">        if (this.list.length) &#123;</span></span><br><span class="line"><span class="regexp">            var listNode = createElement('ul', this.list.map(function(item) &#123;</span></span><br><span class="line"><span class="regexp">                return createElement('li', item);</span></span><br><span class="line"><span class="regexp">            &#125;));</span></span><br><span class="line"><span class="regexp">        &#125; else &#123;</span></span><br><span class="line"><span class="regexp">            var listNode = createElement('p', '暂无聊天内容');</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ </span></span><br><span class="line"><span class="regexp">        return createElement('div', [</span></span><br><span class="line"><span class="regexp">            listNode,</span></span><br><span class="line"><span class="regexp">            createElement('input', &#123;</span></span><br><span class="line"><span class="regexp">                attrs: &#123;</span></span><br><span class="line"><span class="regexp">                    placeholder: '输入内容，按回车键发送'</span></span><br><span class="line"><span class="regexp">                &#125;,</span></span><br><span class="line"><span class="regexp">                style: &#123;</span></span><br><span class="line"><span class="regexp">                    width: '200px'</span></span><br><span class="line"><span class="regexp">                &#125;,</span></span><br><span class="line"><span class="regexp">                on: &#123;</span></span><br><span class="line"><span class="regexp">                    keyup: function(evt) &#123;</span></span><br><span class="line"><span class="regexp">                        // 如果不是回车键，不发送数据</span></span><br><span class="line"><span class="regexp">                        if (evt.keyCode !== 13) return;</span></span><br><span class="line"><span class="regexp">                        // 添加输入的内容到聊天列表</span></span><br><span class="line"><span class="regexp">                        _this.list.push(evt.target.value);</span></span><br><span class="line"><span class="regexp">                        // 发送后，清空输入框</span></span><br><span class="line"><span class="regexp">                        evt.target.value = '';</span></span><br><span class="line"><span class="regexp">                    &#125;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">        ]);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    data: function() &#123;</span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">            value: '',</span></span><br><span class="line"><span class="regexp">            list: []</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#app'</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="函数化组件"><a href="#函数化组件" class="headerlink" title="函数化组件"></a>函数化组件</h2><p>将 <strong>functional 布尔值选项</strong>设置为 true，可以使组件 <strong>无状态</strong> 和 <strong>无实例</strong>，即 没有 data 和 this上下文。这样用 render 函数返回虚拟节点可以更容易渲染。<br>&emsp;&emsp;使用函数化组件时，Render 函数通过第二个参数 context 来提供 <strong>临时上下文</strong>。组件需要的 <strong>data、props、slots、children、parent</strong> 都是通过这个上下文来传递的。比如， <code>this.level</code> 要改写为 <code>context.props.level</code>， <code>this.$slots.default</code>改写为 <code>context.children</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用函数化组件 展示一个 根据数据 智能选择不同组件 的场景 */</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;smart-item :data=<span class="string">"data"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">smart-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change('img')"</span>&gt;</span>切换为图片组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change('video')"</span>&gt;</span>切换为视频组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change('text')"</span>&gt;</span>切换为文本组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 图片组件选项</span></span><br><span class="line"><span class="keyword">var</span> ImgItem = &#123;</span><br><span class="line">    props: [<span class="string">'data'</span>],</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">            createElement(<span class="string">'p'</span>, <span class="string">'图片组件'</span>),</span><br><span class="line">            createElement(<span class="string">'img'</span>, &#123;</span><br><span class="line">                attrs: &#123;</span><br><span class="line">                    src: <span class="keyword">this</span>.data.url</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 视频组件选项</span></span><br><span class="line"><span class="keyword">var</span> VideoItem = &#123;</span><br><span class="line">    props: [<span class="string">'data'</span>],</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">            createElement(<span class="string">'p'</span>, <span class="string">'视频组件'</span>),</span><br><span class="line">            createElement(<span class="string">'video'</span>, &#123;</span><br><span class="line">                attrs: &#123;</span><br><span class="line">                    src: <span class="keyword">this</span>.data.url,</span><br><span class="line">                    controls: <span class="string">'controls'</span>,</span><br><span class="line">                    autoplay: <span class="string">'autoplay'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纯文本组件选项</span></span><br><span class="line"><span class="keyword">var</span> TextItem = &#123;</span><br><span class="line">    props: [<span class="string">'data'</span>],</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">            createElement(<span class="string">'p'</span>, <span class="string">'纯文本组件'</span>),</span><br><span class="line">            createElement(<span class="string">'p'</span>, <span class="keyword">this</span>.data.text),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义 smart-item 组件</span></span><br><span class="line">Vue.component(<span class="string">'smart-item'</span>, &#123;</span><br><span class="line">    <span class="comment">// 函数化组件</span></span><br><span class="line">    functional: <span class="literal">true</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 根据传入的数据，智能判断显示哪种组件</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data = context.props.data;</span><br><span class="line">            <span class="comment">// 判断 prop: data 的 type 字段是属于哪种类型的组件</span></span><br><span class="line">            <span class="keyword">if</span> (data.type === <span class="string">'img'</span>) <span class="keyword">return</span> ImgItem;</span><br><span class="line">            <span class="keyword">if</span> (data.type === <span class="string">'video'</span>) <span class="keyword">return</span> VideoItem;</span><br><span class="line">            <span class="keyword">return</span> TextItem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createElement(</span><br><span class="line">            getComponent(),</span><br><span class="line">            &#123;</span><br><span class="line">                props: &#123;</span><br><span class="line">                    <span class="comment">// 把 smart-item 的 prop: data 传给上面智能选择的组件</span></span><br><span class="line">                    data: context.props.data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            context.children</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            type: <span class="built_in">Object</span>,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        data: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 切换不同类型组件的数据</span></span><br><span class="line">        change: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (type === <span class="string">'img'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.data = &#123;</span><br><span class="line">                    type: <span class="string">'img'</span>,</span><br><span class="line">                    url: <span class="string">'https://raw.githubusercontent.com/iview/iview/master/assets/logo.png'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'video'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.data = &#123;</span><br><span class="line">                    type: <span class="string">'video'</span>,</span><br><span class="line">                    url: <span class="string">'http://vjs/zencdn.net/v/oceans.mp4'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'text'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.data = &#123;</span><br><span class="line">                    type: <span class="string">'text'</span>,</span><br><span class="line">                    content: <span class="string">'这是一段纯文本'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化时，默认设置 图片组件 的数据</span></span><br><span class="line">        <span class="keyword">this</span>.change(<span class="string">'img'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，smart-item 和 3个功能组件 都有 <code>prop: data</code>，这里通过 <code>createElement</code> 函数把 <code>getComponent()</code> 返回的对象设置为第一个参数，通过第二个参数 <code>context</code> 把 <code>smart-item</code> 的<code>data</code> 传递到选择的组件里的 <code>prop: data</code>，组件渲染出不同的内容。</p><p>总的来说，函数化组件 主要适用于以下两个场景：</p><ul><li>程序化地在多个组件中选择一个.</li><li>在将 children，props，data 传递给子组件之前 操作它们.</li></ul><p><br><br><br><br><br></p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>使用 Render 函数最不友好的地方在于，当子节点嵌套较多时，使用 createElement 难以书写及阅读出 DOM结构。<br>&emsp;&emsp;<strong>JSX</strong> 是一种看起来像 HTML，但实际是 <strong>JavaScript 的语法扩展</strong>，它用更接近 DOM 结构的形式 来描述一个组件的 UI 和状态信息。Vue.js 提供了插件 <code>babel-plugin-transform-vue-jsx</code> 来支持 JSX 语法。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Virtual-DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM&quot;&gt;&lt;/a&gt;Virtual DOM&lt;/h2&gt;&lt;p&gt;Virtual DOM 是一个轻量级的 Javascript 对象，
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue.js实战" scheme="http://fujiafeng.com/tags/Vue-js%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 基础语法</title>
    <link href="http://fujiafeng.com/2019/10/20/Vue-js-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://fujiafeng.com/2019/10/20/Vue-js-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2019-10-20T15:41:38.000Z</published>
    <updated>2020-01-06T09:52:49.422Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 简介：</p><ul><li>用于构建用户界面的 <strong>渐进式框架</strong>；</li><li>使用 <strong>Virtual DOM</strong>（<strong>数据驱动</strong> DOM）；</li><li>提供 <strong>响应式、组件化</strong> 的视图组件；</li><li>只关注核心库（声明式渲染+组件系统），其余交给其他库实现：<ul><li>客户端路由：<strong>Vue Router</strong></li><li>大规模状态管理：<strong>Vuex</strong></li><li>构建工具：<strong>Vue CLI</strong></li></ul></li></ul><p><br><br><img width="80%"><br><img src="/2019/10/20/Vue-js-基础语法/虚拟dom.png" title="Vue虚拟DOM"><br><br><img width="80%"><br><img src="/2019/10/20/Vue-js-基础语法/依赖追踪.png" title="Vue依赖追踪"><br></p><h2 id="vue-指令"><a href="#vue-指令" class="headerlink" title="vue 指令"></a>vue 指令</h2><p>以下指令 可使用 <em>对象语法</em>、<em>数组语法</em> 或 <code>data</code>、<code>methods</code>、<code>computed</code> 选项：</p><ul><li><strong>v-on</strong>   绑定事件监听器（事件 / 按键修饰符）</li><li><strong>v-bind</strong>   （1）动态更新 HTML元素；（2）class 与 style 的绑定。</li></ul><p>以下指令用于 在<strong>表单</strong>中双向数据绑定：</p><ul><li><strong>v-model</strong>    双向绑定数据</li></ul><p>以下指令用于 <strong>组件</strong>：</p><ul><li><strong>v-slot</strong>   具名插槽</li></ul><p>以下指令 可用在内置标签 <code>&lt;template&gt;</code> 上：</p><ul><li><strong>v-if / v-else-if / v-else</strong>  条件渲染</li><li><strong>v-show</strong>   改变元素的 CSS属性 display</li><li><strong>v-for</strong>   列表渲染指令（可用于 Array，Object）</li></ul><p>其他常用指令：</p><ul><li><strong>v-cloak</strong>  Vue实例 结束编译时，从绑定的 HTML元素上移除</li><li><strong>v-once</strong>  定义它的元素/组件 只渲染一次</li><li><strong>v-html</strong>  </li><li><strong>v-pre</strong>   跳过编译过程</li></ul><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul><li>v-bind 可简写为 <code>:</code> ;</li><li>v-on 可简写为 <code>@</code></li></ul><blockquote><p>语法糖：<br>&emsp;&emsp;在不影响功能的情况下，添加某种方法 实现同样的效果。</p></blockquote><h3 id="Vue-检测数组更新"><a href="#Vue-检测数组更新" class="headerlink" title="Vue 检测数组更新"></a>Vue 检测数组更新</h3><p>Vue 包含了一组观察 <strong>数组变异</strong> 的方法，如下：</p><ul><li><strong>push()  /  pop()</strong></li><li><strong>shift()  /  unshift()</strong></li><li><strong>splice()</strong></li><li><strong>sort()  /  reverse()</strong></li></ul><p>也包含一些 <strong>非变异方法</strong>，如下：</p><ul><li><strong>filter()</strong></li><li><strong>concat()</strong></li><li><strong>slice()</strong></li></ul><p>注意，以下数组操作，<strong>Vue 不能检测</strong>到，也不会触发视图更新：</p><ul><li><strong>通过索引直接设置项</strong>：app.books[3] = { … };</li><li><strong>修改数组长度</strong>：app.books.length = 1;</li></ul><p><br><br><br><br><br></p><h2 id="vue-实例选项"><a href="#vue-实例选项" class="headerlink" title="vue 实例选项"></a>vue 实例选项</h2><ul><li><strong>el</strong>  指定一个页面中已存在的 DOM元素，来挂载 Vue实例</li><li><strong>data</strong>   声明应用内需要双向绑定的数据</li><li><strong>computed</strong>   计算属性（函数形式 /  <code>{ get: Function, set: Function }</code>）<ol><li>文本插值；</li><li>动态地设置元素样式名class、内联样式style；</li><li>使用组件时，动态传递props</li></ol></li><li><strong>methods</strong>   声明方法</li><li><strong>components</strong>   声明组件</li><li><strong>props</strong>   父组件传值</li><li><strong>filters</strong>   声明过滤器（用于简单的 文本转换）</li></ul><p><br><br><br><br><br></p><h2 id="vue-实例生命周期钩子"><a href="#vue-实例生命周期钩子" class="headerlink" title="vue 实例生命周期钩子"></a>vue 实例生命周期钩子</h2><ul><li><strong>beforeCreate / created</strong>  创建</li><li><strong>beforeMount / mounted</strong>  挂载（挂载后 <code>$el</code> 才可用）</li><li><strong>beforeUpdate / updated</strong>  数据更新</li><li><strong>activated / deactivated</strong>  keep-alive组件 激活/停用 时（vue-router）</li><li><strong>beforeDestroy / destroyed</strong>  销毁</li></ul><p><img width="80%"><br><img src="/2019/10/20/Vue-js-基础语法/Vue生命周期.png" title="Vue生命周期"><br></p><p><strong>父子组件 生命周期 执行顺序：</strong></p><ul><li><p>加载渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt;</span><br><span class="line">子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt;</span><br><span class="line">子 mounted -&gt; 父 mounted</span><br></pre></td></tr></table></figure></li><li><p>子组件更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父 beforeUpdate -&gt; 子 beforeUpdate -&gt; </span><br><span class="line">子 updated -&gt; 父 updated</span><br></pre></td></tr></table></figure></li><li><p>父组件更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父 beforeUpdate -&gt; 父 updated</span><br></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父 beforeDestroy -&gt; 子 beforeDestroy -&gt;</span><br><span class="line">子 destroyed -&gt; 父 destroyed</span><br></pre></td></tr></table></figure></li></ul><p>更多详情请见：<a href="https://cn.vuejs.org/v2/api/index.html" target="_blank" rel="noopener">VueJs API文档</a></p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue.js 简介：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于构建用户界面的 &lt;strong&gt;渐进式框架&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;Virtual DOM&lt;/strong&gt;（&lt;strong&gt;数据驱动&lt;/strong&gt; DOM）；&lt;/li&gt;
&lt;li&gt;提
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue.js实战" scheme="http://fujiafeng.com/tags/Vue-js%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>ESLint 代码检查工具</title>
    <link href="http://fujiafeng.com/2019/09/26/ESLint-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    <id>http://fujiafeng.com/2019/09/26/ESLint-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</id>
    <published>2019-09-25T16:35:25.000Z</published>
    <updated>2019-09-25T16:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-ESLint"><a href="#关于-ESLint" class="headerlink" title="关于 ESLint"></a>关于 ESLint</h1><p>ESLint 是一个插件化的 javascript 代码检测工具，借助 ESLint，可将 <strong>静态代码分析</strong> 和 <strong>问题代码协助修复</strong> 集成到 <strong>编码</strong>、<strong>提交</strong> 和 <strong>打包</strong> 过程中，及早发现并协助修复代码中：</p><ol><li>有语法错误的部分</li><li>不符合约定的样式准则的部分</li><li>不符合约定的最佳实践的部分</li></ol><p>在项目开发中获得如下收益：</p><ol><li>在执行代码之前发现并修复语法错误，减少调试耗时和潜在 bug</li><li>保证项目的 <strong>编码风格统一</strong>，提高可维护性</li><li>督促团队成员在编码时遵守约定的最佳实践，提高代码质量</li></ol><p><br><br><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><br></p><h2 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g eslint</span><br></pre></td></tr></table></figure><p>初始化配置文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eslint --init</span><br></pre></td></tr></table></figure></p><h2 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install eslint --save-dev</span><br></pre></td></tr></table></figure><p>初始化配置文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./node_modules/.bin/eslint --init</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h1 id="规则配置模式"><a href="#规则配置模式" class="headerlink" title="规则配置模式"></a>规则配置模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">规则名： [ 错误级别， 附加选项 ]</span><br><span class="line">规则名： 错误级别</span><br></pre></td></tr></table></figure><p>ESLint 定义了 <strong>三种错误级别</strong>：</p><ul><li><p><strong>“off”</strong> 或 <strong>0</strong> - 关闭，不校验该规则</p></li><li><p><strong>“warn”</strong> 或 <strong>1</strong> - 警告，不影响 exit code</p></li><li><p><strong>“error”</strong> 或 <strong>2</strong> - 错误，触发该规则时 exit code 为 1</p></li></ul><p><br><br><br></p><h1 id="webpack-中配置-eslint-（vue版）"><a href="#webpack-中配置-eslint-（vue版）" class="headerlink" title="webpack 中配置 eslint （vue版）"></a>webpack 中配置 eslint （vue版）</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">  loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">  enforce: <span class="string">'pre'</span>,</span><br><span class="line">  include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">  options: &#123;</span><br><span class="line">    formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>),</span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="vue-cli-的-eslintrc-js-配置文件："><a href="#vue-cli-的-eslintrc-js-配置文件：" class="headerlink" title="vue-cli 的 .eslintrc.js 配置文件："></a>vue-cli 的 .eslintrc.js 配置文件：</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//此项是用来告诉eslint找当前配置文件不能往父级查找</span></span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析</span></span><br><span class="line">  parser: <span class="string">'babel-eslint'</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//此项是用来指定javaScript语言类型和风格，sourceType用来指定js导入的方式，默认是script，此处设置为module，指某块导入方式</span></span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//此项指定环境的全局变量，下面的配置指定为浏览器环境</span></span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style</span></span><br><span class="line">  <span class="comment">// 此项是用来配置标准的js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错</span></span><br><span class="line">  extends: <span class="string">'standard'</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// required to lint *.vue files</span></span><br><span class="line">  <span class="comment">// 此项是用来提供插件的，插件名称省略了eslint-plugin-，下面这个配置是用来规范html的</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">'html'</span></span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// add your custom rules here</span></span><br><span class="line">  <span class="comment">// 下面这些rules是用来设置从插件来的规范代码的规则，使用必须去掉前缀eslint-plugin-</span></span><br><span class="line">  <span class="comment">// 主要有如下的设置规则，可以设置字符串也可以设置数字，两者效果一致</span></span><br><span class="line">  <span class="comment">// "off" -&gt; 0 关闭规则</span></span><br><span class="line">  <span class="comment">// "warn" -&gt; 1 开启警告规则</span></span><br><span class="line">  <span class="comment">//"error" -&gt; 2 开启错误规则</span></span><br><span class="line">  <span class="comment">// 了解了上面这些，下面这些代码相信也看的明白了</span></span><br><span class="line">  <span class="string">'rules'</span>: &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// allow paren-less arrow functions</span></span><br><span class="line">    <span class="string">'arrow-parens'</span>: <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allow async-await</span></span><br><span class="line">    <span class="string">'generator-star-spacing'</span>: <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allow debugger during development</span></span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">'no-multi-str'</span>: <span class="number">2</span>, <span class="comment">// 字符串不能用\换行</span></span><br><span class="line">    <span class="string">'no-unreachable'</span>: <span class="number">2</span>, <span class="comment">// 不能有无法执行的代码</span></span><br><span class="line">    <span class="string">'no-use-before-define'</span>: <span class="number">2</span>, <span class="comment">// 违背顶以前不能使用</span></span><br><span class="line">    <span class="string">'no-with'</span>: <span class="number">2</span>, <span class="comment">// 禁用with</span></span><br><span class="line">    <span class="string">'arrow-spacing'</span>: <span class="number">0</span>, <span class="comment">// =&gt; 的前/后括号</span></span><br><span class="line">    <span class="string">'brace-style'</span>: [<span class="number">1</span>, <span class="string">'1tbs'</span>], <span class="comment">// 大括号风格</span></span><br><span class="line">    <span class="string">'comma-style'</span>: [<span class="number">2</span>, <span class="string">'1ast'</span>], <span class="comment">// 逗号风格，换行是在行首还是行尾</span></span><br><span class="line">    <span class="string">'curly'</span>: [<span class="number">2</span>, <span class="string">'all'</span>], <span class="comment">// 必须使用 if()&#123;&#125; 中的&#123;&#125;</span></span><br><span class="line">    <span class="string">'indent'</span>: [<span class="number">2</span>, <span class="number">4</span>], <span class="comment">//缩进风格</span></span><br><span class="line">    <span class="string">'use-isnan'</span>: <span class="number">2</span>, <span class="comment">// 禁止比较时使用 NaN，只能用 isNan()</span></span><br><span class="line">    <span class="string">'semi-spacing'</span>: [<span class="number">0</span>, &#123;<span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">true</span>&#125;], <span class="comment">// 分号前后空格</span></span><br><span class="line">    <span class="string">'spaced-comment'</span>: <span class="number">0</span>, <span class="comment">// 注释风格要不要空格</span></span><br><span class="line">    <span class="string">'space-before-blocks'</span>: [<span class="number">0</span>, <span class="string">'always'</span>], <span class="comment">// 不以新行开始的代码块 &#123; 前要不要空格</span></span><br><span class="line">    <span class="string">'eol-last'</span>: <span class="number">0</span>, <span class="comment">// 文件 不以单一的换行符结束</span></span><br><span class="line">    <span class="string">'space-before-function-paren'</span>: [<span class="number">0</span>, <span class="string">"always"</span>], <span class="comment">// 函数定义时，括号前面是否要空格</span></span><br><span class="line">    <span class="string">'no-trailing-space'</span>: <span class="number">0</span>, <span class="comment">// 一行结束空格</span></span><br><span class="line">    <span class="string">'quotes'</span>: [<span class="number">0</span>, <span class="string">'single'</span>], <span class="comment">// 引号类型 '' "" ``</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="VSCode-集成"><a href="#VSCode-集成" class="headerlink" title="VSCode 集成"></a>VSCode 集成</h1><p><strong>代码提示</strong><br>工具： VSCode ESLint 插件<br>使用：在 VSCode 设置中将 <code>eslint.enable</code> 设置为 <code>true</code></p><p><strong>代码修复</strong><br>工具：VSCode Prettier 插件<br>使用：在 VSCode 设置中将 <code>prettier.eslintIntegration</code> 设置为 <code>true</code>，prettier 插件执行格式化时将使用 prettier-eslint 完成下述操作：</p><ol><li>使用 prettier 格式化代码</li><li>对上一步格式化过的代码执行 <code>eslint --fix</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于-ESLint&quot;&gt;&lt;a href=&quot;#关于-ESLint&quot; class=&quot;headerlink&quot; title=&quot;关于 ESLint&quot;&gt;&lt;/a&gt;关于 ESLint&lt;/h1&gt;&lt;p&gt;ESLint 是一个插件化的 javascript 代码检测工具，借助 ESLint
      
    
    </summary>
    
    
    
      <category term="工具" scheme="http://fujiafeng.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vscode 快捷键（windows）</title>
    <link href="http://fujiafeng.com/2019/09/23/vscode-%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88windows%EF%BC%89/"/>
    <id>http://fujiafeng.com/2019/09/23/vscode-%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88windows%EF%BC%89/</id>
    <published>2019-09-23T14:38:19.000Z</published>
    <updated>2019-09-23T14:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>【Ctrl + Shift + P】</strong>    打开命令面板<br>&emsp;&emsp;<strong>【Ctrl + U】</strong>   返回上一个光标位置<br>&emsp;&emsp;<strong>【Home/End】</strong>    光标移动至行首或行尾<br>&emsp;&emsp;<strong>【Ctrl + Home/End】</strong>    光标移动至文档的开头或末尾<br>&emsp;&emsp;<strong>【Ctrl + D】</strong>    选中单词（第二次按下，会找到文档中下一次出现该单词的位置 并选中单词）<br>&emsp;&emsp;<strong>【Alt + 上下】</strong>    代码移动<br>&emsp;&emsp;<strong>【Ctrl + /】</strong>    行注释<br>&emsp;&emsp;<strong>【Alt + Shift + F】</strong>    格式化整个文档<br>&emsp;&emsp;<strong>【Alt + 鼠标点击】</strong>    多光标<br>&emsp;&emsp;<strong>【Alt + Shift + I】</strong>    在选中的多行代码的 每一行 （已选中内容）后边都会添加光标<br>&emsp;&emsp;<strong>【Ctrl + P】</strong>    快速打开文件<br>&emsp;&emsp;<strong>【Ctrl + G】</strong>    快速跳转（代码行）<br>&emsp;&emsp;<strong>【Ctrl + Shift + O】</strong>    符号跳转（符号：文件名、函数名、css类名）<br>&emsp;&emsp;<strong>【F12】</strong>    跳转至 函数定义处<br>&emsp;&emsp;<strong>【Ctrl + F12】</strong>    跳转至 函数实现处<br>&emsp;&emsp;<strong>【Shift + F12】</strong>    引用跳转（先将光标移动到 函数/类 上）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;【Ctrl + Shift + P】&lt;/strong&gt;    打开命令面板&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;【Ctrl + U】&lt;/strong&gt;   返回上一个光标位置&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;【Home/End】&lt;/s
      
    
    </summary>
    
    
    
      <category term="工具" scheme="http://fujiafeng.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>侧耳倾听 Vol.4</title>
    <link href="http://fujiafeng.com/2019/09/16/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-4/"/>
    <id>http://fujiafeng.com/2019/09/16/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-4/</id>
    <published>2019-09-16T13:41:02.000Z</published>
    <updated>2019-09-16T13:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>#抄句子#</em></p><blockquote><p>「春有百花秋有月，夏有涼風冬有雪。<br>&emsp;&emsp;&emsp;若無閒事掛心頭，便是人間好時節。」</p></blockquote><p><br></p><blockquote><p>「晴秋上午 隨便走走 不一定要快樂」  &emsp;—— 木心</p></blockquote><p><br></p><blockquote><p>「 我希望你嚮往生命的盎然<br>&emsp;&emsp;&emsp;不會受傷<br>&emsp;&emsp;&emsp;會熱愛生活<br>&emsp;&emsp;&emsp;我想和你一起遊戲人間<br>&emsp;&emsp;&emsp;愛得坦蕩<br>&emsp;&emsp;&emsp;呼吸都想念我 」   &emsp;—— 賈平凹</p></blockquote><p><br></p><blockquote><p>「一個傷痛著的人置身一個陌生的環境是幸福的，因為你不必在熟悉的人和風景面前故作堅強，你完全可以放縱地流淚。」   &emsp;—— 《世界上所有的夜晚》 遲子建</p></blockquote><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;#抄句子#&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「春有百花秋有月，夏有涼風冬有雪。&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;若無閒事掛心頭，便是人間好時節。」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="侧耳倾听" scheme="http://fujiafeng.com/tags/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC/"/>
    
  </entry>
  
</feed>
