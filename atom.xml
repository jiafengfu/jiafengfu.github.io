<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FU&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/73cc2ea2ef5bc47deb559bec0ea4d367</icon>
  <subtitle>Fashion passes ,   style remains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fujiafeng.com/"/>
  <updated>2020-01-05T14:37:30.366Z</updated>
  <id>http://fujiafeng.com/</id>
  
  <author>
    <name>Jiafeng Fu</name>
    <email>jiafengfu@github.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript DOM</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-DOM/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-DOM/</id>
    <published>2020-01-05T14:27:23.000Z</published>
    <updated>2020-01-05T14:37:30.366Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>BOM</strong> = browser Object Model 浏览器对象模型</p></blockquote><p>BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。其中，<strong>浏览器之间共有的对象</strong> 成为了事实标准。</p><p>W3C 为了把浏览器中JavaScript 最基本的部分标准化，已经将 <strong>BOM的主要方面</strong> 纳入了 <strong>HTML5 的规范</strong>中。</p><p><br><br><br><br><br></p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>BOM 的核心对象是window，它表示 <strong>浏览器的一个实例</strong>。<br>在浏览器中，window 对象有双重角色：</p><ol><li>通过JavaScript 访问浏览器窗口的一个接口；</li><li>ECMAScript 规定的Global 对象。</li></ol><p><br></p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>由于window 对象同时扮演着ECMAScript 中Global 对象的角色，因此 <strong>所有在全局作用域中声明的变量、函数 都会变成window 对象的属性和方法</strong>。</p><blockquote><p><u>定义全局变量</u> 与 <u>在window 对象上直接定义属性</u> 的差别：<br>全局变量不能通过delete 操作符删除，而直接在window 对象上定义的属性可以。</p></blockquote><ul><li>使用<code>var</code> 语句添加的window 属性有一个名为 <code>[[Configurable]]</code> 的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。</li><li>IE8及更早版本 在遇到使用delete删除window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。</li><li>尝试访问未声明的变量会抛出错误，但是<strong>通过 <u>查询window 对象</u>，可以知道某个可能未声明的变量是否存在</strong>。</li></ul><p><br></p><h4 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h4><ul><li>如果页面中包含框架，则每个框架都拥有自己的window 对象，并且保存在 <strong>frames 集合</strong>中。</li><li>在frames集合中，可以通过 <strong>数值索引</strong>（从0 开始，从左至右，从上到下）或者 <strong>框架名称</strong> 来访问相应的window 对象。</li><li>每个window 对象都有一个 <strong>name 属性</strong>，其中包含框架的名称（注意，除非最高层窗口是通过 <code>window.open()</code> 打开的，否则其window 对象的 <code>name</code> 属性不会包含任何值）。</li></ul><blockquote><p>对于 <u>在一个框架中</u> 编写的任何代码来说，其中的 <u>window 对象</u> 指向的都是 <u>那个框架的特定实例</u>，而非最高层的框架。</p></blockquote><p><strong>与框架有关的对象</strong>（window对象）：</p><ul><li><strong>top 对象</strong>：始终指向 <strong>最高（最外）层的框架</strong>，也就是浏览器窗口（使用它可以确保在一个框架中正确地访问另一个框架）；</li><li><strong>parent（父）对象</strong>：始终指向当前框架的 <strong>直接上层框架</strong>（在某些情况下，parent 有可能等于top；在没有框架的情况下，parent 一定等于top，此时它们都等于window）；</li><li><strong>self 对象</strong>：<strong>始终指向window</strong>；实际上，self 和window 对象可以互换使用（引入self 对象的目的只是为了与top 和parent 对象相对应）。</li></ul><p>以下是一个包含框架的页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"160,*"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame.htm"</span> <span class="attr">name</span>=<span class="string">"topFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"anotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"leftFrame"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"yetanotherframe.htm"</span> <span class="attr">name</span>=<span class="string">"rightFrame"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在 <strong>最高层窗口</strong> 中，通过代码来访问上述代码中每个框架的不同方式如下：</p><img src="/2020/01/05/JavaScript-DOM/窗口关系.png" title="窗口关系"><p><br></p><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><blockquote><p>窗口相对于屏幕左边和上边的位置：</p><ul><li><strong>screenLeft</strong> 和 <strong>screenTop</strong> —— Safari、Chrome、IE、Opera；</li><li><strong>screenX</strong> 和 <strong>screenY</strong> —— Firefox、Safari、Chrome。</li></ul></blockquote><p><strong>跨浏览器获取 窗口左边和上边的位置</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ?</span><br><span class="line">    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：</p><p>在IE、Opera 中，screenLeft 和screenTop 中保存的是 <strong>从屏幕左边和上边到由window 对象表示的<u>页面可见区域</u>的距离</strong>。换句话说，如果window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox 和Safari 中，screenY 或screenTop中保存的是 <strong><u>整个浏览器窗口</u>相对于屏幕的坐标值</strong>，即在窗口的y 轴坐标为0 时返回0。</p><p>Firefox、Safari 和Chrome <strong>始终返回页面中每个框架的top.screenX 和top.screenY 值</strong>。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX 和screenY 每次也都会返回相同的值。而IE 和Opera 则会给出框架相对于屏幕边界的精确坐标值。</p><p>最终结果，就是 <strong>无法</strong> 在跨浏览器的条件下取得窗口左边和上边的精确坐标值。</p></blockquote><p>将窗口精确地移动到一个新位置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将窗口移动到屏幕左上角</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//将窗向下移动100 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//将窗口移动到(200,300)</span></span><br><span class="line"><span class="built_in">window</span>.moveTo(<span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">//将窗口向左移动50 像素</span></span><br><span class="line"><span class="built_in">window</span>.moveBy(<span class="number">-50</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7（及更高版本）中默认就<br>是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。</p><p><br></p><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><blockquote><p>跨浏览器确定一个窗口的大小不是一件简单的事。<br>IE9+、Firefox、Safari、Opera 和Chrome 均为此提供了4 个属性：<strong>innerWidth</strong>、<strong>innerHeight</strong>、<strong>outerWidth</strong> 和<strong>outerHeight</strong>。在IE9+、Safari 和Firefox中，outerWidth 和outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的window 对象还是从某个框架访问）。在Opera 中，这两个属性的值表示页面视图容器①的大小。而innerWidth 和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome 中，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。</p><p>IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM 提供了页面可见区域的相关信息。</p><p>在IE、Firefox、Safari、Opera 和Chrome 中，<strong>document.documentElement.clientWidth</strong> 和<strong>document.documentElement.clientHeight</strong> 中保存了页面视口的信息。在IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过 <strong>document.body.clientWidth</strong> 和 <strong>document.body.clientHeight</strong> 取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentElement还是document.body 中的clientWidth 和clientHeight 属性，都可以取得视口的大小。</p></blockquote><p>虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>) &#123; <span class="comment">// 标准模式</span></span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>resizeTo()</code> 和 <code>resizeBy()</code> 方法可以调整浏览器窗口的大小：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整到100×100</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//调整到200×150</span></span><br><span class="line"><span class="built_in">window</span>.resizeBy(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//调整到 300×300</span></span><br><span class="line"><span class="built_in">window</span>.resizeTo(<span class="number">300</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure></p><p>在Opera和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window 对象使用。</p><p><br></p><h4 id="导航-amp-打开窗口"><a href="#导航-amp-打开窗口" class="headerlink" title="导航 &amp; 打开窗口"></a>导航 &amp; 打开窗口</h4><p><strong><code>window.open()</code></strong> 方法：<br>（1）导航到一个特定的URL；<br>（2）打开一个新的浏览器窗口。</p><blockquote><p>这个方法可以接收4 个参数：</p><ol><li>要加载的URL；</li><li>窗口目标；</li><li>一个特性字符串；</li><li>一个表示 <u>新页面是否取代浏览器历史记录中当前加载页面</u> 的布尔值。</li></ol></blockquote><p>通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top 或_blank。</p><ol><li><strong>弹出窗口</strong></li></ol><p>如果给 <code>window.open()</code> 传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。</p><p>第三个参数是一个 <strong>逗号分隔的设置字符串</strong>，表示在新窗口中都显示哪些特性。其中，名值对以<strong>等号</strong>表示（注意，整个特性字符串中 <u>不允许出现空格</u>）。</p><p><code>window.open()</code> 方法会返回一个指向新窗口的引用。</p><p>调用 <code>close()</code> 方法还可以关闭 <code>window.open()</code>  新打开的窗口。弹出窗口关闭之后，窗口的引用仍然还在，但除了检测其 <strong>closed 属性</strong>之外，已经没有其他用处了</p><p>新创建的window 对象有一个 <strong><code>opener</code></strong> 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window 对象（top）中有定义，而且指向调用 <code>window.open()</code> 的窗口或框架。</p><p>虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口。</p><blockquote><p>有些浏览器（如IE8 和Chrome）会在 <strong>独立的进程</strong> 中运行每个标签页。当一个标签页打开另一个标签页时，<strong>如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中</strong>。在Chrome中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页。</p></blockquote><ol><li><strong>弹出窗口屏蔽程序</strong></li></ol><p>如果是浏览器 <strong>内置的屏蔽程序</strong> 阻止的弹出窗口，那么 <strong>window.open()很可能会返回null</strong>。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line"><span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是 <strong>浏览器扩展或其他程序</strong> 阻止的弹出窗口，那么<code>window.open()</code>通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 <code>window.open()</code> 的调用封装在一个<code>try-catch</code> 块中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blocked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open(<span class="string">"http://www.wrox.com"</span>, <span class="string">"_blank"</span>);</span><br><span class="line">    <span class="keyword">if</span> (wroxWin == <span class="literal">null</span>) &#123;</span><br><span class="line">        blocked = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">    alert(<span class="string">"The popup was blocked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="间歇调用-amp-超时调用"><a href="#间歇调用-amp-超时调用" class="headerlink" title="间歇调用 &amp; 超时调用"></a>间歇调用 &amp; 超时调用</h4><blockquote><p>JavaScript 是一个<strong>单线程</strong>序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript <strong>任务队列</strong>。这些任务会按照将它们添加到队列的顺序执行。</p></blockquote><p>JavaScript 是 <strong>单线程</strong>语言，但它允许通过设置 <strong>超时值</strong> 和 <strong>间歇时间值</strong> 来调度代码 <u>在特定的时刻</u> 执行。</p><ol><li>超时调用</li></ol><p><strong>超时调用</strong> 需要使用window 对象的 <strong><code>setTimeout()</code></strong> 方法。setTimeout()的第二个参数告诉JavaScript 再过多长时间 <strong>把当前任务添加到 JavaScript任务队列</strong>中。<u>如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行</u>。</p><p>调用 <code>setTimeout()</code> 之后，该方法会返回一个<strong>数值ID</strong>，表示超时调用。这个超时调用ID 是<strong>计划执行代码的唯一标识符</strong>，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 <code>clearTimeout()</code> 方法并将相应的超时调用ID 作为参数传递给它。</p><ol><li>间歇调用</li></ol><p><strong>间歇调用</strong> 的方法是 <strong><code>setInterval()</code></strong> ，它会按照 <u>指定的时间间隔</u> <strong>重复执行</strong> 代码，直至<u><strong>间歇调用被取消</strong></u>或者<u><strong>页面被卸载</strong></u>。</p><p>调用 <code>setInterval()</code> 方法同样也会返回一个 <strong>间歇调用ID</strong>，该ID 可用于在将来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用 <strong><code>clearInterval()</code></strong> 方法并传入相应的间歇调用ID。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> intervalId = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">//如果执行次数达到了max 设定的值，则取消后续尚未执行的调用</span></span><br><span class="line">    <span class="keyword">if</span> (num == max) &#123;</span><br><span class="line">        clearInterval(intervalId);</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">intervalId = setInterval(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p><p>使用超时调用来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="comment">//如果执行次数未达到max 设定的值，则设置另一次超时调用</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">        setTimeout(incrementNumber, <span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"Done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(incrementNumber, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。</p></blockquote><p><br></p><h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><ul><li>浏览器通过 <code>alert()</code>、<code>confirm()</code> 和 <code>prompt()</code> 方法可以调用系统对话框向用户显示消息。</li><li>系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。</li><li>通过这几个方法打开的对话框都是 <strong>同步</strong> 和 <strong>模态</strong> 的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。</li></ul><p><br><br><br><br><br></p><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location 提供了与 <strong>当前窗口中加载的文档</strong> 有关的信息，还提供了一些导航功能。</p><p>location 对象是很特别的一个对象，因为它既是window 对象的属性，也是document 对象的属性；换句话说，<code>window.location</code> 和 <code>document.location</code> 引用的是同一个对象。</p><p><strong>location 对象的作用：</strong><br>（1）保存着当前文档的信息；<br>（2）它将URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段</p><p><img src="en-resource://database/631:1" alt="1553e212e5f94576dba0e8d40aaa45c1.png"><br><img src="/2020/01/05/JavaScript-DOM/location对象.png" title="location对象"></p><p><br></p><h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//取得查询字符串并去掉开头的问号</span></span><br><span class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">        <span class="comment">//保存数据的对象</span></span><br><span class="line">        args = &#123;&#125;,</span><br><span class="line">        <span class="comment">//取得每一项</span></span><br><span class="line">        items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">        item = <span class="literal">null</span>,</span><br><span class="line">        name = <span class="literal">null</span>,</span><br><span class="line">        value = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">//在for 循环中使用</span></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = items.length;</span><br><span class="line">    <span class="comment">//逐个将每一项添加到args 对象中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><p>使用location 对象可以通过很多方式来改变浏览器的位置。</p><h5 id="assign-URL-方法"><a href="#assign-URL-方法" class="headerlink" title="assign(URL) 方法"></a>assign(URL) 方法</h5><p>立即打开新URL 并在浏览器的历史记录中生成一条记录。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure></p><h5 id="href-属性"><a href="#href-属性" class="headerlink" title="href 属性"></a>href 属性</h5><p>如果是将 <code>location.href</code> 或 <code>window.location</code> 设置为一个URL 值，也会以该值调用 <code>assign()</code>方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.wrox.com"</span>;</span><br><span class="line">location.href = <span class="string">"http://www.wrox.com"</span>;</span><br></pre></td></tr></table></figure></p><h5 id="hash-、search、hostname、pathname、port-属性"><a href="#hash-、search、hostname、pathname、port-属性" class="headerlink" title="hash 、search、hostname、pathname、port 属性"></a>hash 、search、hostname、pathname、port 属性</h5><p>修改location 对象的属性也可以改变当前加载的页面，浏览器的历史记录中会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设初始URL 为http://www.wrox.com/WileyCDA/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/#section1"</span></span><br><span class="line">location.hash = <span class="string">"#section1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"</span></span><br><span class="line">location.search = <span class="string">"?q=javascript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/WileyCDA/"</span></span><br><span class="line">location.hostname = <span class="string">"www.yahoo.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com/mydir/"</span></span><br><span class="line">location.pathname = <span class="string">"mydir"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将URL 修改为"http://www.yahoo.com:8080/WileyCDA/"</span></span><br><span class="line">location.port = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure></p><p>每次修改location 的属性（hash 除外），页面都会以新URL 重新加载。</p><blockquote><p>在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome 中，修改hash 的值会在浏览器的历史记录中生成一条新记录。在IE 的早期版本中，hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash 的URL 时才会被更新。</p></blockquote><h5 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h5><ul><li>只接受一个参数，即要导航到的URL；</li><li>不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面。</li></ul><h5 id="reload-方法"><a href="#reload-方法" class="headerlink" title="reload() 方法"></a>reload() 方法</h5><p>重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location.reload(); <span class="comment">//重新加载（有可能从缓存中加载）</span></span><br><span class="line"></span><br><span class="line">location.reload(<span class="literal">true</span>); <span class="comment">//重新加载（从服务器重新加载）</span></span><br></pre></td></tr></table></figure></p><p>位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。</p><p><br><br><br><br><br></p><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象：识别客户端浏览器的事实标准。</p><p><br></p><h4 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h4><p>检测浏览器中是否安装了特定的插件：</p><ul><li><p>对于 <strong>非IE浏览器</strong>：<br>使用 <strong><code>plugins</code></strong> 数组，该数组中每一项都包含下列属性：</p><ol><li><strong>name</strong> ：插件的名字；</li><li><strong>description</strong>：插件的描述；</li><li><strong>filename</strong>：插件的文件名；</li><li><strong>length</strong>：插件所处理的 MIME 类型数量。</li></ol></li></ul><blockquote><p>一般来说，name 属性中会包含检测插件必需的所有信息，但有时候也不完全如此。</p></blockquote><pre><code>在检测插件时，需要像下面这样循环迭代每个插件并将插件的name 与给定的名字进行比较：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测插件（在IE 中无效）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = name.toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; navigator.plugins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasPlugin(<span class="string">"Flash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasPlugin(<span class="string">"QuickTime"</span>));</span><br></pre></td></tr></table></figure><ul><li>对于 <strong>IE浏览器</strong>：<br>在IE 中检测插件的唯一方式就是使用专有的 <strong>ActiveXObject</strong> 类型，并<strong>尝试创建一个特定插件的实例</strong>。IE 是以 COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其 <strong>COM标识符</strong>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测IE 中的插件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>));</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>));</span><br></pre></td></tr></table></figure></li></ul><p>典型的做法是 <u>针对每个插件分别创建检测函数</u>，而不是使用前面介绍的通用检测方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测所有浏览器中的Flash</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasFlash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"Flash"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasIEPlugin(<span class="string">"ShockwaveFlash.ShockwaveFlash"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测所有浏览器中的QuickTime</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasQuickTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = hasPlugin(<span class="string">"QuickTime"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasIEPlugin(<span class="string">"QuickTime.QuickTime"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测Flash</span></span><br><span class="line">alert(hasFlash());</span><br><span class="line"><span class="comment">//检测QuickTime</span></span><br><span class="line">alert(hasQuickTime());</span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h4><p>Firefox 2 为navigator 对象新增了 <strong>registerContentHandler()</strong> 和 <strong>registerProtocolHandler()</strong> 方法（这两个方法是在HTML5 中定义的）。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着RSS 阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。</p><p><br><br><br><br><br></p><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。</p><p><br><br><br><br><br></p><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>history 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history 是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history 对象与特定的window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进。</p><p>使用 <strong>go()</strong> 方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个<strong>整数值</strong>。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。也可以给go()方法传递一个<strong>字符串参数</strong>，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做。</p><p>另外，还可以使用两个简写方法 <strong>back()</strong> 和 <strong>forward()</strong> 来代替go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。</p><p>history 对象还有一个 <strong>length 属性</strong>，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length 等于0。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;BOM&lt;/strong&gt; = browser Object Model 浏览器对象模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。其中，&lt;strong&gt;浏览器
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript 函数表达式</title>
    <link href="http://fujiafeng.com/2020/01/05/JavaScript-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://fujiafeng.com/2020/01/05/JavaScript-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-01-05T14:12:00.000Z</published>
    <updated>2020-01-05T14:23:27.935Z</updated>
    
    <content type="html"><![CDATA[<p>定义函数的方式：<br>（1）函数声明：函数声明提升；<br>（2）函数表达式：创建的函数是 匿名函数，在使用前必须先赋值。</p><blockquote><p><strong>函数声明提升</strong>（function declaration hoisting）：在执行代码之前会先读取函数声明。<br>&emsp;&emsp;<strong>匿名函数</strong>（anonymous function）：匿名函数的 name 属性是空字符串。</p></blockquote><p><br><br><br><br><br></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数：一个函数通过 <strong>名字</strong> 调用自身。<br><strong><code>arguments.callee</code></strong>  是一个 <strong>指向正在执行的函数的指针</strong>，因此可以用它来实现对函数的递归调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但在严格模式下，不能通过脚本访问 <code>arguments.callee</code>，访问这个属性会导致错误。不过，可以使用 <strong>命名函数表达式</strong> 来达成相同的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以上代码创建了一个名为 <code>f()</code> 的命名函数表达式，然后将它赋值给变量 <code>factorial</code>。<strong>即便把函数赋值给了另一个变量，函数的名字f 仍然有效。</strong></p><p><br><br><br><br><br></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p><strong>闭包</strong>：有权访问 <strong>另一个函数 作用域中的变量</strong> 的函数。<br><strong>创建闭包</strong> 的常见方式：在一个函数内部 创建另一个函数。</p><p>闭包会携带包含它的函数的作用域，因此比其他函数 <strong>占用更多内存</strong>，可通过<strong>赋值 null</strong> 来解除对匿名函数的引用，以便释放内存（JS垃圾回收机制）。</p><p><strong>闭包的作用</strong>：（1）模仿块级作用域；（2）在对象中创建私有变量。</p></blockquote><p><strong>ABOUT 函数调用：</strong></p><blockquote><p>当某个<strong>函数被调用</strong>时：<br>（1）会创建一个 <strong>执行环境</strong>（execution context）及相应的 <strong>作用域链</strong>。<br>（2）使用 <u>arguments 和 其他命名参数的值</u> 来 <strong>初始化</strong> 函数的 <strong>活动对象</strong>（activation object）。</p><p> <em>注意</em>：在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为 <strong>作用域链终点</strong> 的 <strong>全局执行环境</strong>。</p></blockquote><p><strong>ABOUT 执行环境：</strong></p><blockquote><p>后台的每个 <strong>执行环境</strong> 都有一个表示变量的对象——<strong>变量对象</strong>。</p><ul><li><strong>全局环境</strong> 的变量对象 <u>始终存在</u>。</li><li><strong>局部环境</strong> 的变量对象，则只在 <u>函数执行的过程中</u> 存在。</li></ul></blockquote><p><strong>ABOUT 作用域链：</strong></p><blockquote><ul><li><strong>作用域链</strong> 本质上是一个 <strong>指向变量对象的指针列表</strong>，它 <strong>只引用</strong> 但不实际包含变量对象。</li><li>无论什么时候在函数中访问一个变量时，就会 <u>从作用域链中</u> 搜索具有相应名字的变量。</li><li>一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。</li><li><strong>在另一个函数内部定义的函数（闭包）</strong> 会将包含函数（即外部函数）的活动对象添加到它的作用域链中。包含函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象（<em><u>换句话说，包含函数执行完毕后，其执行环境的<strong>作用域链会被销毁</strong>，但其 <strong>活动对象仍被保留在内存</strong>中，直到匿名函数被销毁</u></em>）。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数（闭包）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建函数</span></span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">var</span> result = compareNames(&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">"Greg"</span> &#125;);</span><br><span class="line"><span class="comment">//解除对匿名函数的引用（以便释放内存）</span></span><br><span class="line">compareNames = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><img src="/2020/01/05/JavaScript-函数表达式/闭包.png" title="JavaScript闭包"><p><br></p><h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><p>作用域链 <strong>引发的问题</strong>：闭包只能取得 包含函数中任何变量的 <strong>最后一个值</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数会返回一个函数数组，每个函数都返回10。</p><blockquote><p>原因分析：因为每个函数的作用域链中都保存着createFunctions() 函数的活动对象， 所以它们引用的都是同一个变量i 。当createFunctions()函数返回后，变量i 的值是10，此时每个函数都引用着保存变量i 的同一个变量对象，所以在每个函数内部i 的值都是10。</p></blockquote><p>我们可以通过 <strong>创建另一个匿名函数</strong> 强制让闭包的行为符合预期：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述函数返回的函数数组中，每个函数会返回 各自不同的索引值。</p><blockquote><p>原因分析：在这个版本中，我们 <strong>没有直接把闭包赋值给数组</strong>，而是<br>（1）定义了一个<strong>匿名函数</strong>，并将 <strong>立即执行该匿名函数的结果</strong> 赋给数组。<br>（2）匿名函数有一个 <strong>参数num</strong>，也就是最终的函数要返回的值。<br>（3）在调用每个匿名函数时，我们传入了 <strong>变量i</strong>。<br>（4）由于 <strong>函数参数</strong> 是 <strong>按值传递</strong> 的，所以就会 <strong>将变量i 的当前值复制给参数num</strong>。<br>（5）而在这个<strong>匿名函数内部</strong>，又创建并返回了一个<strong>访问num 的闭包</strong>。</p><p>这样一来，result 数组中的每个函数 <u>都有自己num 变量的一个副本</u> ，因此就可以返回各自不同的数值了。</p></blockquote><p><br></p><h4 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h4><p>在闭包中使用 this对象 可能引发的问题：<br><strong>匿名函数</strong> 的<strong>执行环境具有全局性</strong>，其 this对象通常指向 <strong>window</strong>。</p><blockquote><p>this 对象是在运行时基于函数的执行环境绑定的：</p><ul><li>在全局函数中，this 等于window；</li><li>当函数被作为某个对象的方法调用时，this 等于那个对象。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下）</span></span><br></pre></td></tr></table></figure><p>为什么匿名函数没有取得其包含作用域（或外部作用域）的this 对象呢？<br>每个函数在被调用时都会自动取得两个特殊变量：<code>this</code> 和 <code>arguments</code> 。内部函数在搜索这两个变量时，只会搜索到其<strong>活动对象</strong>为止。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"My Object"</span></span><br></pre></td></tr></table></figure></p><p>在定义匿名函数之前，我们把 this对象 赋值给了一个名叫 <code>that</code> 的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。</p><p><br></p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>在低版本IE（<ie9）中，如果 闭包的作用域链中 保存着一个html 元素，那么就意味着该元素将无法被销毁。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(element.id);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></ie9）中，如果></p><p>以上代码创建了一个作为element 元素事件处理程序的闭包，而这个闭包则又创建了一个 <strong>循环引用</strong>。element 的引用数至少为1，因此它所占用的内存永远不会被回收。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id; <span class="comment">// 消除循环引用</span></span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 闭包会引用 包含函数的整个活动对象，其中包含element</span></span><br><span class="line">    element = <span class="literal">null</span>; <span class="comment">// 消除对 DOM对象的引用，以减少其引用数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><blockquote><ul><li>JavaScript 没有块级作用域；</li><li>JavaScript 中，多次声明了同一个变量，js会对后续的声明视而不见，但是会执行后续声明中的变量初始化。</li></ul></blockquote><p><strong>匿名函数</strong> 可以用来 <strong>模仿块级作用域</strong> 并 <strong>避免多次声明同一变量</strong>。<br>用作块级作用域（通常称为<strong>私有作用域</strong>）的匿名函数的语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p><strong>将函数声明包含在一对圆括号中，表示它实际上是一个<u>函数表达式</u>。而紧随其后的另一对圆括号会<u>立即调用</u>这个函数。</strong> </p><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    alert(i); <span class="comment">//导致一个错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在匿名函数中定义的任何变量，都会在执行结束时被销毁。</p><blockquote><p>这种技术经常 在全局作用域中被用在函数外部，从而 <strong>限制向全局作用域中添加过多的变量和函数</strong>。<br>这种做法可以 <strong>减少闭包占用的内存问题</strong>，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。</p></blockquote><p><br><br><br><br><br></p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><blockquote><p><strong>私有变量</strong>：任何在函数中定义的变量，包括 <u>函数参数</u>、<u>局部变量</u>、<u>在函数内部定义的其他函数</u>。（不能在函数外部访问这些变量）<br><strong>特权方法</strong>（privileged method）：有权访问私有变量和私有函数的公有方法。</p><p>在对象上 <strong>创建特权方法</strong> 的方式：<br>（1）在构造函数中定义特权方法；<br>（2）静态私有变量。</p></blockquote><p>在构造函数中定义特权方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缺点：必须使用 <u><em>构造函数模式</em></u> 来达到这个目的。<br><strong>构造函数模式</strong> 的缺点：针对每个实例都会创建同样一组新方法。<br>使用 <em>静态私有变量</em> 来实现特权方法可以避免这个问题。</p><p><br></p><h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><blockquote><p><strong>静态私有变量</strong>：在 <u><strong>私有作用域</strong></u> 中定义私有变量或函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p></blockquote><p>在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。<br><u>注意点</u>：</p><ol><li>这个模式在定义构造函数时并没有使用函数声明，而是使用了 <strong>函数表达式</strong>；</li><li>定义构造函数时，没有使用 <code>var</code> 关键字。</li></ol><blockquote><p>（1）函数声明只能创建 局部函数；<br>（2）初始化未经声明的变量，总是会创建一个 全局变量；但在严格模式下，给未经声明的变量赋值会导致错误。</p></blockquote><p>这个模式 与 在构造函数中定义特权方法 的<strong>主要区别</strong>，就在于 私<u><strong>有变量和函数是由实例共享的</strong></u>。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。</p><p><br></p><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><blockquote><p><strong>模块模式</strong>（module pattern）：为 单例 创建私有变量和特权方法。<br><strong>单例</strong>（singleton）：只有一个实例的对象。</p><p>按照惯例，JavaScript 是以 <strong>对象字面量</strong> 的方式来创建单例对象的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>这个模块模式使用了一个 <u>返回对象的匿名函数</u>。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。</p><p>简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 <strong>Object 的实例</strong>，因为最终要<u>通过一个对象字面量来表示</u>它。</p><p><br></p><h4 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h4><blockquote><p> 增强的模块模式 适合：<br>（1）单例必须是 <strong>某种类型的实例</strong>；<br>（2）必须 <strong>添加</strong> 某些 <strong>属性或方法</strong> 对其加以增强。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">    <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">    object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><blockquote><p>实现<strong>自定义类型</strong>的特权方法：（1）构造函数模式；（2）原型模式。<br>实现<strong>单例</strong>的特权方法：（1）模块模式；（2）增强的模块模式。</p></blockquote><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定义函数的方式：&lt;br&gt;（1）函数声明：函数声明提升；&lt;br&gt;（2）函数表达式：创建的函数是 匿名函数，在使用前必须先赋值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;函数声明提升&lt;/strong&gt;（function declaration hoisting）
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 字符串的扩展</title>
    <link href="http://fujiafeng.com/2020/01/05/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://fujiafeng.com/2020/01/05/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</id>
    <published>2020-01-05T13:07:48.000Z</published>
    <updated>2020-01-05T13:30:53.499Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><p><br></p><h3 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h3><p>JavaScript 共有 6 种方法可以<strong>表示一个字符</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>ES6 加强了对 Unicode 的支持，允许采用 <code>\uxxxx</code> 形式表示一个字符，其中 <code>xxxx</code>表示字符的 <strong>Unicode 码点</strong>。</p><p>但是，这种表示法只限于码点在 <code>\u0000</code> ~ <code>\uFFFF</code> 之间的字符。超出这个范围的字符，必须用 <strong>两个双字节</strong> 的形式表示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br><span class="line"><span class="comment">// 如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</span></span><br></pre></td></tr></table></figure></p><p>ES6 对这一点做出了改进，只要 <strong>将码点放入大括号</strong>，就能正确解读该字符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span></span><br><span class="line"><span class="comment">// "ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;<span class="number">6</span>F&#125; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;1F680&#125;'</span> === <span class="string">'\uD83D\uDE80'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，最后一个例子表明，<strong>大括号表示法与四字节的 UTF-16 编码是等价</strong>的。</p><p><br><br><br><br><br></p><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>ES6 为字符串添加了遍历器接口，使得字符串可以被 <strong><code>for...of</code> 循环遍历</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "f"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br></pre></td></tr></table></figure></p><p>除了遍历字符串，这个遍历器最大的优点是 <strong>可以识别大于0xFFFF的码点</strong>，传统的for循环无法识别这样的码点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);&#125;</span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，字符串text只有一个字符，但是 <code>for</code> 循环会认为它包含两个字符（都不可打印），而 <code>for...of</code> 循环会正确识别出这一个字符。</p><p><br><br><br><br><br></p><h3 id="直接输入-U-2028-和-U-2029"><a href="#直接输入-U-2028-和-U-2029" class="headerlink" title="直接输入 U+2028 和 U+2029"></a>直接输入 U+2028 和 U+2029</h3><p>JavaScript 字符串允许 <strong>直接输入字符</strong>，以及 <strong>输入字符的转义形式</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'中'</span> === <span class="string">'\u4e2d'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，<strong>只能</strong> 使用 <strong>转义形式</strong>：</p><ol><li><strong>U+005C</strong>：反斜杠（reverse solidus)</li><li><strong>U+000D</strong>：回车（carriage return）</li><li><strong>U+2028</strong>：行分隔符（line separator）</li><li><strong>U+2029</strong>：段分隔符（paragraph separator）</li><li><strong>U+000A</strong>：换行符（line feed）</li></ol><blockquote><p><strong>JSON 格式</strong> 允许字符串里面 <strong>直接使用</strong> U+2028（行分隔符）和 U+2029（段分隔符）。</p></blockquote><p>服务器输出的 JSON 被 <code>JSON.parse</code> 解析，就有可能直接报错。</p><p><br><br><br><br><br></p><h3 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h3><p>根据标准，JSON 数据必须是 UTF-8 编码。</p><blockquote><p>UTF-8 标准规定，<strong><code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点，不能单独使用，必须配对使用</strong> 。比如，<code>\uD834\uDF06</code>是两个码点，但是必须放在一起配对使用，代表字符 𝌆。这是为了表示码点大于 <code>0xFFFF</code> 的字符的一种变通方法。单独使用 <code>\uD834</code> 和 <code>\uDFO6</code> 这两个码点是不合法的，或者颠倒顺序也不行，因为<code>\uDF06\uD834</code>并没有对应的字符。</p></blockquote><p><code>JSON.stringify()</code> 的问题在于，它可能返回 <code>0xD800</code> 到 <code>0xDFFF</code> 之间的单个码点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// "\u&#123;D834&#125;"</span></span><br></pre></td></tr></table></figure></p><p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>) <span class="comment">// ""\\uD834""</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\uDF06\uD834'</span>) <span class="comment">// ""\\udf06\\ud834""</span></span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><blockquote><p><strong>模板字符串</strong>（template string）是增强版的字符串，用 <strong>反引号（`）</strong> 标识。它可以当作普通字符串使用，也可以用来定义 <strong>多行字符串</strong>，或者 <strong>在字符串中嵌入变量</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure></p><p>如果使用模板字符串表示多行字符串，<strong>所有的 空格 和 缩进 都会被保留</strong>在输出之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure></p><p>可以使用 <code>trim</code> 方法消除字符串首尾的空白字符（换行符、空格及连续空格、制表符tab）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#list&apos;).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure></p><p>模板字符串中 <strong>嵌入变量</strong>，需要将变量名写在 <code>${}</code> 之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="comment">// 传统写法为</span></span><br><span class="line">      <span class="comment">// 'User '</span></span><br><span class="line">      <span class="comment">// + user.name</span></span><br><span class="line">      <span class="comment">// + ' is not authorized to do '</span></span><br><span class="line">      <span class="comment">// + action</span></span><br><span class="line">      <span class="comment">// + '.'</span></span><br><span class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>大括号内部可以放入任意的 JavaScript 表达式，可以 <strong>进行运算</strong>，以及 <strong>引用对象属性</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "3"</span></span><br></pre></td></tr></table></figure></p><p>模板字符串之中还能 <strong>调用函数</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure></p><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。</p><p>模板字符串甚至还能嵌套：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法如下</span></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tmpl(data));</span><br><span class="line"><span class="comment">// &lt;table&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &lt;/table&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。</p><p><br><br><br><br><br></p><h3 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h3><p>（待补充）</p><p><br><br><br><br><br></p><h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>“标签模板”功能（tagged template）：“标签模板”可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`123`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert(<span class="number">123</span>)</span><br></pre></td></tr></table></figure></p><p>标签模板其实不是模板，而是 <strong>函数调用</strong> 的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 这是函数实际的调用方式</span></span><br></pre></td></tr></table></figure></p><p>函数tag依次会接收到多个参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。<code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure></p><p>passthru函数采用 rest 参数的写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += literals[index]</span><br><span class="line">  <span class="keyword">return</span> output;&#125;</span><br></pre></td></tr></table></figure></p><p>“标签模板”的重要应用：</p><p>（1） <strong>过滤 HTML 字符串，防止用户输入恶意内容</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。</span></span><br><span class="line"><span class="keyword">let</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p><p>（2）多语言转换（国际化处理）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// "欢迎访问xxx，您是第xxxx位访问者！"</span></span><br></pre></td></tr></table></figure></p><p>（3）模拟 Mustache 之类的模板库（添加条件判断、循环处理等功能）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></p><p>（4）在 JavaScript 语言之中嵌入其他语言<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jsx<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      ref='input'</span></span><br><span class="line"><span class="string">      onChange='<span class="subst">$&#123;<span class="keyword">this</span>.handleChange&#125;</span>'</span></span><br><span class="line"><span class="string">      defaultValue='<span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span>' /&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">   &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>上面的代码通过 <code>jsx</code> 函数，<u>将一个 <strong>DOM 字符串</strong>转为 <strong>React 对象</strong></u>。</p><p>模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存转义后的原字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// strings.raw[0] 为 "First line\\nSecond line"</span></span><br><span class="line">  <span class="comment">// 打印输出 "First line\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[“First line\nSecond line”]，那么strings.raw数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符的-Unico
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - 变量的解构赋值</title>
    <link href="http://fujiafeng.com/2019/11/21/ES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://fujiafeng.com/2019/11/21/ES6-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</id>
    <published>2019-11-21T15:23:18.000Z</published>
    <updated>2019-11-21T15:37:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><blockquote><p><strong>解构</strong>（Destructuring）：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p></blockquote><p><br></p><blockquote><p><strong>常见用途</strong>：<br>（1）交换变量的值；<br>（2）从函数返回多个值；<br>（3）函数参数的定义；<br>（4）提取 JSON 数据；<br>（5）函数参数的默认值；<br>（6）遍历 Map 结构；<br>（7）输入模块的指定方法。</p></blockquote><p><br></p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>本质上，这种写法属于“<strong>模式匹配</strong>”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p><p>另一种情况是 <strong>不完全解构</strong>，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>对于 <strong>Set 结构</strong>，也可以使用数组的解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure></p><p>事实上，只要某种数据结构具有 <strong>Iterator 接口</strong>，都可以采用数组形式的解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><p><br></p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p><p>只有当一个数组成员<strong>严格等于undefined</strong>，默认值才会生效。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码等价于</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。</p></blockquote><p><br><br><br></p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>对象的解构与数组有一个重要的不同。数组的元素是 <strong>按次序排列</strong> 的，变量的取值由它的位置决定；而对象的属性<strong>没有次序</strong>，<strong>变量必须与属性同名</strong>，才能取到正确的值。</p><p>如果解构失败，变量的值等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p><strong>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;log(<span class="string">'hello'</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></p><p>上面代码的例一将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将console.log赋值到log变量。</p><p>对象的解构赋值是下面形式的简写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br></pre></td></tr></table></figure></p><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><p>与数组一样，解构也可以用于 嵌套结构的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure></p><p>解构赋值中，<code>：</code>前边的 loc、start 都是模式，不是变量。</p><p>注意，对象的解构赋值可以取到继承的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，对象obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性。</p><p><br></p><h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><p>默认值生效的条件是，对象的属性值严格等于undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p><br></p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>（1）<u>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</u><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure></p><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。</p><p>（2）<u>解构赋值允许等号左边的模式之中，不放置任何变量名。</u>因此，可以写出非常古怪的赋值表达式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br><span class="line"><span class="comment">// 以上表达式毫无意义，但语法合法</span></span><br></pre></td></tr></table></figure></p><p>（3）<u>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</u><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“<strong>属性名表达式</strong>”。（对象的扩展）</p><p><br><br><br></p><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个 <strong>类似数组的对象</strong>。</p><p>类似数组的对象都有一个 <strong>length属性</strong>，因此还可以对这个属性解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><blockquote><p><strong>解构赋值的规则</strong>：只要等号右边的值不是对象或数组，就先将其转为对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p><p>由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p><p><br><br><br></p><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure></p><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是 <code>x</code> 和 <code>y</code> 。</p><p>函数参数的解构也可以使用默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></p><p>undefined就会触发函数参数的默认值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><blockquote><p>ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>建议只要有可能，就不要在模式中放置圆括号。</p></blockquote><h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><ol><li><p>变量声明语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;<span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;<span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;<span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure></li><li><p>函数参数（属于变量声明）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure></li><li><p>赋值语句的模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p><strong><u>赋值语句</u> 的 <u>非模式部分</u></strong>，可以使用圆括号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>（1）<strong>交换变量的值</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></p><p>（2）<strong>从函数返回多个值</strong><br>函数只能返回一个值，如果要返回多个值，只能将它们放在 <strong>数组</strong> 或 <strong>对象</strong> 里返回。有了解构赋值，取出这些值就非常方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></p><p>（3）<strong>函数参数的定义</strong><br>解构赋值可以方便地将 <strong>一组参数</strong> 与 <strong>变量名</strong> 对应起来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>（4）<strong>提取 JSON 数据</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure></p><p>（5）<strong>函数参数的默认值</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>指定参数的默认值，就避免了在函数体内部再写 <code>var foo = config.foo || &#39;default foo&#39;;</code> 这样的语句。</p><p>（6）<strong>遍历 Map 结构</strong><br>任何部署了 Iterator 接口的对象，都可以用 <code>for...of</code> 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，<strong>获取键名和键值</strong> 就非常方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（7）<strong>输入模块的指定方法</strong><br>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;解构&lt;/s
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - let和const命令</title>
    <link href="http://fujiafeng.com/2019/11/21/ES6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>http://fujiafeng.com/2019/11/21/ES6-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</id>
    <published>2019-11-21T15:07:06.000Z</published>
    <updated>2019-11-21T15:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅为学习笔记，详情请见<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰《ECMAScript 入门》</a></p><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><ul><li><code>let</code>声明的变量只在它所在的代码块有效；</li><li><code>for</code>循环 的计数器，适合使用 <code>let</code>命令（设置循环变量的那部分是 父作用域，循环体内部 是一个单独的自作用域）；</li><li><code>let</code> 命令<strong>不存在变量提升</strong>；</li><li><strong>暂时性死区</strong>（TDZ=temporal dead zone）：在代码块内，使用 <code>let</code>声明变量之前，该变量不可用；</li><li>暂时性死区 意味着 <code>typeof</code> 不再是一个百分之百安全的操作（作为比较，如果一个变量根本没有被声明，使用 <code>typeof</code> 反而不会报错）</li><li><code>let</code> <strong>不允许</strong>在相同作用域内，<strong>重复声明</strong>同一变量（不能在函数内部重新声明参数）；</li></ul><p><br><br><br></p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这会导致：</p><ol><li>内层变量可能会覆盖外层变量（变量提升）；</li><li>用来计数的循环变量泄露为全局变量。</li></ol><p><br></p><p>ES6块级作用域</p><p>let实际上为 JavaScript 新增了块级作用域。</p><p>ES6 允许块级作用域的任意嵌套。</p><p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...&#125;());</span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...&#125;</span><br></pre></td></tr></table></figure></p><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要， <strong>块级作用域内部，优先使用函数表达式</strong> 。</p><p><br><br><br></p><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ul><li>const声明 <strong>只读常量</strong>；</li><li>const一旦声明变量，就必须 <strong>立即初始化</strong>，不能留到以后赋值；</li><li>只在声明所在的 <strong>块级作用域</strong> 内有效；</li><li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用；</li><li>不可重复声明。</li></ul><blockquote><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>如果真的想将对象冻结，应该使用Object.freeze方法。</p><p><code>const foo = Object.freeze({});</code></p></blockquote><p><br><br><br></p><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><ul><li>var 命令</li><li>function 命令</li><li>let 命令</li><li>const 命令</li><li>import 命令</li><li>class 命令</li></ul><p>ES5 只有两种声明变量的方法：var命令和function命令。</p><p><br><br><br></p><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><blockquote><p><strong>顶层对象</strong>，在浏览器环境指的是<strong>window对象</strong>，在 Node 指的是<strong>global对象</strong>。</p></blockquote><p>ES5 之中，顶层对象的属性与全局变量是等价的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>这导致了几个问题：</p><ol><li>没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；</li><li>程序员很容易不知不觉地就创建了全局变量（比如打字出错）；</li><li>顶层对象的属性是到处可以读写的，这非常不利于模块化编程。</li></ol><p>从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩：</p><ol><li>为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；</li><li>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h3><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p><ul><li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window；</li><li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self；</li><li>Node 里面，顶层对象是global，但其他环境都不支持。</li></ul><p>同一段代码为了能够在各种环境，都能<strong>取到顶层对象</strong>，现在一般是使用 <strong>this变量</strong>，但是有局限性：</p><ul><li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块；</li><li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined；</li><li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。</li></ul><p>暂时可用的解决方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);&#125;;</span><br></pre></td></tr></table></figure></p><p>现在有一个提案，在语言标准的层面，<u>引入 <strong>globalThis</strong> 作为 <strong>顶层对象</strong></u>。</p><p>也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</p><p><strong>垫片库global-this</strong> 模拟了这个提案，可以在所有环境拿到globalThis。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅为学习笔记，详情请见&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰《ECMAScript 入门》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命
      
    
    </summary>
    
    
    
      <category term="ECMAScript" scheme="http://fujiafeng.com/tags/ECMAScript/"/>
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>大约在冬季</title>
    <link href="http://fujiafeng.com/2019/11/20/%E5%A4%A7%E7%BA%A6%E5%9C%A8%E5%86%AC%E5%AD%A3/"/>
    <id>http://fujiafeng.com/2019/11/20/%E5%A4%A7%E7%BA%A6%E5%9C%A8%E5%86%AC%E5%AD%A3/</id>
    <published>2019-11-19T16:00:06.000Z</published>
    <updated>2019-11-19T14:40:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>-26-</p><p>感谢爱过的人和事</p><p>经历过的美好瞬间</p><p>让我无惧年龄的增长</p><p>‴ Be soft, be powerful </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;-26-&lt;/p&gt;
&lt;p&gt;感谢爱过的人和事&lt;/p&gt;
&lt;p&gt;经历过的美好瞬间&lt;/p&gt;
&lt;p&gt;让我无惧年龄的增长&lt;/p&gt;
&lt;p&gt;‴ Be soft, be powerful &lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>侧耳倾听 Vol.5</title>
    <link href="http://fujiafeng.com/2019/11/07/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-5/"/>
    <id>http://fujiafeng.com/2019/11/07/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-5/</id>
    <published>2019-11-07T15:38:26.000Z</published>
    <updated>2019-11-19T14:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>#抄句子#</em></p><blockquote><p>「我所有的自負皆來自我的自卑；<br>&emsp;&emsp;&emsp;所有的英雄氣概都來自於我的軟弱。<br>&emsp;&emsp;&emsp;嘴裡振振有詞是因為心裡滿是懷疑，<br>&emsp;&emsp;&emsp;深情是因為痛恨自己無情。<br>&emsp;&emsp;&emsp;這世界沒有一件事情是虛空而生的，<br>&emsp;&emsp;&emsp;站在光里，背後就會有陰影；<br>&emsp;&emsp;&emsp;這深夜裡一片寂靜，<br>&emsp;&emsp;&emsp;是因為你還沒有聽見聲音。」<br>&emsp;&emsp;&emsp;—— 馬良 《坦白書》</p></blockquote><p><br></p><blockquote><p>「世界要妳努力考取功名<br>&emsp;&emsp;&emsp;但真誠才是最大的本領」</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;#抄句子#&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「我所有的自負皆來自我的自卑；&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;所有的英雄氣概都來自於我的軟弱。&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;嘴裡振振有詞是因為心裡滿是懷疑，&lt;br&gt;&amp;emsp;&amp;
      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="侧耳倾听" scheme="http://fujiafeng.com/tags/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC/"/>
    
  </entry>
  
  <entry>
    <title>【大数据组件】YARN简介</title>
    <link href="http://fujiafeng.com/2019/10/24/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E3%80%91YARN%E7%AE%80%E4%BB%8B/"/>
    <id>http://fujiafeng.com/2019/10/24/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E3%80%91YARN%E7%AE%80%E4%BB%8B/</id>
    <published>2019-10-24T15:33:53.000Z</published>
    <updated>2019-10-24T15:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Apache YARN</strong> ( Yet Another Resource Negotiator ) 是 hadoop 2.0 引入的 <strong>集群资源管理系统</strong> 。用户可以将各种服务框架部署在 YARN 上，由 YARN 进行统一地管理和资源分配。<br></p><p><br></p><h2 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h2><p>YARN 的基本思想是：</p><p>将 MapReduce 1 中的 JobTracker的 <strong>资源管理</strong> 和 <strong>作业调度</strong> 两个功能分开，分别由 <strong>ResourceManager</strong> 和 <strong>ApplicationMaster</strong> 进程来实现。</p><p>YARN 支持多种计算框架 运行在一个集群当中，比如 MapReduce（批处理）、Strom（在线处理）、Spark、Flink 等。</p><p>下图展示了 YARN 资源调度的流程：<br><img src="/2019/10/24/【大数据组件】YARN简介/yarn资源调度流程.png" title="yarn资源调度流程"></p><ul><li><strong>ResourceManager</strong> ：<strong>全局</strong>，负责整个集群的资源管理和调度；</li><li><strong>ApplicationMaster</strong> ：每个 job 有一个 ApplicationMaster，负责应用程序相关的事务，比如 任务调度、任务监控和容错等；</li><li><strong>NodeManager</strong> ：客户端框架，负责containers，监控他们的 资源使用（CPU、内存、磁盘、网络）并上报给 ResourceManager.</li></ul><hr><p><br></p><h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p><code>ResourceManager</code> 通常在独立的机器上以后台进程的形式运行，它是整个集群资源的主要协调者和管理者。</p><p><code>ResourceManager</code> 负责给用户提交的所有应用程序分配资源，它根据应用程序优先级、队列容量、ACLs、数据位置等信息，做出决策，然后以共享的、安全的、多租户的方式制定分配策略，调度集群资源。</p><p><strong>主要功能</strong>：</p><ol><li>与客户端交互，处理来自客户端的请求；</li><li>启动和管理 ApplicationMaster，并在它失败时 进行重启；</li><li>管理 NodeManager，接受来自 NM的资源汇报信息，下达管理指令；</li><li>资源调度和管理，接受 来自 AM的资源申请请求，并让 NM为之分配资源。</li></ol><p><br></p><h3 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h3><p><code>NodeManager</code> 是 YARN 集群中的单个计算节点的管理者。主要负责该节点内所有容器Container 的生命周期的管理，监视资源和跟踪节点健康。具体如下：</p><ul><li>启动时向 <code>ResourceManager</code> 注册并定时发送心跳消息，等待 <code>ResourceManager</code> 的指令；</li><li>维护 <code>Container</code> 的生命周期，监控 <code>Container</code> 的资源使用情况；</li><li>管理任务运行时的相关依赖，根据 <code>ApplicationMaster</code> 的需要，在启动 <code>Container</code> 之前将需要的程序及其依赖拷贝到本地。</li></ul><p><br></p><h3 id="ApplicationMaster"><a href="#ApplicationMaster" class="headerlink" title="ApplicationMaster"></a>ApplicationMaster</h3><p>在用户提交一个应用程序时，YARN 会启动一个轻量级的进程 <code>ApplicationMaster</code>。<code>ApplicationMaster</code> 负责协调来自 <code>ResourceManager</code> 的资源，并通过 <code>NodeManager</code> 监视容器内资源的使用情况，同时还负责任务的监控与容错。具体如下：</p><ul><li>根据应用的运行状态来决定动态计算资源需求；</li><li>向 <code>ResourceManager</code> 申请资源，监控申请的资源的使用情况；</li><li>跟踪任务状态和进度，报告资源的使用情况和应用的进度信息；</li><li>负责任务的容错。</li></ul><p><br></p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><code>Container</code> 是 YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等。当 AM 向 RM 申请资源时，RM 为 AM 返回的资源是用 <code>Container</code> 表示的。YARN 会为每个任务分配一个 <code>Container</code>，该任务只能使用该 <code>Container</code> 中描述的资源。<code>ApplicationMaster</code> 可在 <code>Container</code> 内运行任何类型的任务。例如，<code>MapReduce ApplicationMaster</code> 请求一个容器来启动 map 或 reduce 任务，而 <code>Giraph ApplicationMaster</code> 请求一个容器来运行 Giraph 任务。</p><p><br><br><br><br><br></p><h2 id="YARN工作原理简述"><a href="#YARN工作原理简述" class="headerlink" title="YARN工作原理简述"></a>YARN工作原理简述</h2><img src="/2019/10/24/【大数据组件】YARN简介/yarn工作原理简述.png" title="yarn工作原理简述"><ol><li><code>Client</code> 提交作业到 YARN 上；</li><li><code>Resource Manager</code> 选择一个 <code>Node Manager</code>，启动一个 <code>Container</code> 并运行 <code>Application Master</code> 实例；</li><li><code>Application Master</code> 根据实际需要向 <code>Resource Manager</code> 请求更多的 <code>Container</code> 资源（如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务）；</li><li><code>Application Master</code> 通过获取到的 <code>Container</code> 资源执行分布式计算。</li></ol><p><br><br><br><br><br></p><h2 id="YARN工作原理详述"><a href="#YARN工作原理详述" class="headerlink" title="YARN工作原理详述"></a>YARN工作原理详述</h2><img src="/2019/10/24/【大数据组件】YARN简介/yarn工作原理详述.png" title="yarn工作原理详述"><ol><li><strong>作业提交</strong></li></ol><p>client 调用 job.waitForCompletion 方法，向整个集群提交 MapReduce 作业 (第 1 步) 。新的作业 ID(应用 ID) 由资源管理器分配 (第 2 步)。作业的 client 核实作业的输出, 计算输入的 split, 将作业的资源 (包括 Jar 包，配置文件, split 信息) 拷贝给 HDFS(第 3 步)。 最后, 通过调用资源管理器的 submitApplication() 来提交作业 (第 4 步)。</p><ol><li><strong>作业初始化</strong></li></ol><p>当资源管理器收到 submitApplciation() 的请求时, 就将该请求发给调度器 (scheduler), 调度器分配 container, 然后资源管理器在该 container 内启动应用管理器进程, 由节点管理器监控 (第 5 步)。</p><p>MapReduce 作业的应用管理器是一个主类为 MRAppMaster 的 Java 应用，其通过创造一些 bookkeeping 对象来监控作业的进度, 得到任务的进度和完成报告 (第 6 步)。然后其通过分布式文件系统得到由客户端计算好的输入 split(第 7 步)，然后为每个输入 split 创建一个 map 任务, 根据 mapreduce.job.reduces 创建 reduce 任务对象。</p><ol><li><strong>任务分配</strong></li></ol><p>如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务。</p><p>如果不是小作业, 那么应用管理器向资源管理器请求 container 来运行所有的 map 和 reduce 任务 (第 8 步)。这些请求是通过心跳来传输的, 包括每个 map 任务的数据位置，比如存放输入 split 的主机名和机架 (rack)，调度器利用这些信息来调度任务，尽量将任务分配给存储数据的节点, 或者分配给和存放输入 split 的节点相同机架的节点。</p><ol><li><strong>任务运行</strong></li></ol><p>当一个任务由资源管理器的调度器分配给一个 container 后，应用管理器通过联系节点管理器来启动 container(第 9 步)。任务由一个主类为 YarnChild 的 Java 应用执行， 在运行任务之前首先本地化任务需要的资源，比如作业配置，JAR 文件, 以及分布式缓存的所有文件 (第 10 步。 最后, 运行 map 或 reduce 任务 (第 11 步)。</p><p>YarnChild 运行在一个专用的 JVM 中, 但是 YARN 不支持 JVM 重用。</p><ol><li><strong>进度和状态更新</strong></li></ol><p>YARN 中的任务将其进度和状态 (包括 counter) 返回给应用管理器, 客户端每秒 (通 mapreduce.client.progressmonitor.pollinterval 设置) 向应用管理器请求进度更新, 展示给用户。</p><ol><li><strong>作业完成</strong></li></ol><p>除了向应用管理器请求作业进度外, 客户端每 5 分钟都会通过调用 waitForCompletion() 来检查作业是否完成，时间间隔可以通过 mapreduce.client.completion.pollinterval 来设置。作业完成之后, 应用管理器和 container 会清理工作状态， OutputCommiter 的作业清理方法也会被调用。作业的信息会被作业历史服务器存储以备之后用户核查。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Apache YARN&lt;/strong&gt; ( Yet Another Resource Negotiator ) 是 hadoop 2.0 引入的 &lt;strong&gt;集群资源管理系统&lt;/strong&gt; 。用户可以将各种服务框架部署在 YARN 上，由 YARN
      
    
    </summary>
    
    
    
      <category term="大数据" scheme="http://fujiafeng.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>【大数据组件】HDFS简介</title>
    <link href="http://fujiafeng.com/2019/10/21/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E3%80%91HDFS%E7%AE%80%E4%BB%8B/"/>
    <id>http://fujiafeng.com/2019/10/21/%E3%80%90%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E3%80%91HDFS%E7%AE%80%E4%BB%8B/</id>
    <published>2019-10-21T14:49:48.000Z</published>
    <updated>2019-10-21T15:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>HDFS</strong> = Hadoop Distributed File System</p><p><strong>Hadoop 分布式文件系统</strong></p><p>分布式文件系统：统一管理 分布在集群上 的文件系统。</p></blockquote><p><br><br><br></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><h3 id="HDFS-优点与局限"><a href="#HDFS-优点与局限" class="headerlink" title="HDFS 优点与局限"></a>HDFS 优点与局限</h3><p>优点：</p><ol><li><strong>高度容错性</strong>，适合部署在 廉价的机器上；</li><li>提供 <strong>高吞吐量</strong> 的数据访问，适用于 <strong>大规模数据集（Large Data Set）</strong>；</li><li><strong>流式读取</strong> 文件系统数据，一次写入，多次读取，不能修改，只能追加。能保证数据的一致性。</li></ol><blockquote><p>注：大规模数据集，指 10^2 MB/GB/TB/PB 级别。</p></blockquote><p>局限：</p><ol><li>不支持 低延迟访问（毫秒级）；</li><li>不适合 大量的小文件存储；</li><li>不支持 并发写入；</li><li>不支持修改。</li></ol><p><br></p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p><strong>分而治之</strong> — 将大文件、大批量文件，分布式存放在大量服务器上，以便于采取 分而治之 的方式对海量数据进行分析运算。</p><p><br></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在 大数据系统 中，为各类分布式运算框架（如：MapReduce、spark、tez 等），提供 <strong>数据存储</strong> 服务。</p><p><br></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>一个分布式文件系统，用于存储文件，通过统一的 <u><strong>命名空间（目录树）</strong></u> 来定位文件。</p><p>HDFS是一个 <strong>主/从（Mater/Slave）体系结构</strong> ，HDFS集群拥有一个NameNode和一些DataNode。NameNode管理文件系统的元数据，DataNode存储实际的数据。</p><p>从用户角度看，HDFS 通过 <strong>目录路径</strong> 对文件执行 <strong>CRUD</strong> 操作（Create、Read、Update、Delete）。</p><hr><p><u><strong>HDFS客户端</strong></u>：就是客户端。<br>1、提供一些命令来管理、访问 HDFS，比如启动或者关闭HDFS。<br>2、与 DataNode 交互，读取或者写入数据；读取时，要与 NameNode 交互，获取文件的位置信息；写入 HDFS 的时候，Client 将文件切分成 一个一个的Block，然后进行存储。<br>3、文件切分。文件上传 HDFS 时，Client 将文件切分成一个个的 Block，然后进行存储。</p><p><u><strong>NameNode</strong></u>：即Master，<br>1、管理 HDFS 的名称空间。<br>2、管理数据块（Block）映射信息<br>3、配置副本策略<br>4、处理客户端读写请求。</p><p><u><strong>DataNode</strong></u>：就是Slave。NameNode 下达命令，DataNode 执行实际的操作。<br>1、存储实际的数据块。<br>2、执行数据块的读/写操作。</p><p><u><strong>Secondary NameNode</strong></u>：并非 NameNode 的热备。当NameNode 挂掉的时候，它并不能马上替换 NameNode 并提供服务。<br>1、辅助 NameNode，分担其工作量。<br>2、定期合并 fsimage和fsedits，并推送给NameNode。<br>3、在紧急情况下，可辅助恢复 NameNode。</p><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs架构.png" title="hdfs架构"><p><br></p><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs架构2.png" title="hdfs架构2"><hr><p><br><br><br></p><h3 id="从HDFS读取内容"><a href="#从HDFS读取内容" class="headerlink" title="从HDFS读取内容"></a>从HDFS读取内容</h3><p>1、首先调用DistributedFileSystem对象的open方法，其实获取的是一个DistributedFileSystem的实例。</p><p>2、DistributedFileSystem通过RPC(远程过程调用)获得文件的第一批block的locations，同一block按照重复数会返回多个locations，这些locations按照hadoop拓扑结构排序，距离客户端近的排在前面。</p><p>3、前两步会返回一个FSDataInputStream对象，该对象会被封装成 DFSInputStream 对象，DFSInputStream可以方便的管理DataNode和NameNode数据流。客户端调用read方法，DFSInputStream就会找出离客户端最近的DataNode并连接DataNode。</p><p>4、数据从DataNode源源不断的流向客户端。</p><p>5、如果第一个block块的数据读完了，就会关闭指向第一个block块的DataNode连接，接着读取下一个block块。这些操作对客户端来说是透明的，从客户端的角度来看只是读一个持续不断的流。</p><p>6、如果第一批block都读完了，DFSInputStream就会去NameNode拿下一批blocks的location，然后继续读，如果所有的block块都读完，这时就会关闭掉所有的流。<br><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs读取数据.png" title="hdfs读取数据"></p><p><br><br><br></p><h3 id="向HDFS写入内容"><a href="#向HDFS写入内容" class="headerlink" title="向HDFS写入内容"></a>向HDFS写入内容</h3><p>1.客户端通过调用DistributedFileSystem的create方法，创建一个新的文件。</p><p>2.DistributedFileSystem通过RPC（远程过程调用）调用NameNode，去创建一个没有blocks关联的新文件。创建前，NameNode会做各种校验，比如文件是否存在，客户端有无权限去创建等。如果校验通过，NameNode 就会记录下新文件，否则就会抛出IO异常。</p><p>3.前两步结束后会返回 FSDataOutputStream 的对象，和读文件的时候相似，FSDataOutputStream 被封装成 DFSOutputStream，DFSOutputStream 可以协调NameNode和 DataNode。客户端开始写数据到DFSOutputStream，DFSOutputStream会把数据切成一个个小packet，然后排成队列data queue。</p><p>4.DataStreamer 会去处理接受 data queue，它先问询 NameNode 这个新的 block 最适合存储的在哪几个DataNode里，比如重复数是3，那么就找到3个最适合的DataNode，把它们排成一个 pipeline。DataStreamer 把 packet 按队列输出到管道的第一个 DataNode 中，第一个 DataNode又把 packet 输出到第二个 DataNode 中，以此类推。</p><p>5.DFSOutputStream 还有一个队列叫 ack queue，也是由 packet 组成，等待DataNode的收到响应，当pipeline中的所有DataNode都表示已经收到的时候，这时akc queue才会把对应的packet包移除掉。</p><p>6.客户端完成写数据后，调用close方法关闭写入流。</p><p>7.DataStreamer 把剩余的包都刷到 pipeline 里，然后等待 ack 信息，收到最后一个ack 后，通知 DataNode 把文件标示为已完成。<br><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs写入数据.png" title="hdfs写入数据"></p><p><br><br><br></p><h3 id="副本存放策略"><a href="#副本存放策略" class="headerlink" title="副本存放策略"></a>副本存放策略</h3><p>一般情况下副本系数为3，HDFS的副本放置策略是：将第一个副本放在本地节点，将第二个副本放在本地机架上的另一个节点，而第三个副本放到不同机架上的节点。</p><p>这种方式减少了机架间的写流量，从而提高了写的性能。机架故障的机率远小于节点故障。这种方式并不影响数据可靠性和可用性的限制，并且它确实减少了读操作的网络聚合带宽，因为文件块仅存在两个不同的机架，而不是三个。</p><p>文件的副本不是均匀的分布在机架当中，1/3的副本在同一个节点上，1/3副本在同一个机架上，另外1/3个副本均匀地分布在其他机架上。</p><p><br></p><p><strong>流水线复制</strong></p><p>假设HDFS副本系数为3，当本地暂时文件积累到一个数据块大小时，client会从NameNode获取一个列表用于存放副本。然后client开始向第一个DataNode数据传输，第一个DataNode一小部分一小部分地接收数据，将每一部分写入本地仓库，并同一时间传输该部分到列表中的第二个DataNode节点。第二个DataNode也是这样，一小部分一小部分地接收数据，写入本地仓库，并同一时候转发给下一个节点，数据以流水线的方式从前一个DataNode拷贝到下一个DataNode。最后，第三个DataNode接收数据并存储到本地。因此，DataNode能流水线地从前一个节点接收数据，并同一时间转发给下一个节点，数据以流水线的方式从前一个DataNode拷贝到下一个DataNode，并以相反的方向Ack前一个Node。<br><img src="/2019/10/21/【大数据组件】HDFS简介/hdfs副本存放策略.png" title="hdfs副本存放策略"></p><p><br><br><br></p><h3 id="HA机制"><a href="#HA机制" class="headerlink" title="HA机制"></a>HA机制</h3><p><strong>HA = high availability 高可用性</strong></p><p>背景：NameNode 单点故障（SPOF=single point of failure）。</p><p>在 HA 机制下，可以运行一个 <strong>Hot Standby</strong>，作为 <strong>热备份</strong>（待机状态），在 Active NameNode 故障时，替代原有的 NN 成为新的 NN 提供服务。这一过程对用户透明，由客户端库完成。</p><p><u><strong>主要实现逻辑</strong></u>：</p><ol><li>主备需 共享 edit log 存储；</li><li>DataNode 需要同时往 主备NN 发送 Block Report；</li><li>客户端需要配置 failover 模式（失效备援模式，对用户透明）；</li><li>Standby 替代 Secondary NameNode.</li></ol><p>NameNode的切换通过代failover controller来实现。failover controller有多种实现，默认实现使用ZooKeeper来保证只有一个Namenode处于active状态。</p><p>每个Namenode运行一个轻量级的failover controller进程，该进程使用简单的心跳机制来监控Namenode的存活状态并在Namenode失败时触发failover。Failover可以由运维手动触发，例如在日常维护中需要切换主Namenode，这种情况graceful(优雅的) failover，非手动触发的failover称为ungraceful failover。</p><p>在ungraceful failover的情况下，没有办法确定失败（被判定为失败）的节点是否停止运行，也就是说触发failover后，之前的主Namenode可能还在运行。QJM一次只允许一个Namenode写edit log，但是之前的主Namenode仍然可以接受读请求。Hadoop使用fencing来杀掉之前的Namenode。Fencing通过收回之前Namenode对共享的edit log的访问权限、关闭其网络端口使得原有的Namenode不能再继续接受服务请求。使用STONITH技术也可以将之前的主Namenode关机。</p><hr><p><br><br><strong>扩展：大数据存储生态圈简介</strong></p><p>Hive与Hbase的数据一般都存储在HDFS上。HDFS为他们提供了高可靠性的底层存储支持。</p><p><strong>Hive</strong></p><p>Hive不支持更改数据的操作，Hive基于数据仓库，提供静态数据的动态查询。其使用类SQL语言，底层经过编译转为MapReduce程序，在Hadoop上运行，数据存储在HDFS上。</p><p><strong>HBase</strong></p><p>Hbase是Hadoop database，即Hadoop数据库。它是一个适合于非结构化数据存储的数据库，HBase基于列的而不是基于行的模式。</p><p>HBase是Google Bigtable的开源实现，类似Google Bigtable利用GFS作为其文件存储系统，HBase利用HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;HDFS&lt;/strong&gt; = Hadoop Distributed File System&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hadoop 分布式文件系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分布式文件系统：统一管理 分布在集群上 的文件
      
    
    </summary>
    
    
    
      <category term="大数据" scheme="http://fujiafeng.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 插件</title>
    <link href="http://fujiafeng.com/2019/10/20/Vue-js-%E6%8F%92%E4%BB%B6/"/>
    <id>http://fujiafeng.com/2019/10/20/Vue-js-%E6%8F%92%E4%BB%B6/</id>
    <published>2019-10-20T15:51:58.000Z</published>
    <updated>2019-10-21T14:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>插件的使用方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(MyPlugin)</span><br><span class="line">Vue.use(MyPlugin, &#123;</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="前端路由-与-vue-router"><a href="#前端路由-与-vue-router" class="headerlink" title="前端路由 与 vue-router"></a>前端路由 与 vue-router</h2><p><strong>单页面富应用（SPA）</strong>= <strong>前后端分离</strong> +  <strong>前端路由</strong>。<br><strong><u>前后端分离</u></strong> 的开发模式是：后端只提供 API 来返回数据，前端通过 Ajax 获取数据后，再用一定的方式渲染到页面里（后端专注于 数据，前端专注于 交互和可视化；web与移动端可共享一套 API ；首屏渲染 需要加载 js 和 css ）。<br><strong><u>前端路由</u></strong> ：由前端来维护一个路由规则。有两种实现：</p><ol><li><strong>利用 url 的 hash</strong>，即锚点（#）：JavaScript 通过 hashChange 事件监听 url 的变化，IE7 及以下需要用轮询；</li><li><strong>利用 HTML5 的 History 模式</strong>：需要服务端支持。</li></ol><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>路由不同的页面，实际上是 <strong>动态加载不同的组件</strong>。其中，每个页面对应一个组件，也就是对应一个 <code>.vue</code> 文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld'</span></span><br><span class="line"><span class="keyword">import</span> First <span class="keyword">from</span> <span class="string">'@/components/views/First'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [ &#123;</span><br><span class="line">      path: <span class="string">'/first'</span>,</span><br><span class="line">      name: <span class="string">'First'</span>,</span><br><span class="line">      component: First</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: <span class="string">'*'</span>,  <span class="comment">// 访问的路径不存在，则重定向到 HelloWorld</span></span><br><span class="line">      name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">      component: HelloWorld</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Routers 里每一项的 <code>path</code> 属性就是指定 当前匹配的路径，可以带参数； <code>component</code> 是映射的组件。webpack 会把每一个路由都打包为一个 js 文件，在请求到该页面时，才去加载这个页面的 js，即异步实现的 <strong>懒加载（按需加载）</strong>。</p><p>在 new Router() 的参数中，设置 <code>mode: &#39;history&#39;</code> 会开启 HTML5 的 history 模式；默认使用 <code>‘#’</code>来设置路径。</p><p>在 Vue 根实例中，通过 <strong><router-view></router-view></strong> 来挂载所有的路由组件。运行网页时，<router-view> 会根据当前路由 动态渲染 不同的页面组件。网页中一些公共部分，如顶部导航栏、侧边导航栏、底部版权信息等，可以直接写在 根实例 中，与 <router-view> 同级。<br>通过 <code>this.$route</code> 可以访问当前路由的具体信息。</router-view></router-view></p><h3 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h3><p>vue-router 有两种跳转页面的方法：</p><ol><li>使用内置的 <code>&lt;router-link&gt;</code> 组件，它默认会被渲染成 <a>；</a></li><li>使用 router 实例的事件方法，如 <code>this.$router.push(targetUrl)</code> ；</li></ol><p>其中，使用 <router-link> 在 HTML5 的 history 模式下会被拦截点击，避免浏览器重新加载页面。<router-link> 的常用 prop 有：</router-link></router-link></p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>to</td><td>指定要跳转的路径</td></tr><tr><td>tag</td><td>指定渲染成什么标签</td></tr><tr><td>replace</td><td>不会留下 History 记录</td></tr><tr><td>active-class</td><td>修改默认的 路由匹配成功时的类名（router-link-active）</td></tr></tbody></table><p><br></p><p>$router 的常用方法：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>push</td><td>添加要跳转到的新路径，会产生新的 history 记录</td></tr><tr><td>replace</td><td>替换当前的 history 记录</td></tr><tr><td>go</td><td>在 history 记录中向前或后退多少步，参数是整数</td></tr></tbody></table><h3 id="vue-router-导航钩子"><a href="#vue-router-导航钩子" class="headerlink" title="vue-router 导航钩子"></a>vue-router 导航钩子</h3><p>vue-router 提供了 导航钩子 <strong>beforeEach</strong> 和 <strong>afterEach</strong> ，分别在路由即将改变前和改变后触发。通过这两个钩子，可以做一些事情来提升用户体验：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * beforeEach 在路由即将改变前触发</span></span><br><span class="line"><span class="comment"> * @param to, 即将要进入的目标的路由对象</span></span><br><span class="line"><span class="comment"> * @param from, 当前导航即将要离开的路由对象</span></span><br><span class="line"><span class="comment"> * @param next, 调用该方法后，才能进入下一个钩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在页面路由改变时，统一设置网页标题</span></span><br><span class="line">  <span class="built_in">window</span>.document.title = to.meta.title;</span><br><span class="line">  <span class="comment">// 网页登录校验，未登录则跳转至登录页</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">'token'</span>)) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="string">'/login'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * afterEach 在路由改变后触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 切换页面后，滚动条返回顶端（滚动条默认保持上一个页面停留的位置）</span></span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="状态管理-与-Vuex"><a href="#状态管理-与-Vuex" class="headerlink" title="状态管理 与 Vuex"></a>状态管理 与 Vuex</h2><h3 id="状态管理与使用场景"><a href="#状态管理与使用场景" class="headerlink" title="状态管理与使用场景"></a>状态管理与使用场景</h3><p>一个组件可以分为 数据（model）和 视图（view），其基本的运行模式是：数据更新时，视图也会自动更新；在视图中又可以绑定一些事件，触发 methods 里指定的方法，从而可以改变数据、更新视图。</p><p>在实际业务中，会有 <strong>跨组件共享数据</strong> 的需求（非父子组件：跨级组件、兄弟组件），而 <strong>Vuex</strong> 的设计，就是用来 <strong>统一管理组件状态</strong> 的。</p><h3 id="Vuex-基本用法"><a href="#Vuex-基本用法" class="headerlink" title="Vuex 基本用法"></a>Vuex 基本用法</h3><p>npm安装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vuex</span><br></pre></td></tr></table></figure></p><p>在项目入口文件 main.js 里，通过 Vue.use() 使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// vuex 的配置</span></span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span>,</span><br><span class="line">        list: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">35</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increament(state, n=<span class="number">1</span>) &#123;</span><br><span class="line">            state.count += n;</span><br><span class="line">        &#125;,</span><br><span class="line">        decrease(state) &#123;</span><br><span class="line">            state.count --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        filteredList: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.list.filter( <span class="function"><span class="params">item</span> =&gt;</span> item &lt; <span class="number">10</span> );</span><br><span class="line">        &#125;,</span><br><span class="line">        listCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getters.filteredList.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    actions: &#123;</span><br><span class="line">        increment (context) &#123;</span><br><span class="line">            context.commit(<span class="string">'increment'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">store,  <span class="comment">// 使用 vuex</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>仓库 store 包含了应用的数据（状态）和操作过程。Vuex 里的数据都是响应式的，任何组件使用同一 store 的数据时，只要 store 的数据变化，对应的组件就会立即更新。</p><p>数据保存在 Vuex 选项的 <strong>state</strong> 字段内，在任何组件内，可以直接通过 <code>$store.state.</code> 读取（注意：来自 store 的数据只能读取，不能手动改变）。</p><p>改变 store 中数据的唯一途径就是 显示地提交 <strong>mutations</strong>，它是 Vuex的第二个选项，用来<strong>直接修改 state 里的数据</strong>。</p><ol><li>在组件内，通过 this.$store.commit 方法来执行 mutations（组件只负责提交一个事件名， Vuex 对应的 mutations 来完成业务逻辑）：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handleIncrement () &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store.commit( <span class="string">'increment'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutations 的第二个参数 可以是 数字、字符串或对象等类型，当一个参数不够用时，可以传入一个对象，无限扩展。</p><ol><li>提交 mutation 的另一种方式是：直接使用包含 type 属性的对象：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">    increment (state, params) &#123;</span><br><span class="line">        state.count += params.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"><span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">    type: <span class="string">'increment'</span>,</span><br><span class="line">    count: <span class="number">10</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>注意：mutation 里尽量不要 异步操作数据。</p><h3 id="Vuex-高级用法"><a href="#Vuex-高级用法" class="headerlink" title="Vuex 高级用法"></a>Vuex 高级用法</h3><h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><p>将获取 store 中的数据的方法提取出来，放在 getters 中，便于统一管理。getter 可以依赖其他的 getter，把 getter 作为第二个参数即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123; list &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;&#123; listCount &#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        computed: &#123;</span><br><span class="line">            list () &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.filteredList;</span><br><span class="line">            &#125;,</span><br><span class="line">            listCount () &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.listCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><p>actions 里面提交的是 mutation，并且可以 <strong>异步操作</strong> 业务逻辑。</p><p>action 在组件内通过 <strong>$store.dispatch</strong> 触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handleActionIncrement () &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store.dispatch( <span class="string">'increment'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们通过 Promise 异步方案 来模拟一次 延迟提交mutation：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    actions: &#123;</span><br><span class="line">        asyncIncrement (context) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    context.commit(<span class="string">'increment'</span>);</span><br><span class="line">                    resolve();</span><br><span class="line">                &#125;, <span class="number">1000</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; count &#125;&#125;</span><br><span class="line">        &lt;button @click=<span class="string">"handleAsyncIncrement"</span>&gt;<span class="keyword">async</span> +<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        computed: &#123;</span></span><br><span class="line"><span class="regexp">            count () &#123;</span></span><br><span class="line"><span class="regexp">                return this.$store.state.count;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        methods: &#123;</span></span><br><span class="line"><span class="regexp">            handleAsyncIncrement () &#123;</span></span><br><span class="line"><span class="regexp">                this.$store.dispatch('asyncIncrement').then( () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">                    console.log(this.$store.state.count); /</span><span class="regexp">/ 1</span></span><br><span class="line"><span class="regexp">                &#125;);</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>建议：<br>&emsp;&emsp;涉及改变数据的，就使用 mutations；<br>&emsp;&emsp;存在业务逻辑的，就用 actions。</p></blockquote><p><br></p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p><strong>modules</strong> 用来 <strong>将 store 分割到不同模块</strong>。当你的项目足够大时，store 里的 state、getters、mutations、actions 会非常多，都放在 main.js 里显得不是很友好，而使用 modules 可以将它们写到不同的文件中。<strong>每个 module 拥有自己的 state、getters、mutations、actions</strong> ，而且可以 <strong>多层嵌套</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">    state: &#123; ... &#125;,</span><br><span class="line">    mutations: &#123; ... &#125;,</span><br><span class="line">    actions: &#123; ... &#125;,</span><br><span class="line">    getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">    state: &#123; ... &#125;,</span><br><span class="line">    mutations: &#123; ... &#125;,</span><br><span class="line">    actions: &#123; ... &#125;,</span><br><span class="line">    getters: &#123; </span><br><span class="line">        sumCount (state, getters, rootState) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.count + rootState.count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">        a: moduleA,</span><br><span class="line">        b: moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a   <span class="comment">// moduleA 的状态 </span></span><br><span class="line">store.state.b   <span class="comment">// moduleB 的状态</span></span><br></pre></td></tr></table></figure><p>module 的 mutation 和 getter 接收的第一个参数 state 是 <strong>当前模块的状态</strong>。在 actions 和 getters 中，可以接受第三个参数 <strong>rootState</strong>，来访问 <strong>根节点的状态</strong>。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;插件的使用方式：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue.js实战" scheme="http://fujiafeng.com/tags/Vue-js%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 使用webpack</title>
    <link href="http://fujiafeng.com/2019/10/20/Vue-js-%E4%BD%BF%E7%94%A8webpack/"/>
    <id>http://fujiafeng.com/2019/10/20/Vue-js-%E4%BD%BF%E7%94%A8webpack/</id>
    <published>2019-10-20T15:51:45.000Z</published>
    <updated>2019-10-21T14:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端工程化-与-webpack"><a href="#前端工程化-与-webpack" class="headerlink" title="前端工程化 与 webpack"></a>前端工程化 与 webpack</h2><p>在webpack 的世界里，一张图片、一个 css 甚至一个字体，<strong>每个文件</strong>都是一个 <strong>模块（Module）</strong>，彼此存在依赖关系；webpack 就是用来处理 <strong>模块间的依赖关系</strong>，并把它们进行<strong>打包</strong>的。<br>&emsp;&emsp;webpack 的主要适用场景是 <strong>单页面富应用</strong>（SPA）。SPA 通常是由一个 html 文件和一堆按需加载的 js 组成。<br>&emsp;&emsp;ES6 语法中的 <strong>export</strong> 和 <strong>import</strong> 是用来 <strong>导出和导入模块</strong>的。一个模块就是一个 js 文件，它拥有独立的作用域，里面定义的变量外部无法获取。如果使用 npm 安装了一些库，在 webpack 中可以直接导入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="webpack-基础配置"><a href="#webpack-基础配置" class="headerlink" title="webpack 基础配置"></a>webpack 基础配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>初始化项目配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p><p>本地局部安装 webpack：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure></p><p>本地局部安装 webpack-dev-server：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure></p><p><code>--save-dev</code> 指 <strong>作为开发依赖</strong> 来安装。<br>&emsp;&emsp;webpack-dev-server 提供的服务有：启动一个服务器、热更新、接口代理 等。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>webpack 就是一个 <code>.js</code> 配置文件，即 webpack.config.js 。<br>&emsp;&emsp;在 <code>package.json</code> 文件的 scripts 选项中添加快速启动 webpack-dev-server 服务的脚本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><p>当运行 <code>npm run dev</code> 命令时，就会执行 <code>webpack-dev-server --inline --progress --config build/webpack.dev.conf.js</code>  命令。</p><p>webpack 核心配置项：</p><ul><li>入口（Entry）：webpack 从哪里开始寻找依赖；</li><li>出口（Output）：配置编译后的 文件存储位置 和 文件名；</li><li>加载器（Loaders）：module对象的rules属性中，可以指定一系列 loaders，每个loader 都必须包含 test 和 use 两个选项。use 选项的值可以是 数组（编译顺序：从后往前）或 字符串；</li><li>插件（Plugins）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/main.js'</span>  <span class="comment">// 单入口</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot, <span class="comment">// 打包后，文件的输出目录</span></span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">'production'</span></span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath <span class="comment">// 资源文件的引用目录</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>打包命令：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --progress --hide-modules</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><p>在使用 webpack 构建 Vue 项目的时候，可以使用一种新的构建模式：<strong>.vue 单文件组件</strong> 。在 webpack 中使用 <code>vue-loader</code> 就可以对 <code>.vue</code> 格式的文件进行处理。</p><p>为了支持图片、文字等文件，需要安装 <code>url-loader</code> 和 <code>file-loader</code> ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader?limit=1024'</span>,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p><code>&quot;?limit=1024&quot;</code> 是指如果文件小于 <code>1kb</code>，就以 <code>base64</code> 的形式加载，不会生成一个文件。</p><p>使用 单页面富应用（SPA）技术，即最终只有<strong>一个 html 文件</strong>，其余都是 <strong>静态资源</strong>。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端工程化-与-webpack&quot;&gt;&lt;a href=&quot;#前端工程化-与-webpack&quot; class=&quot;headerlink&quot; title=&quot;前端工程化 与 webpack&quot;&gt;&lt;/a&gt;前端工程化 与 webpack&lt;/h2&gt;&lt;p&gt;在webpack 的世界里，一张图片
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue.js实战" scheme="http://fujiafeng.com/tags/Vue-js%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js Render函数</title>
    <link href="http://fujiafeng.com/2019/10/20/Vue-js-Render%E5%87%BD%E6%95%B0/"/>
    <id>http://fujiafeng.com/2019/10/20/Vue-js-Render%E5%87%BD%E6%95%B0/</id>
    <published>2019-10-20T15:50:58.000Z</published>
    <updated>2019-10-21T14:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>Virtual DOM 是一个轻量级的 Javascript 对象，在状态发生变化时，Virtual DOM 会进行 Diff 运算，只更新需要被替换的 DOM，而不是重绘。<br>&emsp;&emsp;在Vue.js 2.0 中，Virtual DOM 是通过一种 <strong>VNode 类</strong> 表达的，每个 DOM 元素或组件 都对应一个 VNode 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> interface VNode &#123;</span><br><span class="line">    tag?: string; <span class="comment">// 当前节点的标签名</span></span><br><span class="line">    data?: VNodeData; <span class="comment">// 当前节点的数据对象</span></span><br><span class="line">    children?: VNode[]; <span class="comment">// 子节点数组</span></span><br><span class="line">    text?: string; <span class="comment">// 当前节点的文本</span></span><br><span class="line">    elm?: Node; <span class="comment">// 当前虚拟节点 对应的真实的 DOM 节点</span></span><br><span class="line">    ns?: string; <span class="comment">// 节点的 namespace</span></span><br><span class="line">    context?: Vue; <span class="comment">// 编译作用域</span></span><br><span class="line">    key?: string | number; <span class="comment">// 节点的标识，有利于 patch 的优化</span></span><br><span class="line">    componentOptions?: VNodeComponentOptions; <span class="comment">// 创建组件实例时，用到的选项信息</span></span><br><span class="line">    componentInstance?: Vue; <span class="comment">//</span></span><br><span class="line">    parent?: VNode; <span class="comment">// 组件的占位节点</span></span><br><span class="line">    raw?: boolean; <span class="comment">// 原始 html</span></span><br><span class="line">    isStatic?: boolean; <span class="comment">// 静态节点的标识</span></span><br><span class="line">    isRootInsert: boolean; <span class="comment">// 是否作为根节点插入</span></span><br><span class="line">    isComment: boolean; <span class="comment">// 是否是 注释节点</span></span><br><span class="line">    isCloned?: boolean; <span class="comment">// 是否是 克隆节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> interface VNodeData &#123;</span><br><span class="line">    key?: string | number;</span><br><span class="line">    slot?: string;</span><br><span class="line">    scopedSlots?: &#123; [key: string]: scopedSlot &#125;;</span><br><span class="line">    ref?: string;</span><br><span class="line">    tag?: string;</span><br><span class="line">    staticClass?: string;</span><br><span class="line">    class?: any;</span><br><span class="line">    staticStyle?: &#123; [key: string]: any &#125;;</span><br><span class="line">    style?: <span class="built_in">Object</span>[] | <span class="built_in">Object</span>;</span><br><span class="line">    props?: &#123; [key: string]: any &#125;;</span><br><span class="line">    attrs?: &#123; [key: string]: any &#125;;</span><br><span class="line">    domProps?: &#123; [key: string]: any &#125;;</span><br><span class="line">    hook?: &#123; [key: string]: Funcion &#125;;</span><br><span class="line">    on?: &#123; [key: string]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">    nativeOn?: &#123; [key: string]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[] &#125;;</span><br><span class="line">    transition?: <span class="built_in">Object</span>;</span><br><span class="line">    show?: boolean;</span><br><span class="line">    inlineTemplate?: &#123;</span><br><span class="line">        render: <span class="built_in">Function</span>;</span><br><span class="line">        staticRenderFns: <span class="built_in">Function</span>[];</span><br><span class="line">    &#125;;</span><br><span class="line">    directives?: VNodeDirective[];</span><br><span class="line">    keepAlive?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VNode 主要可分为如下5类：</p><ul><li><strong>TextVNode</strong> 文本节点</li><li><strong>ElementVNode</strong> 普通元素节点</li><li><strong>ComponentVNode</strong> 组件节点</li><li><strong>EmptyVNode</strong> 没有内容的注释节点</li><li><strong>CloneVNode</strong> 克隆节点（可以为以上任意类型）</li></ul><p><br><br><br><br><br></p><h2 id="Render-函数"><a href="#Render-函数" class="headerlink" title="Render 函数"></a>Render 函数</h2><p>Render 函数通过 <code>createElement</code> 参数来创建 Virtual DOM，有利于精简代码结构。</p><p><br><br><br><br><br></p><h2 id="createElement-用法"><a href="#createElement-用法" class="headerlink" title="createElement 用法"></a>createElement 用法</h2><h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><p>createElement 构成了 Vue Virtual DOM 的模板，它有 3 个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">createElement(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;String | Object | Function&#125; 一个HTML标签 / 组件选项 / 一个函数</span></span><br><span class="line"><span class="comment">     * 必须 Return 上述其中一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;Object&#125; 一个对应属性的数据对象（可选）</span></span><br><span class="line"><span class="comment">     * 可以在 template 中使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;String | Array&#125; 子节点（VNode）（可选）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [</span><br><span class="line">        createElement(<span class="string">'h1'</span>, <span class="string">'hello world'</span>),</span><br><span class="line">        createElement(MyComponent, &#123;</span><br><span class="line">            props: &#123; <span class="attr">someProp</span>: <span class="string">'foo'</span> &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="string">'bar'</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中，第 2 个参数 “数据对象” 的具体选项如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 和 v-bind: class 一样的API</span></span><br><span class="line">    <span class="string">'class'</span>: &#123;</span><br><span class="line">        foo: <span class="literal">true</span>,</span><br><span class="line">        bar: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 和 v-bind: style 一样的API</span></span><br><span class="line">    style: &#123;</span><br><span class="line">        color: <span class="string">'red'</span>,</span><br><span class="line">        fontSize: <span class="string">'14px'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 正常的 HTML 特性</span></span><br><span class="line">    attrs: &#123;</span><br><span class="line">        id: <span class="string">'foo'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 组件props</span></span><br><span class="line">    props: &#123;</span><br><span class="line">        myProp: <span class="string">'bar'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// DOM 属性</span></span><br><span class="line">    domProps: &#123;</span><br><span class="line">        innerHTML: <span class="string">'baz'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义事件监听器“on”</span></span><br><span class="line">    <span class="comment">// 不支持如 v-on: keyup.enter 的修饰器</span></span><br><span class="line">    <span class="comment">// 需要手动匹配 keyCode</span></span><br><span class="line">    on: &#123;</span><br><span class="line">        click: <span class="keyword">this</span>.clickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 仅对于组件，用于监听原生事件</span></span><br><span class="line">    <span class="comment">// 而不是组件使用 vm.$emit 触发的自定义事件]</span></span><br><span class="line">    nativeOn: &#123;</span><br><span class="line">        click: <span class="keyword">this</span>.nativeClickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义指令</span></span><br><span class="line">    directives: [&#123;</span><br><span class="line">        name: <span class="string">'my-custom-directive'</span>,</span><br><span class="line">        value: <span class="string">'2'</span>,</span><br><span class="line">        expression: <span class="string">'1 + 1'</span>,</span><br><span class="line">        arg: <span class="string">'foo'</span>,</span><br><span class="line">        modifiers: &#123;</span><br><span class="line">            bar: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="comment">// 作用域 slot</span></span><br><span class="line">    <span class="comment">// &#123;name: props =&gt; VNode | Array&lt;VNode&gt;&#125;</span></span><br><span class="line">    scopedSlots: &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> h(<span class="string">'span'</span>, props.text)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 具名slot</span></span><br><span class="line">    slot: <span class="string">'name-of-slot'</span>,</span><br><span class="line">    <span class="comment">// 其他特殊顶层属性</span></span><br><span class="line">    key: <span class="string">'myKey'</span>,</span><br><span class="line">    ref: <span class="string">'myRef'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>所有的组件树中，如果 VNode 是 <strong>组件</strong> 或 <strong>含有组件的 slot</strong>，那么 <strong>VNode 必须唯一</strong>。<br>&emsp;&emsp;重复渲染多个组件的方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重复渲染多个组件 */</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ele&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ele</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 局部声明组件</span></span><br><span class="line"><span class="regexp">var Child = &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        return createElement('p', 'text');</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">Vue.component('ele', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        return createElement('div', </span></span><br><span class="line"><span class="regexp">            Array.apply(null, &#123;</span></span><br><span class="line"><span class="regexp">                length: 5</span></span><br><span class="line"><span class="regexp">            &#125;).map(function() &#123;</span></span><br><span class="line"><span class="regexp">                return createElement(Child);</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#app'</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><p>对于含有组件的 slot，复用时 需要将 slot 的每个子节点都克隆一份（深度克隆）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 复用含有组件的slot，需要将slot的每个子节点都clone一份 */</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ele&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Child&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ele&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 全局注册组件</span></span><br><span class="line"><span class="regexp">Vue.component('Child', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        return createElement('p', 'text');</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">Vue.component('ele', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 克隆 slot 节点的方法</span></span><br><span class="line"><span class="regexp">        function cloneVNode(vnode) &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 递归遍历所有子节点，并克隆(工厂函数)</span></span><br><span class="line"><span class="regexp">            const clonedChildren = vnode.children &amp;&amp; </span></span><br><span class="line"><span class="regexp">            vnode.children.map(function(v) &#123;</span></span><br><span class="line"><span class="regexp">                return cloneVNode(v);</span></span><br><span class="line"><span class="regexp">            &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            const cloned = createElement(</span></span><br><span class="line"><span class="regexp">                vnode.tag,</span></span><br><span class="line"><span class="regexp">                vnode.data,</span></span><br><span class="line"><span class="regexp">                clonedChildren</span></span><br><span class="line"><span class="regexp">            );</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ VNode 关键属性</span></span><br><span class="line"><span class="regexp">            cloned.text = vnode.text;</span></span><br><span class="line"><span class="regexp">            cloned.isComment = vnode.isComment;</span></span><br><span class="line"><span class="regexp">            cloned.componentOptions = vnode.componentOptions;</span></span><br><span class="line"><span class="regexp">            cloned.elm = vnode.elm;</span></span><br><span class="line"><span class="regexp">            cloned.context = vnode.context;</span></span><br><span class="line"><span class="regexp">            cloned.ns = vnode.ns;</span></span><br><span class="line"><span class="regexp">            cloned.isStatic = vnode.isStatic;</span></span><br><span class="line"><span class="regexp">            cloned.key = vnode.key;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            return cloned;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        const vNodes = this.$slots.default;</span></span><br><span class="line"><span class="regexp">        const clonedVNodes = vNodes.map(function(vnode) &#123;</span></span><br><span class="line"><span class="regexp">            return cloneVNode(vnode);</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        return createElement('div', [</span></span><br><span class="line"><span class="regexp">            vNodes,</span></span><br><span class="line"><span class="regexp">            clonedVNodes</span></span><br><span class="line"><span class="regexp">        ]);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#app'</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="使用-JavaScript-代替模板功能"><a href="#使用-JavaScript-代替模板功能" class="headerlink" title="使用 JavaScript 代替模板功能"></a>使用 JavaScript 代替模板功能</h3><p>在 Render 函数中，<strong>不能使用 Vue 内置的指令</strong>，无论要实现什么功能，都可以用原生 JavaScript。<br>例如，使用 JS 的for 循环来实现 v-for 如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* JS 实现 v-for */</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ele :list=<span class="string">"list"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ele</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('ele', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        var nodes = [];</span></span><br><span class="line"><span class="regexp">        for(var i = 0; i &lt; this.list.length; i++) &#123;</span></span><br><span class="line"><span class="regexp">            nodes.push(createElement('p', this.list[i]));</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        return createElement('div', nodes);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    props: &#123;</span></span><br><span class="line"><span class="regexp">        list: &#123;</span></span><br><span class="line"><span class="regexp">            type: Array</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#app',</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        list: [</span></span><br><span class="line"><span class="regexp">            '《Vue.js 实战》',</span></span><br><span class="line"><span class="regexp">            '《JavaScript 高级程序设计》',</span></span><br><span class="line"><span class="regexp">            '《JavaScript 语言精粹》'</span></span><br><span class="line"><span class="regexp">        ]</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><p>Render 函数里也没有与 <strong>v-model</strong> 对应的API；对于 <strong>事件修饰符</strong> 和 <strong>按键修饰符</strong>，基本也需要自己实现。下面给出一个简单的发送聊天内容的场景模拟：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 聊天发送内容的简单模拟 */</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;ele&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ele</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('ele', &#123;</span></span><br><span class="line"><span class="regexp">    render: function(createElement) &#123;</span></span><br><span class="line"><span class="regexp">        var _this = this;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 渲染聊天内容列表</span></span><br><span class="line"><span class="regexp">        if (this.list.length) &#123;</span></span><br><span class="line"><span class="regexp">            var listNode = createElement('ul', this.list.map(function(item) &#123;</span></span><br><span class="line"><span class="regexp">                return createElement('li', item);</span></span><br><span class="line"><span class="regexp">            &#125;));</span></span><br><span class="line"><span class="regexp">        &#125; else &#123;</span></span><br><span class="line"><span class="regexp">            var listNode = createElement('p', '暂无聊天内容');</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ </span></span><br><span class="line"><span class="regexp">        return createElement('div', [</span></span><br><span class="line"><span class="regexp">            listNode,</span></span><br><span class="line"><span class="regexp">            createElement('input', &#123;</span></span><br><span class="line"><span class="regexp">                attrs: &#123;</span></span><br><span class="line"><span class="regexp">                    placeholder: '输入内容，按回车键发送'</span></span><br><span class="line"><span class="regexp">                &#125;,</span></span><br><span class="line"><span class="regexp">                style: &#123;</span></span><br><span class="line"><span class="regexp">                    width: '200px'</span></span><br><span class="line"><span class="regexp">                &#125;,</span></span><br><span class="line"><span class="regexp">                on: &#123;</span></span><br><span class="line"><span class="regexp">                    keyup: function(evt) &#123;</span></span><br><span class="line"><span class="regexp">                        // 如果不是回车键，不发送数据</span></span><br><span class="line"><span class="regexp">                        if (evt.keyCode !== 13) return;</span></span><br><span class="line"><span class="regexp">                        // 添加输入的内容到聊天列表</span></span><br><span class="line"><span class="regexp">                        _this.list.push(evt.target.value);</span></span><br><span class="line"><span class="regexp">                        // 发送后，清空输入框</span></span><br><span class="line"><span class="regexp">                        evt.target.value = '';</span></span><br><span class="line"><span class="regexp">                    &#125;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">        ]);</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    data: function() &#123;</span></span><br><span class="line"><span class="regexp">        return &#123;</span></span><br><span class="line"><span class="regexp">            value: '',</span></span><br><span class="line"><span class="regexp">            list: []</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#app'</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p><p><br><br><br><br><br></p><h2 id="函数化组件"><a href="#函数化组件" class="headerlink" title="函数化组件"></a>函数化组件</h2><p>将 <strong>functional 布尔值选项</strong>设置为 true，可以使组件 <strong>无状态</strong> 和 <strong>无实例</strong>，即 没有 data 和 this上下文。这样用 render 函数返回虚拟节点可以更容易渲染。<br>&emsp;&emsp;使用函数化组件时，Render 函数通过第二个参数 context 来提供 <strong>临时上下文</strong>。组件需要的 <strong>data、props、slots、children、parent</strong> 都是通过这个上下文来传递的。比如， <code>this.level</code> 要改写为 <code>context.props.level</code>， <code>this.$slots.default</code>改写为 <code>context.children</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用函数化组件 展示一个 根据数据 智能选择不同组件 的场景 */</span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;smart-item :data=<span class="string">"data"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">smart-item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change('img')"</span>&gt;</span>切换为图片组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change('video')"</span>&gt;</span>切换为视频组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"change('text')"</span>&gt;</span>切换为文本组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 图片组件选项</span></span><br><span class="line"><span class="keyword">var</span> ImgItem = &#123;</span><br><span class="line">    props: [<span class="string">'data'</span>],</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">            createElement(<span class="string">'p'</span>, <span class="string">'图片组件'</span>),</span><br><span class="line">            createElement(<span class="string">'img'</span>, &#123;</span><br><span class="line">                attrs: &#123;</span><br><span class="line">                    src: <span class="keyword">this</span>.data.url</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 视频组件选项</span></span><br><span class="line"><span class="keyword">var</span> VideoItem = &#123;</span><br><span class="line">    props: [<span class="string">'data'</span>],</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">            createElement(<span class="string">'p'</span>, <span class="string">'视频组件'</span>),</span><br><span class="line">            createElement(<span class="string">'video'</span>, &#123;</span><br><span class="line">                attrs: &#123;</span><br><span class="line">                    src: <span class="keyword">this</span>.data.url,</span><br><span class="line">                    controls: <span class="string">'controls'</span>,</span><br><span class="line">                    autoplay: <span class="string">'autoplay'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纯文本组件选项</span></span><br><span class="line"><span class="keyword">var</span> TextItem = &#123;</span><br><span class="line">    props: [<span class="string">'data'</span>],</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</span><br><span class="line">            createElement(<span class="string">'p'</span>, <span class="string">'纯文本组件'</span>),</span><br><span class="line">            createElement(<span class="string">'p'</span>, <span class="keyword">this</span>.data.text),</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义 smart-item 组件</span></span><br><span class="line">Vue.component(<span class="string">'smart-item'</span>, &#123;</span><br><span class="line">    <span class="comment">// 函数化组件</span></span><br><span class="line">    functional: <span class="literal">true</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 根据传入的数据，智能判断显示哪种组件</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data = context.props.data;</span><br><span class="line">            <span class="comment">// 判断 prop: data 的 type 字段是属于哪种类型的组件</span></span><br><span class="line">            <span class="keyword">if</span> (data.type === <span class="string">'img'</span>) <span class="keyword">return</span> ImgItem;</span><br><span class="line">            <span class="keyword">if</span> (data.type === <span class="string">'video'</span>) <span class="keyword">return</span> VideoItem;</span><br><span class="line">            <span class="keyword">return</span> TextItem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createElement(</span><br><span class="line">            getComponent(),</span><br><span class="line">            &#123;</span><br><span class="line">                props: &#123;</span><br><span class="line">                    <span class="comment">// 把 smart-item 的 prop: data 传给上面智能选择的组件</span></span><br><span class="line">                    data: context.props.data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            context.children</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            type: <span class="built_in">Object</span>,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        data: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 切换不同类型组件的数据</span></span><br><span class="line">        change: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (type === <span class="string">'img'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.data = &#123;</span><br><span class="line">                    type: <span class="string">'img'</span>,</span><br><span class="line">                    url: <span class="string">'https://raw.githubusercontent.com/iview/iview/master/assets/logo.png'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'video'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.data = &#123;</span><br><span class="line">                    type: <span class="string">'video'</span>,</span><br><span class="line">                    url: <span class="string">'http://vjs/zencdn.net/v/oceans.mp4'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'text'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.data = &#123;</span><br><span class="line">                    type: <span class="string">'text'</span>,</span><br><span class="line">                    content: <span class="string">'这是一段纯文本'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化时，默认设置 图片组件 的数据</span></span><br><span class="line">        <span class="keyword">this</span>.change(<span class="string">'img'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，smart-item 和 3个功能组件 都有 <code>prop: data</code>，这里通过 <code>createElement</code> 函数把 <code>getComponent()</code> 返回的对象设置为第一个参数，通过第二个参数 <code>context</code> 把 <code>smart-item</code> 的<code>data</code> 传递到选择的组件里的 <code>prop: data</code>，组件渲染出不同的内容。</p><p>总的来说，函数化组件 主要适用于以下两个场景：</p><ul><li>程序化地在多个组件中选择一个.</li><li>在将 children，props，data 传递给子组件之前 操作它们.</li></ul><p><br><br><br><br><br></p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>使用 Render 函数最不友好的地方在于，当子节点嵌套较多时，使用 createElement 难以书写及阅读出 DOM结构。<br>&emsp;&emsp;<strong>JSX</strong> 是一种看起来像 HTML，但实际是 <strong>JavaScript 的语法扩展</strong>，它用更接近 DOM 结构的形式 来描述一个组件的 UI 和状态信息。Vue.js 提供了插件 <code>babel-plugin-transform-vue-jsx</code> 来支持 JSX 语法。</p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Virtual-DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM&quot;&gt;&lt;/a&gt;Virtual DOM&lt;/h2&gt;&lt;p&gt;Virtual DOM 是一个轻量级的 Javascript 对象，
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue.js实战" scheme="http://fujiafeng.com/tags/Vue-js%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 基础语法</title>
    <link href="http://fujiafeng.com/2019/10/20/Vue-js-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://fujiafeng.com/2019/10/20/Vue-js-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2019-10-20T15:41:38.000Z</published>
    <updated>2019-10-21T14:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.js 简介：</p><ul><li>用于构建用户界面的 <strong>渐进式框架</strong>；</li><li>使用 <strong>Virtual DOM</strong>（<strong>数据驱动</strong> DOM）；</li><li>提供 <strong>响应式、组件化</strong> 的视图组件；</li><li>只关注核心库（声明式渲染+组件系统），其余交给其他库实现：<ul><li>客户端路由：<strong>Vue Router</strong></li><li>大规模状态管理：<strong>Vuex</strong></li><li>构建工具：<strong>Vue CLI</strong></li></ul></li></ul><p><br><br><img width="80%"><br><img src="/2019/10/20/Vue-js-基础语法/虚拟dom.png" title="Vue虚拟DOM"><br><br><img width="80%"><br><img src="/2019/10/20/Vue-js-基础语法/依赖追踪.png" title="Vue依赖追踪"><br></p><h2 id="vue-指令"><a href="#vue-指令" class="headerlink" title="vue 指令"></a>vue 指令</h2><p>以下指令 可使用 <em>对象语法</em>、<em>数组语法</em> 或 <code>data</code>、<code>methods</code>、<code>computed</code> 选项：</p><ul><li><strong>v-on</strong>   绑定事件监听器（事件 / 按键修饰符）</li><li><strong>v-bind</strong>   （1）动态更新 HTML元素；（2）class 与 style 的绑定。</li></ul><p>以下指令用于 在<strong>表单</strong>中双向数据绑定：</p><ul><li><strong>v-model</strong>    双向绑定数据</li></ul><p>以下指令用于 <strong>组件</strong>：</p><ul><li><strong>v-slot</strong>   具名插槽</li></ul><p>以下指令 可用在内置标签 <code>&lt;template&gt;</code> 上：</p><ul><li><strong>v-if / v-else-if / v-else</strong>  条件渲染</li><li><strong>v-show</strong>   改变元素的 CSS属性 display</li><li><strong>v-for</strong>   列表渲染指令（可用于 Array，Object）</li></ul><p>其他常用指令：</p><ul><li><strong>v-cloak</strong>  Vue实例 结束编译时，从绑定的 HTML元素上移除</li><li><strong>v-once</strong>  定义它的元素/组件 只渲染一次</li><li><strong>v-html</strong>  </li><li><strong>v-pre</strong>   跳过编译过程</li></ul><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul><li>v-bind 可简写为 <code>:</code> ;</li><li>v-on 可简写为 <code>@</code></li></ul><blockquote><p>语法糖：<br>&emsp;&emsp;在不影响功能的情况下，添加某种方法 实现同样的效果。</p></blockquote><h3 id="Vue-检测数组更新"><a href="#Vue-检测数组更新" class="headerlink" title="Vue 检测数组更新"></a>Vue 检测数组更新</h3><p>Vue 包含了一组观察 <strong>数组变异</strong> 的方法，如下：</p><ul><li><strong>push()  /  pop()</strong></li><li><strong>shift()  /  unshift()</strong></li><li><strong>splice()</strong></li><li><strong>sort()  /  reverse()</strong></li></ul><p>也包含一些 <strong>非变异方法</strong>，如下：</p><ul><li><strong>filter()</strong></li><li><strong>concat()</strong></li><li><strong>slice()</strong></li></ul><p>注意，以下数组操作，<strong>Vue 不能检测</strong>到，也不会触发视图更新：</p><ul><li><strong>通过索引直接设置项</strong>：app.books[3] = { … };</li><li><strong>修改数组长度</strong>：app.books.length = 1;</li></ul><p><br><br><br><br><br></p><h2 id="vue-实例选项"><a href="#vue-实例选项" class="headerlink" title="vue 实例选项"></a>vue 实例选项</h2><ul><li><strong>el</strong>  指定一个页面中已存在的 DOM元素，来挂载 Vue实例</li><li><strong>data</strong>   声明应用内需要双向绑定的数据</li><li><strong>computed</strong>   计算属性（函数形式 /  <code>{ get: Function, set: Function }</code>）<ol><li>文本插值；</li><li>动态地设置元素样式名class、内联样式style；</li><li>使用组件时，动态传递props</li></ol></li><li><strong>methods</strong>   声明方法</li><li><strong>components</strong>   声明组件</li><li><strong>props</strong>   父组件传值</li><li><strong>filters</strong>   声明过滤器（用于简单的 文本转换）</li></ul><p><br><br><br><br><br></p><h2 id="vue-实例生命周期钩子"><a href="#vue-实例生命周期钩子" class="headerlink" title="vue 实例生命周期钩子"></a>vue 实例生命周期钩子</h2><ul><li><strong>beforeCreate / created</strong>  创建</li><li><strong>beforeMount / mounted</strong>  挂载（挂载后 <code>$el</code> 才可用）</li><li><strong>beforeUpdate / updated</strong>  数据更新</li><li><strong>activated / deactivated</strong>  keep-alive组件 激活/停用 时（vue-router）</li><li><strong>beforeDestroy / destroyed</strong>  销毁</li></ul><p><img width="80%"><br><img src="/2019/10/20/Vue-js-基础语法/Vue生命周期.png" title="Vue生命周期"><br></p><p><strong>父子组件 生命周期 执行顺序：</strong></p><ul><li><p>加载渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt;</span><br><span class="line">子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt;</span><br><span class="line">子 mounted -&gt; 父 mounted</span><br></pre></td></tr></table></figure></li><li><p>子组件更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父 beforeUpdate -&gt; 子 beforeUpdate -&gt; </span><br><span class="line">子 updated -&gt; 父 updated</span><br></pre></td></tr></table></figure></li><li><p>父组件更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父 beforeUpdate -&gt; 父 updated</span><br></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父 beforeDestroy -&gt; 子 beforeDestroy -&gt;</span><br><span class="line">子 destroyed -&gt; 父 destroyed</span><br></pre></td></tr></table></figure></li></ul><p>更多详情请见：<a href="https://cn.vuejs.org/v2/api/index.html" target="_blank" rel="noopener">VueJs API文档</a></p><p><br><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue.js 简介：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于构建用户界面的 &lt;strong&gt;渐进式框架&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;Virtual DOM&lt;/strong&gt;（&lt;strong&gt;数据驱动&lt;/strong&gt; DOM）；&lt;/li&gt;
&lt;li&gt;提
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="Vue.js实战" scheme="http://fujiafeng.com/tags/Vue-js%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>ESLint 代码检查工具</title>
    <link href="http://fujiafeng.com/2019/09/26/ESLint-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    <id>http://fujiafeng.com/2019/09/26/ESLint-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</id>
    <published>2019-09-25T16:35:25.000Z</published>
    <updated>2019-09-25T16:57:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-ESLint"><a href="#关于-ESLint" class="headerlink" title="关于 ESLint"></a>关于 ESLint</h1><p>ESLint 是一个插件化的 javascript 代码检测工具，借助 ESLint，可将 <strong>静态代码分析</strong> 和 <strong>问题代码协助修复</strong> 集成到 <strong>编码</strong>、<strong>提交</strong> 和 <strong>打包</strong> 过程中，及早发现并协助修复代码中：</p><ol><li>有语法错误的部分</li><li>不符合约定的样式准则的部分</li><li>不符合约定的最佳实践的部分</li></ol><p>在项目开发中获得如下收益：</p><ol><li>在执行代码之前发现并修复语法错误，减少调试耗时和潜在 bug</li><li>保证项目的 <strong>编码风格统一</strong>，提高可维护性</li><li>督促团队成员在编码时遵守约定的最佳实践，提高代码质量</li></ol><p><br><br><br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><br></p><h2 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g eslint</span><br></pre></td></tr></table></figure><p>初始化配置文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eslint --init</span><br></pre></td></tr></table></figure></p><h2 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install eslint --save-dev</span><br></pre></td></tr></table></figure><p>初始化配置文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./node_modules/.bin/eslint --init</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h1 id="规则配置模式"><a href="#规则配置模式" class="headerlink" title="规则配置模式"></a>规则配置模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">规则名： [ 错误级别， 附加选项 ]</span><br><span class="line">规则名： 错误级别</span><br></pre></td></tr></table></figure><p>ESLint 定义了 <strong>三种错误级别</strong>：</p><ul><li><p><strong>“off”</strong> 或 <strong>0</strong> - 关闭，不校验该规则</p></li><li><p><strong>“warn”</strong> 或 <strong>1</strong> - 警告，不影响 exit code</p></li><li><p><strong>“error”</strong> 或 <strong>2</strong> - 错误，触发该规则时 exit code 为 1</p></li></ul><p><br><br><br></p><h1 id="webpack-中配置-eslint-（vue版）"><a href="#webpack-中配置-eslint-（vue版）" class="headerlink" title="webpack 中配置 eslint （vue版）"></a>webpack 中配置 eslint （vue版）</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(js|vue)$/</span>,</span><br><span class="line">  loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">  enforce: <span class="string">'pre'</span>,</span><br><span class="line">  include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">  options: &#123;</span><br><span class="line">    formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>),</span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="vue-cli-的-eslintrc-js-配置文件："><a href="#vue-cli-的-eslintrc-js-配置文件：" class="headerlink" title="vue-cli 的 .eslintrc.js 配置文件："></a>vue-cli 的 .eslintrc.js 配置文件：</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//此项是用来告诉eslint找当前配置文件不能往父级查找</span></span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析</span></span><br><span class="line">  parser: <span class="string">'babel-eslint'</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//此项是用来指定javaScript语言类型和风格，sourceType用来指定js导入的方式，默认是script，此处设置为module，指某块导入方式</span></span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//此项指定环境的全局变量，下面的配置指定为浏览器环境</span></span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style</span></span><br><span class="line">  <span class="comment">// 此项是用来配置标准的js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错</span></span><br><span class="line">  extends: <span class="string">'standard'</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// required to lint *.vue files</span></span><br><span class="line">  <span class="comment">// 此项是用来提供插件的，插件名称省略了eslint-plugin-，下面这个配置是用来规范html的</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="string">'html'</span></span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// add your custom rules here</span></span><br><span class="line">  <span class="comment">// 下面这些rules是用来设置从插件来的规范代码的规则，使用必须去掉前缀eslint-plugin-</span></span><br><span class="line">  <span class="comment">// 主要有如下的设置规则，可以设置字符串也可以设置数字，两者效果一致</span></span><br><span class="line">  <span class="comment">// "off" -&gt; 0 关闭规则</span></span><br><span class="line">  <span class="comment">// "warn" -&gt; 1 开启警告规则</span></span><br><span class="line">  <span class="comment">//"error" -&gt; 2 开启错误规则</span></span><br><span class="line">  <span class="comment">// 了解了上面这些，下面这些代码相信也看的明白了</span></span><br><span class="line">  <span class="string">'rules'</span>: &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// allow paren-less arrow functions</span></span><br><span class="line">    <span class="string">'arrow-parens'</span>: <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allow async-await</span></span><br><span class="line">    <span class="string">'generator-star-spacing'</span>: <span class="number">0</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allow debugger during development</span></span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">'no-multi-str'</span>: <span class="number">2</span>, <span class="comment">// 字符串不能用\换行</span></span><br><span class="line">    <span class="string">'no-unreachable'</span>: <span class="number">2</span>, <span class="comment">// 不能有无法执行的代码</span></span><br><span class="line">    <span class="string">'no-use-before-define'</span>: <span class="number">2</span>, <span class="comment">// 违背顶以前不能使用</span></span><br><span class="line">    <span class="string">'no-with'</span>: <span class="number">2</span>, <span class="comment">// 禁用with</span></span><br><span class="line">    <span class="string">'arrow-spacing'</span>: <span class="number">0</span>, <span class="comment">// =&gt; 的前/后括号</span></span><br><span class="line">    <span class="string">'brace-style'</span>: [<span class="number">1</span>, <span class="string">'1tbs'</span>], <span class="comment">// 大括号风格</span></span><br><span class="line">    <span class="string">'comma-style'</span>: [<span class="number">2</span>, <span class="string">'1ast'</span>], <span class="comment">// 逗号风格，换行是在行首还是行尾</span></span><br><span class="line">    <span class="string">'curly'</span>: [<span class="number">2</span>, <span class="string">'all'</span>], <span class="comment">// 必须使用 if()&#123;&#125; 中的&#123;&#125;</span></span><br><span class="line">    <span class="string">'indent'</span>: [<span class="number">2</span>, <span class="number">4</span>], <span class="comment">//缩进风格</span></span><br><span class="line">    <span class="string">'use-isnan'</span>: <span class="number">2</span>, <span class="comment">// 禁止比较时使用 NaN，只能用 isNan()</span></span><br><span class="line">    <span class="string">'semi-spacing'</span>: [<span class="number">0</span>, &#123;<span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">true</span>&#125;], <span class="comment">// 分号前后空格</span></span><br><span class="line">    <span class="string">'spaced-comment'</span>: <span class="number">0</span>, <span class="comment">// 注释风格要不要空格</span></span><br><span class="line">    <span class="string">'space-before-blocks'</span>: [<span class="number">0</span>, <span class="string">'always'</span>], <span class="comment">// 不以新行开始的代码块 &#123; 前要不要空格</span></span><br><span class="line">    <span class="string">'eol-last'</span>: <span class="number">0</span>, <span class="comment">// 文件 不以单一的换行符结束</span></span><br><span class="line">    <span class="string">'space-before-function-paren'</span>: [<span class="number">0</span>, <span class="string">"always"</span>], <span class="comment">// 函数定义时，括号前面是否要空格</span></span><br><span class="line">    <span class="string">'no-trailing-space'</span>: <span class="number">0</span>, <span class="comment">// 一行结束空格</span></span><br><span class="line">    <span class="string">'quotes'</span>: [<span class="number">0</span>, <span class="string">'single'</span>], <span class="comment">// 引号类型 '' "" ``</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1 id="VSCode-集成"><a href="#VSCode-集成" class="headerlink" title="VSCode 集成"></a>VSCode 集成</h1><p><strong>代码提示</strong><br>工具： VSCode ESLint 插件<br>使用：在 VSCode 设置中将 <code>eslint.enable</code> 设置为 <code>true</code></p><p><strong>代码修复</strong><br>工具：VSCode Prettier 插件<br>使用：在 VSCode 设置中将 <code>prettier.eslintIntegration</code> 设置为 <code>true</code>，prettier 插件执行格式化时将使用 prettier-eslint 完成下述操作：</p><ol><li>使用 prettier 格式化代码</li><li>对上一步格式化过的代码执行 <code>eslint --fix</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于-ESLint&quot;&gt;&lt;a href=&quot;#关于-ESLint&quot; class=&quot;headerlink&quot; title=&quot;关于 ESLint&quot;&gt;&lt;/a&gt;关于 ESLint&lt;/h1&gt;&lt;p&gt;ESLint 是一个插件化的 javascript 代码检测工具，借助 ESLint
      
    
    </summary>
    
    
    
      <category term="工具" scheme="http://fujiafeng.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vscode 快捷键（windows）</title>
    <link href="http://fujiafeng.com/2019/09/23/vscode-%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88windows%EF%BC%89/"/>
    <id>http://fujiafeng.com/2019/09/23/vscode-%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%88windows%EF%BC%89/</id>
    <published>2019-09-23T14:38:19.000Z</published>
    <updated>2019-09-23T14:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>【Ctrl + Shift + P】</strong>    打开命令面板<br>&emsp;&emsp;<strong>【Ctrl + U】</strong>   返回上一个光标位置<br>&emsp;&emsp;<strong>【Home/End】</strong>    光标移动至行首或行尾<br>&emsp;&emsp;<strong>【Ctrl + Home/End】</strong>    光标移动至文档的开头或末尾<br>&emsp;&emsp;<strong>【Ctrl + D】</strong>    选中单词（第二次按下，会找到文档中下一次出现该单词的位置 并选中单词）<br>&emsp;&emsp;<strong>【Alt + 上下】</strong>    代码移动<br>&emsp;&emsp;<strong>【Ctrl + /】</strong>    行注释<br>&emsp;&emsp;<strong>【Alt + Shift + F】</strong>    格式化整个文档<br>&emsp;&emsp;<strong>【Alt + 鼠标点击】</strong>    多光标<br>&emsp;&emsp;<strong>【Alt + Shift + I】</strong>    在选中的多行代码的 每一行 （已选中内容）后边都会添加光标<br>&emsp;&emsp;<strong>【Ctrl + P】</strong>    快速打开文件<br>&emsp;&emsp;<strong>【Ctrl + G】</strong>    快速跳转（代码行）<br>&emsp;&emsp;<strong>【Ctrl + Shift + O】</strong>    符号跳转（符号：文件名、函数名、css类名）<br>&emsp;&emsp;<strong>【F12】</strong>    跳转至 函数定义处<br>&emsp;&emsp;<strong>【Ctrl + F12】</strong>    跳转至 函数实现处<br>&emsp;&emsp;<strong>【Shift + F12】</strong>    引用跳转（先将光标移动到 函数/类 上）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;【Ctrl + Shift + P】&lt;/strong&gt;    打开命令面板&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;【Ctrl + U】&lt;/strong&gt;   返回上一个光标位置&lt;br&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;【Home/End】&lt;/s
      
    
    </summary>
    
    
    
      <category term="工具" scheme="http://fujiafeng.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>侧耳倾听 Vol.4</title>
    <link href="http://fujiafeng.com/2019/09/16/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-4/"/>
    <id>http://fujiafeng.com/2019/09/16/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-4/</id>
    <published>2019-09-16T13:41:02.000Z</published>
    <updated>2019-09-16T13:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>#抄句子#</em></p><blockquote><p>「春有百花秋有月，夏有涼風冬有雪。<br>&emsp;&emsp;&emsp;若無閒事掛心頭，便是人間好時節。」</p></blockquote><p><br></p><blockquote><p>「晴秋上午 隨便走走 不一定要快樂」  &emsp;—— 木心</p></blockquote><p><br></p><blockquote><p>「 我希望你嚮往生命的盎然<br>&emsp;&emsp;&emsp;不會受傷<br>&emsp;&emsp;&emsp;會熱愛生活<br>&emsp;&emsp;&emsp;我想和你一起遊戲人間<br>&emsp;&emsp;&emsp;愛得坦蕩<br>&emsp;&emsp;&emsp;呼吸都想念我 」   &emsp;—— 賈平凹</p></blockquote><p><br></p><blockquote><p>「一個傷痛著的人置身一個陌生的環境是幸福的，因為你不必在熟悉的人和風景面前故作堅強，你完全可以放縱地流淚。」   &emsp;—— 《世界上所有的夜晚》 遲子建</p></blockquote><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;#抄句子#&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「春有百花秋有月，夏有涼風冬有雪。&lt;br&gt;&amp;emsp;&amp;emsp;&amp;emsp;若無閒事掛心頭，便是人間好時節。」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="侧耳倾听" scheme="http://fujiafeng.com/tags/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC/"/>
    
  </entry>
  
  <entry>
    <title>YoungFront 框架</title>
    <link href="http://fujiafeng.com/2019/09/16/YoungFront%E6%A1%86%E6%9E%B6/"/>
    <id>http://fujiafeng.com/2019/09/16/YoungFront%E6%A1%86%E6%9E%B6/</id>
    <published>2019-09-16T13:04:28.000Z</published>
    <updated>2019-09-16T13:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="YFjs-组件库"><a href="#YFjs-组件库" class="headerlink" title="YFjs 组件库"></a>YFjs 组件库</h2><p>一个基于 AMD规范 的组件库，内含简洁 SPA 框架，便于快速构建单页面应用系统。<br>&emsp;&emsp;其中大部分是第三方库，如 jQuery、RequireJs、Bootstrap 等的开源库和框架是这个组件库的核心依赖。<br>&emsp;&emsp;YFjs不仅能够帮助我们快速使用弹出框、美化后的下拉框和单/复选框、滚动条等UI组件，也能使用JSON转换、Cookie处理、日期格式处理等工具插件，更能配合内含的 SPA 框架快速构建一个单页面应用系统，让我们的前端开发更便捷。</p><img src="/2019/09/16/YoungFront框架/yfjs-content.png" title="yfjs目录结构"><h3 id="引入组件库"><a href="#引入组件库" class="headerlink" title="引入组件库"></a>引入组件库</h3><p>在 head 标签内引入组件库的入口 JS 文件 yfjs.js 即可：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"[yfjs-lib path]/yfjs.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>入口 JS 文件会 <strong>自动引入</strong> 基本样式文件、核心 JS 库文件等组件库的相关静态资源。</p><h3 id="入口配置"><a href="#入口配置" class="headerlink" title="入口配置"></a>入口配置</h3><p>在引入组件库的入口 JS 文件时，我们可以通过定义以下属性来扩展组件库的功能。</p><ul><li><strong>data-cache</strong>: 全局缓存开关，默认为 true。设为 false 则关闭缓存</li><li><strong>data-debug</strong>: 调试模式开关，默认为 false，使用压缩后的资源。设为 true 时将使用未压缩的资源</li><li><strong>data-debug-css</strong>: 基本样式文件的调试模式开关，默认为 data-debug。为 false 时引入压缩后的基本样式文件，否则引入未压缩的基本样式文件</li><li><strong>data-debug-module</strong>: 组件模块的调试模式开关，默认为 data-debug。为 false 时引入压缩后的组件模块文件，否则引入未压缩的组件模块文件</li><li><strong>data-base</strong>: 应用访问基路径，默认继承 <base> 标签值。</li><li><strong>data-base-require</strong>: 应用内自定义模块引入基路径，默认相对于 data-base。</li><li><strong>data-base-css</strong>: 是否引入组件库的基本样式文件，默认为 true。设为 false 时不引入基本样式文件。</li><li><strong>data-compatible</strong>: 是否引入所有兼容脚本，默认为 false。设为 true 时自动判断兼容性并引入兼容脚本。</li><li><strong>data-compatible-modernizr</strong>: 是否引入 Modernizr 兼容脚本，默认为 data-compatible。了解 Modernizr。</li><li><strong>data-compatible-respond</strong>: 是否引入 respond 兼容脚本（兼容 Media Query），默认为 data-compatible。</li><li><strong>data-compatible-html5</strong>: 是否引入 html5shiv 兼容脚本（兼容 HTML5 新元素），默认为 data-compatible。</li><li><strong>data-compatible-es5</strong>: 是否引入 es5 兼容脚本（兼容 ES5 API），默认为 data-compatible。</li><li><strong>data-compatible-es6</strong>: 是否引入 es6 兼容脚本（兼容 ES6 API），默认为 data-compatible。</li><li><strong>data-compatible-json</strong>: 是否引入 JSON 兼容脚本（兼容 JSON.parse 和 JSON.stringify），默认为 data-compatible。</li><li><strong>data-main</strong>: 应用入口 JS 文件。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"[yfjs-lib path]/yfjs.js?v=0.8.2"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">data-cache</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">data-debug</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="yfjs-spa-框架"><a href="#yfjs-spa-框架" class="headerlink" title="yfjs/spa 框架"></a>yfjs/spa 框架</h2><p>一个 SPA（单页面应用）框架，风格简洁，配置和约定共同驱动。</p><h3 id="配置应用入口"><a href="#配置应用入口" class="headerlink" title="配置应用入口"></a>配置应用入口</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/yfjs-lib/yfjs.js"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">data-main</span>=<span class="string">"app"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">data-base-require</span>=<span class="string">"app"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">data-cache</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>data-main</strong>: 应用的入口 JS 文件。建议为 app。</li><li><strong>data-base-require</strong>: 引入本地资源的基路径。建议为 app。</li><li><strong>data-cache</strong>: 全局缓存开关，控制模板文件、JS 文件等是否缓存。默认开启缓存，设置为 false 则关闭缓存。 </li></ul><h3 id="构建应用目录"><a href="#构建应用目录" class="headerlink" title="构建应用目录"></a>构建应用目录</h3><img src="/2019/09/16/YoungFront框架/content-structure.png" title="构建应用目录"><h3 id="编写首页内容"><a href="#编写首页内容" class="headerlink" title="编写首页内容"></a>编写首页内容</h3><p>编写应用入口文件内容，引入框架 yfjs/spa ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'yfjs/spa'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">SPA</span>) </span>&#123; </span><br><span class="line">    SPA.create(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在视图目录下创建文件 home.js，并编写内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'App'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">App</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> App.View(&#123;</span><br><span class="line">        layout: <span class="string">"default"</span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在视图模板目录下创建文件 home.html，并编写内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在布局目录下创建布局文件 default.js，并编写内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'App'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> App.Layout();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在布局模板目录下创建文件 default.html，并编写内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span> </span><br><span class="line">    &#123;&#123;&#123;body&#125;&#125;&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用布局"><a href="#使用布局" class="headerlink" title="使用布局"></a>使用布局</h3><p>将<strong>页面的公共部分</strong>抽离成布局，提升页面的渲染效率。</p><h3 id="约定与配置"><a href="#约定与配置" class="headerlink" title="约定与配置"></a>约定与配置</h3><p>yfjs/spa 框架是一个 <u><strong>配置和约定共同驱动</strong></u> 的框架。配置的是<strong>功能接口</strong>，约定的是<strong>路由等规则</strong>。</p><p><strong>约定规则 — 路由约定</strong></p><p>框架内置了页面路由，页面的定向遵守框架既定规则：</p><ul><li>页面的路由在 URL 上默认体现为 hash 模式。即形如 <a href="http://127.0.0.1/#/path?param1=value1，则页面路径为" target="_blank" rel="noopener">http://127.0.0.1/#/path?param1=value1，则页面路径为</a>“ /path “，其后内容为页面的参数。</li><li>页面路径对应视图目录 views下的同路径同名的 JavaScript 文件。</li><li>页面的默认模板对应模板目录 templates下的同路径同名的 HTML 文件。</li><li>页面使用的布局（若存在）对应布局目录 layouts下的同路径同名的 JavaScript 文件。</li><li>页面布局的默认模板对应布局模板目录 templates/layouts下的同路径同名的 HTML 文件。</li></ul><p><strong>约定规则 — 分层渲染</strong></p><p>为了充分体现单页面应用的局部加载、按需加载的特性，框架将页面内容进行了区段划分，并由上至下分层渲染。<br>&emsp;&emsp;框架将当前页面窗口定义为 App 层（应用层），页面主体内容定义为 View 层（视图层），页面外层布局定义为 Layout 层（布局层）。其中 View 层可任意嵌套并定义加载时机，在最上层的 View 层可指定采用的 Layout 层。App 层则负责整体状态切换、页面路由等。</p><img src="/2019/09/16/YoungFront框架/spa-widgets.png" title="yfjs/spa分层渲染"><p><strong>配置和扩展</strong></p><p>在应用入口文件 /app/app.js 中，为当前应用指定一些配置项：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SPA.create(&#123; </span><br><span class="line">    <span class="comment">// 配置项 baseUrl </span></span><br><span class="line">    baseUrl: &#123; </span><br><span class="line">        style: <span class="string">"/assets/css"</span>,    <span class="comment">// 设置样式文件基路径</span></span><br><span class="line">        resource: <span class="string">"/assets"</span>    <span class="comment">// 设置其他资源基路径</span></span><br><span class="line">     &#125;, </span><br><span class="line">    <span class="comment">// 扩展功能 </span></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"do "</span> + <span class="keyword">this</span>.getSomething(); </span><br><span class="line">     &#125;, </span><br><span class="line">    getSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something."</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在创建一个视图实例 /views/home.js 时，配置扩展功能如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">App.View(&#123;</span><br><span class="line">    <span class="comment">// 配置项 layout 布局</span></span><br><span class="line">    layout: <span class="string">"default"</span>,</span><br><span class="line">    <span class="comment">// 配置项 ready 页面渲染后执行</span></span><br><span class="line">    ready: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="keyword">this</span>.doSomething()</span><br><span class="line">        );</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 扩展功能</span></span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 App 实例的扩展功能</span></span><br><span class="line">        App.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>框架结构的顶层。<br>&emsp;&emsp;应用层主要负责路由自动切换、维护全局状态、提供全局功能等。应用开始启动后，框架将自动生成一个应用实例来负责应用层的一应事务。</p><h3 id="视图-布局层"><a href="#视图-布局层" class="headerlink" title="视图/布局层"></a>视图/布局层</h3><p>在框架下渲染每个页面的层级结构称为视图（View）层。视图层可以定义自己的布局（Layout）层，布局层主要负责实现多个视图层共有的渲染效果（如公用的 header 页头，banner 图，footer 页脚等）。多个视图层可以共用一个布局层。</p><h3 id="实例的生命周期"><a href="#实例的生命周期" class="headerlink" title="实例的生命周期"></a>实例的生命周期</h3><p>应用实例从页面开始初次加载时创建，一直存在到页面顶层窗口关闭。期间页面内容的更新由内置的路由器（Router）自动加载视图层进行处理。这个过程称为 <strong>应用实例生命周期</strong>。<br>页面的访问由 url 中的 hash 部分自动触发。应用层会通过内置的页面路由监控这个触发事件，并开始路由页面。每个页面视图脚本从被加载到开始，到自身内容从页面中移除的过程，称为 <strong>视图实例生命周期</strong>。<br>视图页面内容加载完成后，如果定义了布局层，会继续加载布局层内容。布局层脚本从被加载到开始，到布局内容从页面中移除的过程，称为 <strong>布局实例生命周期</strong>。</p><blockquote><p>更多详细信息，请访问： <a href="http://jinzhk.github.io/yfjs/" target="_blank" rel="noopener">YoungFront 官网</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;YFjs-组件库&quot;&gt;&lt;a href=&quot;#YFjs-组件库&quot; class=&quot;headerlink&quot; title=&quot;YFjs 组件库&quot;&gt;&lt;/a&gt;YFjs 组件库&lt;/h2&gt;&lt;p&gt;一个基于 AMD规范 的组件库，内含简洁 SPA 框架，便于快速构建单页面应用系统。&lt;br&gt;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="YoungFront" scheme="http://fujiafeng.com/tags/YoungFront/"/>
    
  </entry>
  
  <entry>
    <title>侧耳倾听 Vol.3</title>
    <link href="http://fujiafeng.com/2019/08/19/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-3/"/>
    <id>http://fujiafeng.com/2019/08/19/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC-Vol-3/</id>
    <published>2019-08-19T14:44:38.000Z</published>
    <updated>2019-09-16T13:47:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>#抄句子#</em></p><blockquote><p>「你任何為人稱道的美麗不及我第一次遇見你」  &emsp;—— 馬頔</p></blockquote><p><br></p><blockquote><p>「知識和感覺比金錢更能決定一個人的階級」  &emsp;—— 《身份的焦慮》阿蘭·德波頓</p></blockquote><p><br></p><blockquote><p>“The woman I like is so powerful that a man has to be courageous to approach her.” &emsp;&emsp; ——  Alexander McQueen </p></blockquote><p><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;#抄句子#&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「你任何為人稱道的美麗不及我第一次遇見你」  &amp;emsp;—— 馬頔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「知識和感覺比金錢更能決定一個人的階級」 
      
    
    </summary>
    
    
    
      <category term="生活" scheme="http://fujiafeng.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="侧耳倾听" scheme="http://fujiafeng.com/tags/%E4%BE%A7%E8%80%B3%E5%80%BE%E5%90%AC/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 引用类型</title>
    <link href="http://fujiafeng.com/2019/08/15/JavaScript-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>http://fujiafeng.com/2019/08/15/JavaScript-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2019-08-14T16:29:01.000Z</published>
    <updated>2019-08-14T16:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。</p><p><br></p><h1 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h1><blockquote><p>Object 是一个基础类型，其他所有类型都从Object 继承了基本的行为。</p></blockquote><p>创建 Object 实例有两种方式：</p><ol><li>使用 new 操作符后跟 Object 构造函数；</li><li>使用对象字面量表示法（属性名可以使用字符串）。</li></ol><blockquote><p>对象字面量表示法 也是向函数传递大量可选参数的首选方式；<br>最好的做法是 对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。</p></blockquote><p>访问对象属性：</p><ol><li>点表示法；</li><li>方括号表示法（将要访问的属性以 <strong>字符串</strong> 的形式放在方括号中）。</li></ol><blockquote><p>方括号语法的主要优点是可以通过 <strong>变量</strong> 来访问属性</p></blockquote><p><br><br><br><br><br></p><h1 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h1><p>ECMAScript 数组与其他语言中数组的不同之处：</p><ol><li>ECMAScript 数组的每一项可以保存 <strong>任何类型</strong> 的数据；</li><li>ECMAScript 数组的 <strong>大小</strong>是可以 <strong>动态调整</strong> 的。</li></ol><p>创建数组的基本方式有两种：</p><ol><li>使用 Array 构造函数；</li><li>使用数组字面量表示法。</li></ol><p>在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值；如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加 1 的长度。数组最后一项的索引始终是 length-1。</p><p>数组的项数保存在其 length 属性中，这个属性始终会返回 0 或更大的值。数组的 length 属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。</p><h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>确定某个对象是不是数组：</p><ol><li><strong>value instanceof Array</strong>  （instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array 构造函数）</li><li><strong>Array.isArray( value )</strong>  方法 （确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的）</li></ol><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><ul><li><strong>toLocaleString()</strong> ：创建一个数组值的以逗号分隔的字符串；为了取得每一项的值，调用的是每一项的toLocaleString()方法；</li><li><strong>toString()</strong> ：返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串；为了创建这个字符串会调用数组每一项的toString()方法；</li><li><strong>valueOf()</strong> ：返回的还是数组。</li></ul><h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>LIFO 后进先出，推入 与 弹出 只发生在 <strong>栈顶</strong> 。</p><ul><li><strong>push() 方法</strong> ：推入，可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度；</li><li><strong>pop() 方法</strong> ：弹出，从数组末尾移除最后一项，减少数组的length 值，然后返回移除的项。</li></ul><h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>FIFO 先进先出，推入 发生在队尾，移除 发生在队列头部。</p><ul><li><strong>push() 方法</strong></li><li><strong>shift() 方法</strong> ：移除数组中的第一个项并返回该项，同时将数组长度减1。</li></ul><blockquote><p> <strong>unshift()方法</strong> ：在数组前端添加任意个项并返回新数组的长度</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">//推入两项</span></span><br><span class="line"><span class="comment">// unshift 插入顺序 与 参数顺序 一致，该语句得到的 colors == ["red", "green"];</span></span><br></pre></td></tr></table></figure><h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><ul><li><strong>reverse() 方法</strong> ：反序；</li><li><strong>sort() 方法</strong> ：默认升序（会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串）。sort() 方法可以接收一个 <strong>比较函数</strong> 作为参数。</li></ul><blockquote><ol><li>比较函数接收两个参数，如果第一个参数应该位于第二个 <strong>之前</strong> 则返回一个 <strong>负数</strong> ，如果两个参数 <strong>相等</strong> 则返回 <strong>0</strong> ，如果第一个参数应该位于第二个 <strong>之后</strong> 则返回一个 <strong>正数</strong> ；</li><li>对于 <strong>数值类型</strong> 或者其 <strong>valueOf() 方法会返回数值类型的对象类型</strong> ，可以使用一个更简单的比较函数。这个函数只要用 <strong>第二个值减第一个值</strong> 即可。</li></ol></blockquote><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li><strong>concat() 方法</strong> ：先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</li><li><strong>slice() 方法</strong> ：接受一或两个参数，即要返回项的 <strong>起始</strong> 和 <strong>结束</strong> 位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项；如果有两个参数，该方法返回起始和结束位置之间的项（不包括结束位置的项）。</li><li><strong>splice() 方法</strong>：主要用途是向数组的中部插入项，使用方式有如下三种：<ul><li><strong>删除</strong> ：指定2 个参数 &lt;要删除的第一项的位置， 要删除的项数&gt;；</li><li><strong>插入</strong> ：提供3 个参数 &lt;起始位置， 0（要删除的项数）<br>，要插入的项，…&gt;</li><li><strong>替换</strong> ：指定3 个参数 &lt;起始位置，要删除的项数，要插入的任意数量的项&gt;；始终都会返回一个数组，该数组中包含从原始数组中删除的项</li></ul></li></ul><blockquote><p>如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置；如果结束位置小于起始位置，则返回空数组。</p></blockquote><h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><ul><li>indexOf()  ：从数组的开头（位置0）开始向后查找；</li><li>lastIndexOf() ：从数组的末尾开始向前查找。</li></ul><p>这两个方法都</p><ol><li>接收两个参数：<strong>要查找的项</strong> 和（可选的）表示<strong>查找起点位置</strong>的索引；</li><li>都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1；</li><li>在比较第一个参数与数组中的每一项时，会使用 <strong>全等</strong> 操作符</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> people = [&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> morePeople = [person];</span><br><span class="line">alert(people.indexOf(person)); <span class="comment">//-1</span></span><br><span class="line">alert(morePeople.indexOf(person)); <span class="comment">//0</span></span><br><span class="line"><span class="comment">/* 在这里查找的时候，所比较的是对象。</span></span><br><span class="line"><span class="comment">*在 people 这个数组中的这个 &#123;name:“Nicholas”&#125; 和 person 并不是同一个对象，而morepeole 中和 person 是同一个对象（因为直接引用了它）。</span></span><br><span class="line"><span class="comment">*因此第一个会返回 -1（无法找到），第二个是 0。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>数组中定义了5 个迭代方法，分别对 <strong>数组中的每一项</strong> 运行给定函数：</p><ul><li><strong>every()</strong> ：如果该函数对<strong>每一项都返回true</strong>，则返回true；</li><li><strong>some()</strong> ：如果该函数对<strong>任一项返回true</strong>，则返回true；</li><li><strong>filter()</strong> ：返回该函数会返回true 的项组成的<strong>数组</strong> （用于 查询符合某些条件的所有数组项）；</li><li><strong>map()</strong> ：返回每次函数调用的结果组成的<strong>数组</strong>；</li><li><strong>forEach()</strong> ：没有返回值。</li></ul><p>每个方法都接收两个参数：</p><ol><li>要在每一项上运行的 <strong>函数</strong>；</li><li>（可选的）运行该函数的作用域对象——影响this 的值。</li></ol><blockquote><p>传入这些方法中的函数会接收三个参数：</p><ol><li>数组项的值；</li><li>该项在数组中的位置；</li><li>数组对象本身。</li></ol></blockquote><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>ECMAScript 定义了两个归并数组的方法，可以迭代数组的所有项，然后构建一个最终返回的值：</p><ul><li><strong>reduce() 方法</strong> ：从数组的第一项开始，逐个遍历到最后；</li><li><strong>reduceRight() 方法</strong> ： 从数组的最后一项开始，向前遍历到第一项。</li></ul><p>这两个方法都接收两个参数：</p><ol><li>一个在每一项上 <strong>调用的函数</strong>；</li><li>（可选的）作为归并基础的初始值。</li></ol><blockquote><p>传给reduce()和reduceRight()的函数接收4 个参数：</p><ol><li>前一个值；</li><li>当前值；</li><li>项的索引；</li><li>数组对象。<br><br></li></ol><p>这个函数返回的任何值都会作为 <strong>第一个参数</strong> 自动传给下一项。<strong>第一次迭代发生在数组的第二项上</strong>，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p></blockquote><p><br><br><br><br><br></p><h1 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h1><p>Date类型 使用自 <strong>UTC（Coordinated Universal Time，国际协调时间）</strong> 1970 年1 月1 日午夜（零时）开始经过的 <strong>毫秒数</strong> 来保存日期。</p><p>使用 Date 构造函数，创建一个日期对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure><p><strong>不传递参数</strong> 的情况下，新创建的对象自动获得 <strong>当前日期和时间</strong>；<br>如果想根据 <strong>特定的日期和时间</strong> 创建日期对象，必须传入表示 <strong>该日期的毫秒数</strong>。<br>ECMAScript 提供了三个方法，以获取日期的毫秒数：</p><ul><li><strong>Date.parse()</strong> ：接收一个<strong>表示日期的字符串参数</strong>，然后尝试根据这个字符串返回相应日期的毫秒数；如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。</li><li><strong>Date.UTC()</strong> ：参数分别是 <strong>年份</strong>、<strong>基于0 的月份</strong>（0 - 11）、月中的哪一天（1 - 31）、小时数（0 - 23）、分钟、秒以及毫秒数；返回表示日期的毫秒数。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。</li><li><strong>Data.now()</strong> ：返回表示调用这个方法时的日期和时间的毫秒数（可用于分析代码；在不支持它的浏览器中，使用+操作符把Data 对象转换成字符串，也可以达到同样的目的）。</li></ul><blockquote><p>实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Date.parse()。<br><br>如同模仿Date.parse()一样，Date 构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT 来创建。</p></blockquote><h2 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h2><p>将日期格式化为字符串的方法 如下：</p><ul><li><strong>toDateString()</strong> ——以特定于实现的格式显示星期几、月、日和年；</li><li><strong>toTimeString()</strong> ——以特定于实现的格式显示时、分、秒和时区；</li><li><strong>toLocaleDateString()</strong> ——以特定于地区的格式显示星期几、月、日和年；</li><li><strong>toLocaleTimeString()</strong> ——以特定于地区的格式显示时、分、秒；</li><li><strong>toUTCString()</strong> ——以特定于实现的格式完整的UTC 日期。</li></ul><h2 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h2><blockquote><p>UTC 日期指的是在没有时区偏差的情况下（将日期转换为GMT 时间）的日期值</p></blockquote><p>常用方法如下：</p><ul><li><strong>getFullYear()</strong>  ：取得4位数的年份（如2007而非仅07）；</li><li><strong>getMonth()</strong> ： 返回日期中的月份，其中0表示一月，11表示十二月；</li><li><strong>getDate()</strong> ： 返回日期月份中的天数（1到31）；</li><li><strong>getDay()</strong> ： 返回日期中星期的星期几（其中0表示星期日，6表示星期六）；<br><br></li><li><strong>setFullYear(年)</strong> ： 设置日期的年份；</li><li><strong>setMonth(月)</strong> ： 设置日期的月份。传入的月份值必须大于0，超过11则增加年份；</li><li><strong>setDate(日)</strong> ： 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份；</li></ul><p><br><br><br><br><br></p><h1 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h1><ul><li><p>以 <strong>字面量形式</strong> 创建 正则表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>RegExp 构造函数</strong> 创建 正则表达式：<br>它接收两个参数：一个是要匹配的字符串模式（所有元字符都必须 <strong>双重转义</strong>，那<br>些已经转义过的字符也是如此），另一个是可选的标志字符串。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure><p>正则表达式的匹配模式支持下列 3 个标志：</p><ul><li><strong>g</strong> ：表示 <strong>全局</strong>（global）模式；</li><li><strong>i</strong> ：表示 <strong>不区分大小写</strong>（case-insensitive）模式；</li><li><strong>m</strong> ：表示 <strong>多行</strong>（multiline）模式。</li></ul><p>模式中使用的所有元字符都必须转义。正则表达式中的 <strong>元字符</strong> 包括：<br>     ( [ { \ ^ $ | ) ? * + .]} </p><blockquote><p>注意：<br>使用正则表达式字面量和使用RegExp 构造函数创建的正则表达式不一样。<br>在ECMAScript 3 中，正则表达式字面量始终会共享同一个RegExp 实例，<br>而使用构造函数创建的每一个新RegExp 实例都是一个新实例。</p></blockquote><h2 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h2><p>RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p><ul><li>global：布尔值，表示是否设置了g 标志。</li><li>ignoreCase：布尔值，表示是否设置了i 标志。</li><li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0 算起。</li><li>multiline：布尔值，表示是否设置了m 标志。</li><li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。</li></ul><h2 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h2><ul><li><strong>exec()</strong>  ：exec() 接受一个参数，即 要应用模式的字符串，然后返回 <strong>包含第一个匹配项信息的数组</strong>；或者在没有匹配项的情况下返回null。</li></ul><blockquote><p>返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，<strong>index</strong> 表示匹配项在字符串中的位置，而 <strong>input</strong> 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</p></blockquote><ul><li><strong>test()</strong> ：在模式与该参数匹配的情况下返回 true；否则，返回 false。</li></ul><blockquote><p>test() 方法经常被用在 <strong>if 语句</strong> 中</p></blockquote><p><br><br><br><br><br></p><h1 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h1><p>每个函数都是Function 类型的实例，而且都与其他引用类型一样具有属性和方法。<br>由于<strong>函数是对象</strong>，因此 <strong>函数名</strong> 实际上也是一个 <strong>指向函数对象的指针</strong>，不会与某个函数绑定。</p><p>定义函数的方式：</p><ul><li><strong>函数声明</strong></li><li><strong>函数表达式</strong></li><li><strong>使用Function 构造函数</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式定义法</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数定义法</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure><blockquote><p>构造函数定义法 会导致<strong>解析两次代码</strong>（第一次是解析常规ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。</p></blockquote><p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line"><span class="keyword">var</span> anotherSum = sum;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，使用 <strong>不带圆括号的函数名</strong> 是 <strong>访问函数指针</strong>，而非调用函数。</p></blockquote><h2 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h2><p>函数是对象，没有重载，可以将函数名理解为 指针：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure></p><p>上述代码 用 函数表达式 表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure><p>可见，在创建第二个函数时，实际上覆盖了<strong>引用</strong>第一个函数的变量addSomeNumber。</p><h2 id="函数声明-与-函数表达式"><a href="#函数声明-与-函数表达式" class="headerlink" title="函数声明 与 函数表达式"></a>函数声明 与 函数表达式</h2><blockquote><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。<br><strong>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；<br>至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</strong></p></blockquote><p><strong>函数声明提升</strong>（function declaration hoisting）<br>对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。</p><h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>因为 <strong>函数名</strong> 本身就是 <strong>变量</strong>，所以函数也可以 <strong>作为值</strong> 来使用。<br>也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。我们需要一种方式来指明按照哪个属性来排序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line"><span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line"><span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h2><p>在函数内部，有两个特殊的对象：arguments 和 this 。</p><ul><li><strong>arguments</strong> ：类数组对象，包含着传入函数中的所有参数。<br>这个对象还有一个名叫 <strong>callee</strong> 的属性，该属性是一个指针，指向 <strong>拥有这个arguments 对象的函数</strong>。使用arguments.callee，可以消除 递归调用 中的紧密耦合现象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>this</strong> ：this 引用的是 <strong>函数据以执行的环境对象</strong>（当在网页的全局作用域中调用函数时，this 对象引用的就是 window）</li></ul><blockquote><p>请牢记：函数的名字仅仅是一个 <strong>包含指针的变量</strong> 而已</p></blockquote><ul><li><strong>caller</strong> ：保存着 <strong>调用当前函数的函数的引用</strong>，如果是在全局作用域中调用当前函数，它的值为null。</li></ul><h2 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h2><ul><li><strong>length 属性</strong>：表示函数希望接收的 <strong>命名参数的个数</strong>；</li><li><strong>prototype 属性</strong>： 不可枚举；</li></ul><p>以下方法 在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值：</p><ul><li><strong>apply() 方法</strong>：接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象。</li><li><strong>call() 方法</strong>：第一个参数是this 值，其余参数都直接传递给函数（必须逐个列举出来）。</li><li><strong>bind() 方法</strong>：这个方法会创建一个函数的实例，其this 值会被绑定到传给bind()函数的值。</li></ul><blockquote><p>call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。</p></blockquote><p>apply()和call() 能够扩充函数赖以运行的作用域，使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(o); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br></p><h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><p>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p><blockquote><p>引用类型与基本包装类型的主要区别就是 <strong>对象的生存期</strong>。<br>（1）使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。<br>（2）而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p></blockquote><p>三种基本包装类型的共同特征：<br>（1）每个包装类型都 <strong>映射</strong> 到同名的基本类型；<br>（2）在 <strong>读取模式</strong> 下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作（在实例上调用指定的方法）；<br>（3）操作基本类型值的语句一经 <strong>执行完毕</strong>，就会 <strong>立即销毁</strong> 新创建的包装对象。</p><h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;</span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">typeof</span> falseObject); <span class="comment">//object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> falseValue); <span class="comment">//boolean</span></span><br><span class="line">alert(falseObject <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line">alert(falseValue <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><strong>布尔表达式中的所有对象都会被转换为 true</strong>，因此上述代码中，falseObject 对象在布尔表达式中代表的是true。<br>我们的建议是永远不要使用Boolean 对象。</p><h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><ul><li><strong>valueOf() 方法</strong> ：返回对象表示的基本类型的数值；</li><li><strong>toLocaleString() 方法</strong> ：返回字符串形式的数值；</li><li><strong>toString() 方法</strong>： 返回字符串形式的数值（可以为toString()方法传递一个<strong>表示基数</strong>的参数，告诉它返回<strong>几进制数值</strong>的字符串形式）；</li><li><strong>toFixed() 方法</strong> ：会按照指定的小数位返回数值的字符串表示 ；</li><li><strong>toExponential() 方法</strong> ：返回以指数表示法（也称e 表示法）表示的数值的字符串形式；</li><li><strong>toPrecision() 方法</strong> ：可能会返回固定大小（fixed）格式，也可能返回指数<br>（exponential）格式；具体规则是看哪种格式最合适。接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.005</span>;</span><br><span class="line">alert(num.toFixed(<span class="number">2</span>)); <span class="comment">//"10.01"</span></span><br><span class="line"><span class="comment">// 能够 自动舍入 的特性，使得toFixed()方法很适合 处理货币值</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</span><br><span class="line">alert(num.toPrecision(<span class="number">1</span>)); <span class="comment">//"1e+2"</span></span><br><span class="line">alert(num.toPrecision(<span class="number">2</span>)); <span class="comment">//"99"</span></span><br><span class="line">aler t(num.toPrecision(<span class="number">3</span>)); <span class="comment">//"99.0"</span></span><br></pre></td></tr></table></figure><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>String 类型的每个实例都有一个 <strong>length 属性</strong>，表示字符串中包含多个字符。</p><blockquote><p>应该注意的是，即使字符串中包含 <strong>双字节字符</strong>（不是占一个字节的ASCII 字符），每个字符 也仍然 <strong>算一个字符</strong>。</p></blockquote><p>String 类型提供了很多方法，用于辅助完成对ECMAScript 中字符串的解析和操作：</p><ul><li>字符方法<ul><li><strong>charAt()</strong> ：以<strong>单字符字符串</strong>的形式返回给定位置的那个字符</li><li><strong>charCodeAt()</strong> ：以<strong>字符编码</strong>的形式返回给定位置的那个字符</li></ul></li><li>字符串操作方法<ul><li><strong>concat()</strong> ：用于将一或多个字符串拼接起来，返回拼接得到的新字符串。 </li><li><strong>加号操作符（+）</strong></li><li><strong>slice()</strong> </li><li><strong>substr()</strong> </li><li><strong>substring()</strong></li></ul></li><li>字符串位置方法<ul><li><strong>indexOf()</strong> ： 从前往后</li><li><strong>lastIndexOf()</strong> ： 从后往前</li></ul></li><li><strong>trim() 方法</strong> ： 创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果；</li><li>字符串大小写转换方法<ul><li><strong>toLowerCase()</strong></li><li><strong>toUpperCase()</strong></li><li><strong>toLocaleLowerCase()</strong></li><li><strong>toLocaleUpperCase()</strong></li></ul></li><li>字符串的模式匹配方法<ul><li><strong>match()</strong> ：本质上与调用RegExp 的exec()方法相同。</li><li><strong>search()</strong> ：返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。</li><li><strong>replace()</strong> ： 这个方法接受两个参数：第一个参数可以是一个RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。</li><li><strong>split()</strong> ：基于 <strong>指定的分隔符</strong> 将一个字符串分割成多个子字符串，并将结果放在一个<strong>数组</strong>中。分隔符可以是字符串，也可以是一个RegExp 对象（这个方法不会将字符串看成正则表达式）；</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>);</span><br><span class="line">alert(result); <span class="comment">//"cond, bat, sat, fat"</span></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>);</span><br><span class="line">aler t(result); <span class="comment">//"cond, bond, sond, fond"</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>localeCompare() 方法</strong> ：比较两个字符串，并返回下列值中的一个：</p><ul><li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（-1）；</li><li>如果字符串等于字符串参数，则返回 0；</li><li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（1）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>;</span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"brick"</span>)); <span class="comment">//1</span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"yellow"</span>)); <span class="comment">//0</span></span><br><span class="line">alert(stringValue.localeCompare(<span class="string">"zoo"</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>fromCharCode() 方法</strong> ： 接收一或多个字符编码，然后将它们转换成一个字符串。</p></li><li>HTML 方法</li></ul><p><br><br><br><br><br></p><h1 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h1><p>ECMA-262 对内置对象的定义是：“由ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript 程序执行之前就已经存在了。</p><h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><p>事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global 对象的属性。不属于任何其他对象的属性和方法，最终都是它的属性和方法。<br>例如，isNaN()、isFinite()、parseInt() 以及 parseFloat() 等。</p><ul><li>URI 编码方法 ：Global 对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform ResourceIdentifiers，通用资源标识符）进行编码，以便发送给浏览器。<ul><li><strong>encodeURI()</strong>：主要用于整个URI；</li><li><strong>encodeURIComponent()</strong> ：主要用于对URI 中的某一段。</li><li><strong>decodeURI()</strong> ：只能对使用encodeURI()替换的字符进行解码；</li><li><strong>decodeURIComponent()</strong> ：能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。</li></ul></li></ul><blockquote><p>它们的主要区别在于，encodeURI()不会对本身属于URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p><p>一般来说， 我们使用encodeURIComponent() 方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。</p></blockquote><ul><li><strong>eval() 方法</strong> ：<br>通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量；在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。</li><li><strong>Global 对象的属性</strong></li><li><strong>window 对象</strong> ：<br>ECMAScript 虽然没有指出如何直接访问Global 对象，但Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">/* 在没有给函数明确指定this 值的情况下</span></span><br><span class="line"><span class="comment">（无论是通过将函数添加为对象的方法，</span></span><br><span class="line"><span class="comment">还是通过调用call()或apply()），</span></span><br><span class="line"><span class="comment">this值等于Global 对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><p>Math 对象有如下方法：</p><ul><li><strong>min() 方法</strong> ：确定一组数中的最小值；</li><li><strong>max() 方法</strong> ：确定一组数中的最大值；</li></ul><blockquote><p>这两个方法经常用于<br>（1）避免多余的循环；<br>（2）在if 语句中确定一组数的最大/小值。</p></blockquote><p>要找到 <strong>数组</strong> 中的最大或最小值，可以像下面这样使用 apply() 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</span><br><span class="line"><span class="comment">// 关键是把 Math 对象作为apply()的第一个参数，从而正确地设置this 值。</span></span><br></pre></td></tr></table></figure><ul><li><strong>Math.ceil()</strong> ：向上舍入；</li><li><strong>Math.floor()</strong> ：向下舍入；</li><li><strong>Math.round()</strong> ：四舍五入；</li><li><strong>Math.random()</strong> ：返回 <strong>[ 0 , 1 )</strong> 中的一个随机数</li></ul><blockquote><p>利用Math.random()从某个整数范围内随机选择一个值：<br>值 = Math.floor( Math.random() * 可能值的总数 + 第一个可能的值 )</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> choices = upperValue - lowerValue + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = selectFrom(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">alert(num); <span class="comment">// 介于 2 和10 之间（包括 2 和 10）的一个数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用这个函数，可以方便地从数组中随机取出一项</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>, <span class="string">"purple"</span>, <span class="string">"brown"</span>];</span><br><span class="line"><span class="keyword">var</span> color = colors[selectFrom(<span class="number">0</span>, colors.length<span class="number">-1</span>)];</span><br><span class="line">alert(color); <span class="comment">// 可能是数组中包含的任何一个字符串</span></span><br></pre></td></tr></table></figure><p><br><br><br><br><br><br>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;Object-类型&quot;&gt;&lt;a href=&quot;#Object-类型&quot; class=&quot;headerlink&quot; title=&quot;Object 类型&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 变量、作用域和内存问题</title>
    <link href="http://fujiafeng.com/2019/08/08/JavaScript-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>http://fujiafeng.com/2019/08/08/JavaScript-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</id>
    <published>2019-08-08T12:28:03.000Z</published>
    <updated>2019-08-08T14:27:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h1><p>JavaScript采用松散类型变量<br>&emsp;&emsp;<strong>松散类型变量</strong> – 在特定时间用于保存特定值的一个名字，<strong>变量的值</strong> 及其 <strong>数据类型</strong> 可以在脚本的生命周期内改变。</p><p><br></p><p><strong>基本类型值</strong> </p><ul><li>简单的数据段；  </li><li>按值访问；  </li><li>可以操作保存在变量中的实际的值（栈内存，固定大小）；</li></ul><p><br></p><p><strong>引用类型值</strong> </p><ul><li>可能由多个值构成的对象；  </li><li>按引用访问；  </li><li>实际上是在操作对象的引用，而不是实际的对象（堆内存）；</li><li>当复制保存着对象的某个变量时，操作的是对象的引用；在为对象添加属性时，操作的是实际的对象（JS 不允许直接访问内存中的位置）；</li><li>只能给 引用类型值 动态地添加属性。</li></ul><p><br></p><p><strong>复制变量值</strong><br>基本类型值 会在变量对象上 创建一个新值，然后把该值 复制 到为新变量分配的位置上；<br>&emsp;&emsp;引用类型值 也会在变量对象上 创建一个新值，然后把该值 复制 到为新变量分配的位置上，这个值的副本 实际上是一个指针，指向 存储在堆中 的一个对象。<br><br></p><p><strong>传递参数</strong><br>ECMAScript 中，所有函数的参数 都是 <strong>按值传递</strong> 的，被传递的值（基本类型值 / 引用类型值在内存中的地址） 会被复制给一个 局部变量（即命名参数 / arguments对象中的一个元素）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果person 是按引用传递的，那么person 就会自动被修改为指向其name 属性值为"Greg"的新对象。</span></span><br><span class="line"><span class="comment">// 但是，当接下来再访问person.name 时，显示的值仍然是"Nicholas"。</span></span><br><span class="line"><span class="comment">// 这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。</span></span><br></pre></td></tr></table></figure><p><br></p><p><strong>检测类型</strong></p><ul><li><strong>typeof</strong> 操作符 —— 确定一个变量是 字符串、数值、布尔值，还是undefined  的最佳工具；</li><li><strong>instanceof</strong> 操作符 —— 检测是什么类型的对象；</li></ul><p><br><br><br><br><br></p><h1 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h1><p><strong>执行环境</strong> 定义了 变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。</p><ul><li><strong>全局执行环境</strong> —— 最外围的一个执行环境。<br>在Web浏览器中，全局执行环境被认为是window 对象，因此所有全局变量和函数都是作为window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。</li><li><strong>函数执行环境</strong> —— 当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。<br>而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</li></ul><p><br></p><p><strong>作用域链</strong>（scope chain）保证对执行环境有权访问的所有变量和函数的有序访问。</p><ul><li>作用域链的前端，始终都是 <strong>当前执行的代码所在环境的变量对象</strong> 。</li><li><strong>全局执行环境的变量对象</strong> 始终都是作用域链中的最后一个对象。</li></ul><p><strong>标识符解析</strong> 沿着作用域链一级一级地搜索标识符的过程。</p><ul><li>搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。</li><li>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。</li><li>这些环境之间的联系是 <strong>线性、有次序</strong> 的。</li></ul><p><strong>延长作用域链</strong>：<br>&emsp;&emsp;有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。当执行流进入下列任何一个语句时，作用域链就会得到加长：</p><ul><li>try-catch 语句的catch 块；</li><li>with 语句。<br>这两个语句都会在作用域链的前端添加一个变量对象。对with 语句来说，会将指定的对象添加到作用域链中。<br>对catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</li></ul><p><strong>没有块级作用域</strong>：<br>变量声明 —— 使用 var 声明的变量会自动被添加到最接近的环境中；如果初始化变量时没有使用var 声明，该变量会自动被添加到全局环境（严格模式下会报错）。<br>查询标识符 —— 如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。</p><p><br><br><br><br><br></p><h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><p>JavaScript 具有<strong>自动垃圾收集机制</strong>，执行环境会负责管理代码执行过程中使用的内存。所需内存的分配以及无用内存的回收完全实现了自动管理。垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），<strong>周期性</strong> 地找出那些不再继续使用的变量，然后释放其占用的内存。</p><p><strong>垃圾收集方式</strong> ：</p><ul><li><strong>标记清除</strong> （mark-and-sweep）—— 当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li><li><strong>引用计数</strong> （reference counting）—— 跟踪记录每个值被引用的次数。当垃圾收集器运行时，它就会释放那些引用次数为零的值所占用的内存。值得注意的问题是：<strong>循环引用</strong> ，指的是对象A 中包含一个指向对象B 的指针，而对象B 中也包含一个指向对象A 的引用。</li></ul><p><br></p><p><strong>性能问题 &amp; 管理内存</strong> ：<br>&emsp;&emsp;随着IE7 的发布，JavaScript 引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。<br>&emsp;&emsp;而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null 来释放其引用——这个做法叫做 <strong>解除引用</strong> （dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。<br>解除引用的真正作用是 <strong>让值脱离执行环境</strong> ，以便垃圾收集器下次运行时将其回收。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本类型和引用类型的值&quot;&gt;&lt;a href=&quot;#基本类型和引用类型的值&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型的值&quot;&gt;&lt;/a&gt;基本类型和引用类型的值&lt;/h1&gt;&lt;p&gt;JavaScript采用松散类型变量&lt;br&gt;&amp;emsp;&amp;emsp;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://fujiafeng.com/tags/JavaScript/"/>
    
      <category term="JavaScript高级程序设计" scheme="http://fujiafeng.com/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
