[{"title":"NodeJs process 进程模块","url":"/2020/02/14/NodeJs-process-进程模块/"},{"title":"深入解析 process.env.NODE_ENV","url":"/2020/01/16/深入解析-process-env-NODE-ENV/","content":"\n\n### process.env.NODE_ENV\n\n>process 对象是存在 node.js 中的一个**全局变量**，所有模块均可调用。\n\n`NODE_ENV` 不是 `process.env` 的自带属性，而是为了 **区分开发环境（development）与生产环境（production）** 而设置的变量。\n\n#### 设置 NODE_ENV\n\n通过 **cross-env 命令** 来设置环境变量：\n```\ncross-env NODE_ENV=development\n```\n在 scripts 脚本启动命令中设置的 `NODE_ENV` 可通过 `process.env.NODE_ENV` 直接访问（在 `npm run xxx` 执行启动命令时，设置 `NODE_ENV` 变量）。\n\n<br/>\n<br/>\n\n### 配置环境变量的方法\nNode 中常用到的环境变量是 `NODE_ENV`，以此为例：\n\n#### cmd 命令\n\n**Windows 环境**\n```\n# 查看 环境变量 是否存在\nset NODE_ENV\n\n# 若不存在，添加 环境变量\nset NODE_ENV=production\n\n# 环境变量 追加值 set 变量名=%变量名%;变量内容\nset path=%path%;C:\\web;C:\\Tools\n\n# 删除 环境变量\nset NODE_ENV=\n```\n\n**Linux 环境（包括 Mac 环境）**\n```\n# 查看 环境变量 是否存在\necho $NODE_ENV\n\n# 若不存在，添加 环境变量\nexport NODE_ENV=production\n\n# 环境变量 追加值 \nexport path=$path:/home/download:/usr/local/\n\n# 删除 环境变量\nunset NODE_ENV\n\n# 显示所有 环境变量\nenv\n```\n\n>在命令行中设置环境变量后，该环境变量的值是**全局的**（比如，设置 `NODE_ENV` 为 production，则所有项目下 `NODE_ENV` 都是生产环境，此时使用 `npm install `下载依赖包，只会下载 package.json 中 dependencies 配置项中的包依赖包，而不会下载 devDependencies 中的）。\n>因此，我们有时需要 删除设置的环境变量。\n\n<br/>\n\n#### webpack.DefinePlugin() \n\nDefinePlugin 允许我们创建全局变量，可在编译时进行设置。\n```\nnew webpack.DefinePlugin({\n    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV)\n}) \n```\n我们可以在 **webpack.conf.js** 中通过 `webpack.DefinePlugin()` 设置 `process.env.NODE_ENV` ，当 webpack 编译时就会设置该环境变量；同时，我们在 **package.json** 中的 scripts中配置 `NODE_ENV=xxx` ，使项目代码打包时可以设置 `NODE_ENV` 的值：\n```\n\"scripts\": {\n    \"dev\": \"NODE_ENV=production webpack --progress --devtool\"\n}\n```\n\n<br/>\n\n#### cross-env 工具包\n\n`cross-env` 是一个 <u>**跨平台** 地设置及使用 **环境变量**</u> 的工具。\n\n> **跨平台** 指的是：不同平台下，可使用统一的指令。\n> &emsp;&emsp;我们可通过 `cross-env` 跨Win/Linux 平台设置 `process.env`值。\n> \n> 注意：*Windows不支持 `NODE_ENV=development` 这种环境变量设置方式，会报错（阻塞或异常），通过 `cross-env` 我们就能以 Unix方式设置环境变量了。*\n\n<br/>\n\n##### 安装 cross-env\n```\nnpm install --save-dev cross-env\n```\n\n<br/>\n<br/>\n\n#### 同时配置 webpack 和 cross-env\n\n* **cross-env** 设置NODE_ENV **使webpack的配置文件可以获取该值**；\n\n* **webpack配置文件**中设置的NODE_ENV 是为了 **在打包文件中获取该值**。\n\n由此可知，我们需要做的配置如下：\n\n1. 在**package.json**文件中的 `scripts` 脚本中，既要配置环境变量 `cross-env NODE_ENV=XXX`，又要指定对应的 webpack配置文件 `webpack --config /build/webpack.conf.js` ；\n2. 并在**webpack配置文件**中使用 `DefinePlugin()` （或 在webpack4 中可使用 __`mode`__ ）设置打包文件中的环境变量 `NODE_ENV` 。\n\n\n关于 webpack4 的 `mode` 属性，element 源码中设置如下：\n```javascript\n// webpack.demo.js\n\nconst webpackConfig = {\n\n    mode: process.env.NODE_ENV,\n    \n    entry: isProd ? {\n        docs: './examples/entry.js'\n    } : (isPlay ? './examples/play.js' : './examples/entry.js'),\n    \n    output: {\n        path: path.resolve(process.cwd(), './examples/element-ui/'),\n        publicPath: process.env.CI_ENV || '',\n        filename: '[name].[hash:7].js',\n        chunkFilename: isProd ? '[name].[hash:7].js' : '[name].js'\n    },\n    \n    devServer: {\n        host: '0.0.0.0',\n        port: 8085,\n        publicPath: '/',\n        hot: true\n    }\n};\n```\n当我们设置 mode 为 development 或者 production时，webpack会自动的进行一些设置（当然设置了模式以后，webpack会自动的为项目添加一些插件）\n>mode: development --> process.env.NODE_ENV = development\n>&emsp;&emsp;mode: production --> process.env.NODE_ENV = production\n>&emsp;&emsp;默认情况下 --> process.env.NODE_ENV = production\n\n<br/>\n<br/>\n<br/>\n","tags":["源码系列","NodeJs","前端工程化"]},{"title":"深入解析 npm scripts","url":"/2020/01/16/深入解析-npm-scripts/","content":"\n\n>将 打包、部署 等命令都封装到 npm scripts 中，通过运行 `npm run xxx` 命令可以 **执行多个自定义任务**：增加 scripts 中的键值对，然后用一个 **总任务脚本** 将相关键值对用 `&&` 连接起来。\n\n<br/>\n<br/>\n\n### package.json 中的 scripts\n> package.json 中的scripts 执行的脚本是 本地项目的 `/node_modules/.bin` 目录下的脚本。\n>\n>  `npm run` 会 **创建一个Shell**，执行指定的命令，并临时将 `/node_modules/.bin` 加入 **`PATH`** 变量，这意味着 本地模块可以直接运行。\n\n```json\n{\n    ... \n    \"scripts\": {\n        \"serve\": \"vue-cli-service serve\",\n        \"build\": \"vue-cli-service build\",\n        \"lint\": \"vue-cli-service lint\"\n    },\n    ...\n}\n```\n\n前端项目中的 package.json 文件中，<u>scripts 脚本说明</u>：\n\n* 执行 __`npm run <scripts的key>`__ 相当于执行 `<scripts的key对应的value>`\n* `build`，`build:prod`，`build:sit` 分别为 本地环境、生产环境、测试环境 打包\n* `build:doc`  自动生成文档\n\n<u>常用配置信息</u>：\n\n* 【 **`cross-env`** 】跨平台设置及使用环境变量（`npm i --save-dev cross-env`）\n* 【 **`NODE_ENV`** 】/config 下对应环境配置的 NODE_ENV 值\n* 【 **`env_config`** 】/config 下对应环境配置的 env_config 值\n* 【 **`node build/build.js`** 】环境入口文件\n* 【 **`npm-run-all`** 】并行（`--parallel`）/按序（`--sequential`）执行多个脚本\n\n<br/>\n<br/>\n\n### 控制符 && 与 &\n\n* `npm-run-all --parallel` 相当于  `&`  ，并行执行\n* `npm-run-all --sequential` 相当于  `&&` ，串行执行\n\n{% asset_img Image1.png StackOverflow相关讨论 %}\n\n{% asset_img Image2.png StackOverflow相关讨论 %}\n\n<br/>\n<br/>\n\n### webpack-dev-server\n\n* 只能用在 **开发环境**（ `NODE_ENV=development` ）\n* 用于构建 **本地服务器**\n\n详情请见：深入解析 webpack-dev-server\n\n<br/>\n<br/>\n\n### scripts 命令的hook\n每个命令都有对应的 pre<scriptname>脚本 和 post<scriptname>脚本，显示定义时，会执行对应的 pre/post命令：\n```json\nscripts: {\n  \"prebuild\" : \"echo \\\" this is pre build \\\"\",\n  \"build\" : \"echo \\\" this is build \\\"\",\n  \"postbuild\" : \"echo \\\" this is post build \\\"\"\n}\n```\n执行 `npm run build` 会依次执行 prebuild、build、postbuild 三个命令。\n\nnpm默认提供如下钩子：\n\n* prepublish, postpublish\n* preinstall, postinstall\n* preuninstall, postuninstall\n* preversion, postversion\n* pretest, posttest\n* prestop, poststop\n* prestart, poststart\n* prerestart, postrestart\n\n自定义脚本命令 也可以添加钩子：**pre**myscript, myscript, **post**myscript 。\n\n<br/>\n<br/>\n\n### npm命令简写\n\n* npm start === npm run start\n* npm stop === npm run stop\n* npm test === npm run test\n* npm restart === npm run restart\n\n<br/>\n<br/>\n\n### ElementUI 源码中的scripts\n\n详情请见： ElementUI 源码分析 - package.json配置\n\n\n<br/>\n<br/>\n<br/>\n","tags":["NodeJs","npm","前端工程化"]},{"title":"ElementUI 源码分析 - 目录结构","url":"/2020/01/16/ElementUI-源码分析-目录结构/","content":"\n\n### 概览\nElementUI 的目录结构大致如下：\n{% asset_img element-content.png element目录结构 %}\n\n将项目 clone 下来之后，执行打包命令 生成 `/lib`  目录：\n```\nnpm run dist\n```\n该命令依次执行了以下脚本：\n```\nwebpack --config build/webpack.conf.js &&\nwebpack --config build/webpack.common.js &&\nwebpack --config build/webpack.component.js &&\n```\n其中，webpack.conf.js 与 webpack.common.js 打包的入口文件都是 `src/index.js` ，输出文件都在 `/lib` 目录，分别是 **UMD规范** 和 **commonjs规范** ；webpack.component.js 入口文件为 components.json 中的所有组件，即 `/packages` 目录下的所有组件。\n\n<br/>\n<br/>\n<br/>\n\n### 入口文件 src/index.js\nsrc 下的入口文件index.js 实现的功能：\n\n* 国际化配置\n* 组件全局注册\n* 在 prototype 上挂载共用方法\n{% asset_img srcIndex.png element入口文件 %}\n\n<br/>\n<br/>\n<br/>\n\n### 自定义指令 src/directives\n主要实现了两种功能：\n\n1. **鼠标滚轮事件 mousewheel.js** ： 应用在 table组件 中（如：固定表头、流体高度）。（[参考链接](https://github.com/basilfx/normalize-wheel) ）\n2. **函数防抖 repeat-click.js** ：主要用在 InputNumber 计数器中，控制用户点击频率。\n{% asset_img srcDirectives.png element自定义指令 %}\n\n<br/>\n<br/>\n<br/>\n\n### 混用 src/mixins\n\n1. **emitter.js**\n（1）broadcast 函数：广播 （父 -> 子）；\n（2）dispatch 函数：分发（子 -> 父）\n组件中添加 自定义属性‘componentName’\n\n2. **focus.js**\n使 DOM 元素获取焦点。\n```javascript\nexport default function(ref) {\n    return {\n        methods: {\n            focus() {\n                this.$refs[ref].focus();\n            }\n        }\n    }\n} \n```\n\n3. **locale.js**\n国际化输出。\n\n4. **migrating.js**\n在浏览器控制台 输出 elementUI 已经移除的一些属性。\n\n{% asset_img srcMixins.png element混用 %}\n\n<br/>\n<br/>\n<br/>\n\n### 通用库 utils\n\n1. **clickoutside.js** \n点击元素外面 才会触发的事件\n2. **date.js** \n日期格式化\n3. **dom.js**\n对 DOM元素 进行操作，如 `hasClass`, `addClass`, `removeClass`, `getStyle`, `setStyle`, `on`, `off` 等。\n4. **util.js**\n定义一些常用函数：`hasOwn`, `getValueByPath`, `valueEquals` 。\n5. **vdom.js**\nvnode 判断，vnode获取。\n\n<br/>\n<br/>\n<br/>\n","tags":["elementUI","源码系列"]},{"title":"NodeJs path 路径模块","url":"/2020/01/16/NodeJs-path-路径模块/","content":"\n\n### path.dirname( path )\n返回 path 的**目录名**，尾部的目录分隔符将被忽略。\n\n```javascript\npath.dirname('/foo/bar/baz/asdf/quux');\n// 返回 '/foo/bar/baz/asdf'\n```\n\n<br/>\n<br/>\n<br/>\n\n### path.basename( path[, ext] )\n获取 `path` 的**最后一部分**，尾部的 目录分隔符 将被忽略。\n\n```javascript\npath.basename('/foo/bar/baz/asdf/quux.html');\n// 返回 'quux.html'\n\npath.basename('/foo/bar/baz/asdf/quux.html', '.html');\n// 返回 'quux'\n```\n\n<br/>\n<br/>\n<br/>\n\n### path.extname( path )\n返回 path 的**扩展名**（从最后一个 `.` 字符到 `path` 最后一部分的字符串结束）；若 `path` 的最后一部分中没有 `.` 字符，或者 path 的基本名称除了第一个字符以外没有 `.` 字符，则返回 空字符串。\n\n```javascript\npath.extname('.index');\n// 返回 ''\n```\n\n<br/>\n<br/>\n<br/>\n\n### path.format( pathObject )\n从对象返回路径字符串。与 `path.parse()` 相反。\n\n>pathObject <Object> = {\n>&emsp;&emsp;&emsp;&emsp;    dir: <string>,\n>&emsp;&emsp;&emsp;&emsp;    root: <string>,\n>&emsp;&emsp;&emsp;&emsp;    base: <string>,\n>&emsp;&emsp;&emsp;&emsp;    name: <string>,\n>&emsp;&emsp;&emsp;&emsp;    ext: <string>\n>&emsp;&emsp;}\n\npathObject 属性优先级：\n\n* 提供了 `pathObject.dir` ，则忽略 `pathObject.root` 。\n* 提供了 `pathObject.base`，则忽略 `pathObject.ext` 和 `pathObject.name` 。\n\n```javascript\n// 如果提供了 `dir`、 `root` 和 `base`，\n// 则返回 `${dir}${path.sep}${base}`。\n// `root` 会被忽略。\npath.format({\n  root: '/ignored',\n  dir: '/home/user/dir',\n  base: 'file.txt'\n});\n// 返回: '/home/user/dir/file.txt'\n\n\n// 如果未指定 `dir`，则使用 `root`。 \n// 如果只提供 `root`，或 'dir` 等于 `root`，则将不包括平台分隔符。 \n// `ext` 将被忽略。\npath.format({\n  root: '/',\n  base: 'file.txt',\n  ext: 'ignored'\n});\n// 返回: '/file.txt'\n\n\n// 如果未指定 `base`，则使用 `name` + `ext`。\npath.format({\n  root: '/',\n  name: 'file',\n  ext: '.txt'\n});\n// 返回: '/file.txt'\n```\n\n<br/>\n<br/>\n<br/>\n\n### path.parse( path )\n返回一个对象，其属性表示 path 的重要元素。忽略 尾部的目录分隔符。\n```javascript\npath.parse('/home/user/dir/file.txt');\n// 返回:\n// { root: '/',\n//   dir: '/home/user/dir',\n//   base: 'file.txt',\n//   ext: '.txt',\n//   name: 'file' }\n```\n\n<br/>\n<br/>\n<br/>\n\n### path.isAbsolute( path )\n检测 path 是否为**绝对路径**。零长度字符串 返回 false。\n```javascript\npath.isAbsolute('.');   //  false\n```\n\n<br/>\n<br/>\n<br/>\n\n### path.relative( from, to )\n根据当前工作目录，返回 **`from` 到 `to` 的相对路径**。\n\n如果 `from` 和 `to` 各自解析到相同的路径（分别调用 `path.resolve()` 之后），则返回零长度的字符串。\n\n如果将零长度的字符串 传入 `from` 或 `to` ，则使用 当前工作目录 代替该零长度的字符串。\n\n```javascript\npath.relative('/fruit/orange/type1/a', '/fruit/orange/type2/b');\n// 返回 '.. / .. / type2 / b'\n```\n\n<br/>\n<br/>\n<br/>\n\n### path.resolve( [...paths] )\n将 路径 或 路径片段 的序列，解析为**绝对路径**。\n\n* 给定的路径序列 从右到左 进行处理，每个后续的 path 前置，直到构造出一个绝对路径。\n* 若在处理完所有给定的 path 片段之后 还未生成绝对路径，则再加上 当前工作目录。\n* 生成的路径 已经规范化；除非将路径解析为 根目录，否则将删除尾部斜杠。\n* 零长度的 path 片段会被忽略。\n* 未传入 path 片段，则 `path.resolve()` 将返回 当**前工作目录的绝对路径**。\n\n```javascript\npath.resolve('/foo/bar', './baz');\n// 返回 '/foo/bar/baz'\n\npath.resolve('/foo/bar', '/tmp/file/');\n// 返回 '/tmp/file'\n\npath.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');\n// 如果当前工作目录是 /home/myself/node,\n// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif'\n```\n>path.resolve() 类似于对路径执行 `cd` 操作，不同的是，`resolve()` 的 `path` 可以是文件，且不必是真实存在的路径 （ __`resolve()` 方法不会利用 底层文件系统 判断路径是否存在，只是进行 路径字符串操作__ ）\n\n<br/>\n<br/>\n<br/>\n\n### path.join( [...paths] )\n使用 **平台特定分隔符** 作为 界定符，将所有给定的 path 片段连接在一起，规范化生成的路径。\n\n* 零长度的 path 片段会被忽略。\n* 如果连接的路径字符串是零长度的字符串，则返回 `'.'` ，表示 当前工作目录。\n\n<br/>\n<br/>\n<br/>\n\n### path.sep\n提供平台特定的 路径片段分隔符：\n\n* Windows 上是 ` \\ ` 。\n* POSIX 上是 ` /`  。\n\n>在Windows 上，正斜杠（` / `）和反斜杠（` \\ `）都被接受为 路径片段分隔符，但 path 方法只添加反斜杠（` \\ `）。\n\n<br/>\n<br/>\n<br/>\n\n### path.normalize( path )\n规范化给定的 path，**解析 `'..'` 和 `'.'` 片段**。\n\n当找到多个连续的 **路径片段分隔字符**（如 POSIX上的 `/ `，Windows上的 `\\ `或 `/ `），则它们将被替换为 单个 平台特定的路径段分隔符（POSIX上的 `/ `，Windows上的 `\\ `）。保留 尾部的分隔符。\n\n<br/>\n<br/>\n<br/>\n\n### path.toNamespacedPath( path )\n仅在 Windows 系统上，返回给定 `path` 的等效 **名称空间前缀路径** 。\n\n如果 `path` 不是字符串，则将返回 `path` 而不进行修改。\n\n<br/>\n<br/>\n<br/>\n\n### path.delimiter\n提供平台特定的 **路径界定符**：\n\n*  __`; `__ 用于 Windows\n*  __`: `__ 用于 POSIX\n\n<br/>\n<br/>\n<br/>\n\n### path.posix\n提供对 path 方法的 POSIX 特定实现的访问。\n\n<br/>\n<br/>\n<br/>\n\n### path.win32\n提供对特定于 Windows 的 `path` 方法实现的访问。\n\n<br/>\n<br/>\n<br/>\n\n\n* * *\n### 补充\n#### path.resolve() 与 path.join() 对比\n\n{% asset_img path_resolve_1.png path_resolve_1 %}\n运行结果如下：\n\n{% asset_img path_resolve_2.png path_resolve_2 %}\n\n<br/>\n\n#### 内置全局变量 \\_\\_dirname、\\_\\_filename\n\n*  `__dirname` 当前脚本文件 <u>**所在目录**</u> 的**绝对路径**（被执行的 js文件所在文件夹的绝对路径）\n*   `__filename` 当前执行**脚本文件** 的**绝对路径**\n\n<br/>\n\n#### Node.js 中的几种文件路径\n\n* `__dirname` \n* `__filename`\n* `module.filename === __filename`\n* `process.cwd()`  运行当前脚本的 **工作目录的路径**（即 node命令路径）\n* `process.chdir()`  改变工作目录\n* `./ ` 当前工作路径（node命令路径）\n\n\n{% asset_img path_1.png path_1 %}\n上述代码运行结果如下：\n\n{% asset_img path_2.png path_2 %}\n\n\n\n>注意：\n>\n>（1）在 `require()` 中使用 `./ ` 和 `../ ` 时，` '.' ` 指的是 当前脚本文件的 **相对路径**。（即 请求路径是相对于当前执行文件的目录的，`./ ` 指的是<u>同级目录</u>下的相对路径， `../ ` 指的是<u>上级目录</u>下的相对路径）\n>\n>（2）除了在 `require()` 中使用 **相对路径** 的写法，其他地方均使用 **绝对路径** ，如下所示：\n```javascript\nconst path = require('path');\n\n// 当前目录\npath.dirname(__filename) + '/demo.js';\n\n// 相邻目录\npath.resolve( __dirname, '../siblings/subfile.js' );\n\n// 根据绝对路径读取文件\nconst fs = require('fs');\nconst data = fs.readFileSync( path.resolve(__dirname, './demo.js') );\n```\n\n<br/>\n<br/>\n<br/>\n","tags":["NodeJs"]},{"title":"NodeJs 阻塞调用与非阻塞调用","url":"/2020/01/16/NodeJs-阻塞调用与非阻塞调用/","content":"\n\n### 阻塞\n\n阻塞：在Node.js 程序中，其他 JavaScript语句的执行，必须等待一个 非JavaScript 操作（如 I/O）的完成。\n>当阻塞发生时，事件循环 无法继续运行 JavaScript。\n\n在 Node.js 标准库中的所有 I/O 方法都提供 异步版本（非阻塞），并接受回调函数；某些方法提供对应的 阻塞版本，名称以 `Sync` 结尾。\n\n<br/>\n<br/>\n<br/>\n\n### 代码对比\n\n**阻塞**方法 - **同步**执行；\n**非阻塞**方法 - **异步**执行。\n\n```javascript\nconst fs = require('fs');\n\n// 同步 文件读取（阻塞 其它js 语句的执行，直到整个文件读取完毕）\nconst data = fs.readFileSync('/file.md');\n\n// 异步 文件读取（提高吞吐量）\nfs.readFile('/file.md', (err, data) => {\n  if (err) throw err;\n});\n```\n\n<br/>\n<br/>\n<br/>\n\n### 并发 & 吞吐量\n\n在 Node.js 中 JavaScript 的执行是 **单线程** 的，因此，**并发性** 是指 <u>事件循环在完成其他工作后 执行 JavaScript回调函数的能力</u>。\n\n>混合 阻塞和非阻塞代码，可能导致执行顺序错误。\n\n<br/>\n\n参考链接： \n\n* nodejs核心库（跨平台事件库）  [libuv](https://libuv.org/)\n\n<br/>\n<br/>\n<br/>\n\n","tags":["NodeJs"]},{"title":"《我们之间的距离》","url":"/2020/01/14/《我们之间的距离》/","content":"\n\n“ 每个人都不能孤立于社会，在我们的生命里，有些人有些事的出现，不是为了让你陷入绝望，而是要推你向前，遇见更好的自己。\n{% asset_img bookPic.jpg 我们之间的距离 %}\n\n_\\#抄句子\\#_\n\n>1. **总是会有一段乐曲来标志一段相遇。**\n\n>2. 一群快乐的疯子，我才应该给他们鼓掌，拥抱他们，我想告诉他们，我在他们身上感受到的关怀让我可以承受这一切痛苦。\n\n>3. 虚伪的人是最糟糕的。\n\n>4. 生活中的偏见无处不在。\n\n>5. 我喜欢观察周围的生活。曾经有段时间，在离这里不远的地方，晚上我会去超市散步。在那里可以遇见各种各样的人，大学生、夜班工人，还有很多上了年纪的人去那里排遣寂寞。\n\n>6. “我是录有声书的。只出声，不出镜，跟默片正好相反，但我觉得这份工作挺有诗意的，不是吗？”\n\n>7. 客厅里的灯光弱下来，天色变暗了。窗户开着，能听到风吹过树木发出的沙沙声。\n\n>8. 只要他想到我，我就存在。\n\n>9. 准备去水池旁边散散步，看看路人，想象他们的生活，这是他的乐趣之一，也是他开发应用的灵感来源。\n\n>10. **我说离开家的时候什么都没有失去，这是谎话。因为我在那里抛弃了一部分自己，这份骄傲让我付出了代价，直到现在我还会因此受苦。**\n\n>11. 太多人因为不同的原因错过了彼此，为了获得幸福冒冒险又何妨？\n\n>12. 观察，但不评论。\n\n>13. 一段爱情故事的开始总是非常纠结。恋人们处于恐慌中，犹豫着要不要告诉对方自己的思念之情。什么都想给对方，但是又不愿前进一步。恋人们对幸福精打细算，想存起来，慢慢享用。刚刚诞生的爱情疯狂又脆弱。\n\n>12. 我明白跟失去的双腿相比，**我更需要的是温柔**。\n\n>13. 某一天，当我在孟买的街上散步时，我们会呼吸同样的空气，我知道光是这样就会让我幸福。谁知道呢？也许我们会再次在公园里相遇。无尽的温柔。\n\n>14. 当人生触及最低谷时，生活会给我们准备一份意外的惊喜。","tags":["读书"]},{"title":"Docker 入门","url":"/2020/01/09/Docker-入门/","content":"\n\n\n### 什么是 Docker\n\n>**虚拟化**：在硬件性能过剩的前提下，为不同应用提供某个级别的 **运行环境隔离**。（虚拟机是 硬件虚拟化，容器是 操作系统虚拟化）\n>\n>**微服务** 带来的两个问题：\n>（1）微服务拆分，使需要 **打包、测试、上线** 的量级信息大量增加；\n>（2）进行 **服务器扩容**，需要对 **环境初始化**，使其与原先的环境一致，部署工作繁重。\n\n**容器** 完全使用 **沙箱机制**，相互之间不会有任何接口（类似 iPhone 的 app），性能开销极低。\n\nDocker 是一个开源的 **应用容器引擎**：\n\n* 可以让开发者打包他们的应用以及依赖包到一个 <u>*轻量级、可移植的容器*</u> 中，然后发布到任何流行的 Linux 机器上；\n* 也可以实现 *<u>虚拟化</u>*。\n\n>**Docker** \n>（1）解决了 应用程序 **运行时隔离** 的问题；\n>（2）Docker镜像 解决了 DevOps中 微服务运行的环境 难以在本地环境、测试环境及线上环境保持一致的问题（ **运行环境迁移** 问题）。\n>Docker 镜像可以打包： <u>应用程序 及其所有依赖</u>、**<u>整个操作系统</u>**。\n\n\n\n**应用场景**：\n\n* Web 应用的自动化打包和发布。\n* 自动化测试和持续集成、发布。\n* 在服务型环境中部署和调整数据库或其他的后台应用。\n* 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。\n\n<br/>\n<br/>\n<br/>\n\n### Docker 架构\n三个基本概念：\n\n* **镜像**（Image）：相当于一个 root 文件系统；\n* **容器**（Container）：镜像运行时的实体，可以被创建、启动、停止、删除、暂停等；\n* **仓库**（Repository）：代码控制中心，用来保存镜像。\n\n\nDocker 使用 **客户端-服务器(C/S)架构模式**，使用远程API 来管理和创建Docker 容器。\n\nDocker 容器通过 Docker 镜像来创建。\n\n>镜像和容器的关系，类似于面向对象编程中的类与对象，镜像是静态的定义。\n\n<br/>\n<br/>\n<br/>\n\n### Win10系统 Docker 安装\n\n#### 开启 Hyper-v\n\nWindows【开始菜单】 -> 右键菜单，选择【应用和功能】-> 相关设置，点击【程序和功能】-> 左侧菜单，点击【启用或关闭 Windows 功能】-> 选中 Hyper-v，点击【确定】\n\n<br/>\n\n#### 安装 Toolbox\n\n最新版 Toolbox 下载地址： [Docker 官方下载](https://www.docker.com/get-docker)\n\n点击【Download Desktop and Take a Tutorial】，下载Windows相应版本。\n{% asset_img docker_download.png docker_download %}\n\n<br/>\n\n#### 运行安装文件\n\n安装时，勾选 <u>使用 Windows容器</u>：\n{% asset_img docker_install.png docker_install %}\n\n安装完成后，查看版本信息：\n\n{% asset_img docker_version.png docker_version %}\n\n<br/>\n\n#### 镜像加速\n在 【Settings -> Daemon -> Registry mirrors】中填写 镜像加速地址：\n{% asset_img docker_speed.png docker_speed %}\n\n\n参考可用的地址：\n\n```javascript\nhttps://dockerhub.azk8s.cn        #Azure 中国镜像 \nhttps://reg-mirror.qiniu.com      #七牛云加速器 \nhttps://registry.docker-cn.com　　 #Docker中国区\nhttp://hub-mirror.c.163.com　　　　 #网易\nhttps://docker.mirrors.ustc.edu.cn       #USTC\n```\n\n<br/>\n\n#### 修改镜像文件存储地址\n\n执行 `docker info` 查看Docker 系统信息：\n{% asset_img docker_info.png docker_info %}\n\nWindows 系统默认的镜像地址是 `C:\\ProgramData\\Docker` ，由于Docker 使用过程中可能会拉取很多镜像文件，建议将Docker 的镜像文件存储地址修改到其他盘。\n\n\n##### 通过Docker GUI 界面修改\n在 【Settings -> Daemon】中勾选【Advanced】选项，添加 **graph属性** 配置自定义路径：\n{% asset_img docker_graph.png docker_graph %}\n\n\n配置后点击【Apply】Docker 将自动重启，再查看 `Root Dir` 显示如下：\n{% asset_img docker_info_changed.png docker_info_changed %}\n\n\n##### 使用 命令行 修改\n\n停止运行 Docker：\n```\n$ systemctl stop docker\n```\n修改 daemon.json 文件，添加 graph属性配置：\n```\n$ vi /etc/docker/daemon.json\n```\n\n>Windows 上配置文件的默认位置： `%programdata%\\docker\\config\\daemon.json`\n","tags":["Docker"]},{"title":"Vuex 简介","url":"/2020/01/06/Vuex-简介/","content":"\n\n[Vuex 官方文档](https://vuex.vuejs.org/zh/)\n\n<br/>\n\n### Vuex是什么\nVuex 是一个专为 Vue.js 应用程序开发的 **状态管理模式** 。它采用 **集中式存储** 管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n{% asset_img vuex.png vuex状态管理 %}\n\n\n每一个 Vuex 应用的核心就是 **store（仓库）**。“store”基本上就是一个容器，它包含着你的应用中大部分的 **状态 (state)** 。\n\nVuex 和单纯的全局对象有以下两点不同：\n\n1. Vuex 的状态存储是 **响应式** 的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地 **提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n\n由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要**在计算属性中返回**即可。触发变化也仅仅是**在组件的 methods 中提交 mutation**。\n\n<br/>\n<br/>\n<br/>\n\n### 核心概念\n\n#### State\n##### 单一状态树\n用一个对象就包含了全部的应用层级状态，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。\n\n##### 在Vue 组件中获取Vuex 状态\nVuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：\n```javascript\nconst app = new Vue({\n    el: '#app',\n    // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n    store,\n    components: { Counter },\n    template: `\n      <div class=\"app\">\n        <counter></counter>\n      </div>\n    `\n  })\n```\n通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 `this.$store` 访问到：\n```javascript\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n\n##### mapState 辅助函数\n当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性：\n```javascript\n// 在单独构建的版本中辅助函数为 \n// Vuex.mapStateimport { mapState } from 'vuex'\n\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组：\n```javascript\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'])\n```\n\n##### 对象展开运算符\nmapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用？\n```javascript\ncomputed: {\n  localComputed () { /* ... */ },\n  // 使用对象展开运算符将此对象混入到外部对象中\n  ...mapState({\n    // ...\n  })\n}\n```\n##### 组件仍保有 局部状态\n\n<br/>\n\n#### Getter\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\nGetter 接受 state 作为其第一个参数：\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }}\n)\n```\n\n##### 通过属性访问\n\nGetter 也可以接受其他 getter 作为第二个参数：\n```javascript\ngetters: {\n  // ...\n  doneTodosCount: (state, getters) => {\n    return getters.doneTodos.length\n  }\n}\n\n\nstore.getters.doneTodosCount // -> 1\n```\n我们可以在任何组件中使用它：\n```javascript\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }}\n```\n注意，getter 在通过属性访问时是**作为Vue 的响应式系统的一部分缓存其中** 的。\n\n##### 通过方法访问\n你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用：\n```javascript\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n```\n```javascript\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n注意，getter 在通过方法访问时，**每次都会去进行调用，而不会缓存结果**。\n\n##### mapGetters 辅助函数\n将 store 中的 getter 映射到局部计算属性：\n```javascript\nimport { mapGetters } from 'vuex'\n\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n```\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n```javascript\nmapGetters({\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```\n\n<br/>\n\n#### Mutation\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)** 。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 __`store.commit`__ 方法：\n```javascript\nstore.commit('increment')\n```\n\n##### 提交载荷（Payload）\n你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：\n```javascript\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n```\n```javascript\nstore.commit('increment', 10)\n```\n在大多数情况下，载荷应该是一个**对象**，这样可以**包含多个字段**并且记录的 mutation 会更易读：\n```javascript\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n```javascript\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n##### 对象风格的提交方式\n提交 mutation 的另一种方式是直接使用包含 type 属性的对象：\n```javascript\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：\n```javascript\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n##### Mutation 需遵守Vue 的响应规则\n Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：\n\n1.  最好提前在 store 中**初始化**好所有所需属性。\n2.  当需要在对象上添加新属性时，你应该\n    * 使用 Vue.set(obj, 'newProp', 123), 或者\n    * 以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：\n```javascript\nstate.obj = { ...state.obj, newProp: 123 }\n```\n\n##### 使用常量替代Mutation 事件类型\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n```javascript\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n```javascript\n// store.js\nimport Vuex from 'vuex'import { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n##### Mutation 必须是同步函数\n\n##### 在组件中提交Mutation\n你可以在组件中使用 `this.$store.commit('xxx')` 提交 mutation，或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用（需要在根节点注入 `store`）：\n```javascript\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }}\n```\n\n<br/>\n\n#### Action\nAction 类似于 mutation，不同在于：\n\n* Action 提交的是 mutation，而不是直接变更状态。\n* Action 可以包含任意 **异步**操作。\n\n```javascript\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n```\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。\n\n\n实践中，我们会经常用到 ES2015 的 **参数解构** 来简化代码（特别是我们需要调用 commit 很多次的时候）：\n```javascript\nactions: {\n  increment ({ commit }) {\n    commit('increment')\n  }}\n```\n\n##### 分发 Action\nAction 通过 __`store.dispatch`__ 方法触发：\n```javascript\nstore.dispatch('increment')\n```\n可以在 action 内部执行 **异步操作**：\n```javascript\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }}\n```\nActions 支持同样的 **载荷方式** 和 **对象方式** 进行分发：\n```javascript\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n购物车示例，涉及到 **调用异步 API** 和 **分发多重 mutation**：\n```javascript\nactions: {\n  checkout ({ commit, state }, products) {\n    // 把当前购物车的物品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发出结账请求，然后乐观地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接受一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () => commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n```\n\n##### 在组件中分发 Action\n在组件中使用 `this.$store.dispatch('xxx')` 分发 action，或者使用 __`mapActions`__  辅助函数将组件的 methods 映射为 `store.dispatch` 调用（需要先在根节点注入 `store`）：\n```javascript\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }}\n```\n\n##### 组合 Action\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？如何才能组合多个 action，以处理更加复杂的异步流程？\n\n`store.dispatch` 可以处理被触发的 action 的处理函数返回的 Promise，并且 `store.dispatch` 仍旧返回 Promise：\n```javascript\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }}\n```\n```javascript\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n在另外一个 action 中也可以：\n```javascript\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }}\n```\n\n利用 **async / await**，我们可以如下组合 action：\n```javascript\n// 假设 getData() 和 getOtherData() 返回的是 Promise\n\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }}\n```\n\n>一个 store.dispatch 在不同模块中可以**触发多个 action 函数**。在这种情况下，只有当**所有**触发函数**完成后**，返回的 **Promise 才会执行**。\n\n<br/>\n\n#### Module\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n为了解决以上问题，Vuex 允许我们**将store 分割成模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n```javascript\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n##### 模块的局部状态\n对于模块内部的 mutation 和 getter，接收的第一个参数是 **模块的局部状态对象**：\n```javascript\nconst moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }}\n```\n同样，对于模块内部的 action，局部状态通过 `context.state` 暴露出来，根节点状态则为 `context.rootState`：\n```javascript\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }}\n```\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n```javascript\nconst moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n##### 命名空间\n**默认**情况下，模块内部的 action、mutation 和 getter 是注册在**全局**命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n \n如果希望你的模块具有更高的封装度和复用性，你可以通过添加 __`namespaced: true`__ 的方式使其成为 **带命名空间的模块**。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名：\n```javascript\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。\n\n###### 在 带命名空间的模块内 访问全局内容（Global Assets）\n\n* 如果你希望使用全局 state 和 getter，`rootState` 和 `rootGetters` 会作为第三和第四参数传入 getter，也会通过 `context` 对象的属性传入 action。\n\n* 若需要在全局命名空间内分发 action 或提交 mutation，将 `{ root: true }` 作为第三参数传给 `dispatch` 或 `commit` 即可。\n```javascript\nmodules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n###### 在 带命名空间的模块 注册全局action\n若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中：\n```javascript\n{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch('someAction')\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> 'someAction'\n        }\n      }\n    }\n  }\n}\n```\n###### 带命名空间的绑定函数\n当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：\n```javascript\ncomputed: {\n  ...mapState({\n    a: state => state.some.nested.module.a,\n    b: state => state.some.nested.module.b\n  })},\nmethods: {\n  ...mapActions([\n    'some/nested/module/foo', // -> this['some/nested/module/foo']()\n    'some/nested/module/bar' // -> this['some/nested/module/bar']()\n  ])}\n```\n对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文：\n```javascript\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])}\n```\n可以通过使用 **createNamespacedHelpers** 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：\n```javascript\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }}\n```\n\n##### 模块动态注册\n在 store 创建 **之后**，你可以使用 `store.registerModule` 方法注册模块：\n```javascript\n// 注册模块 `myModule`\nstore.registerModule('myModule', {\n  // ...\n})// 注册嵌套模块 `nested/myModule`\nstore.registerModule(['nested', 'myModule'], {\n  // ...\n})\n```\n之后就可以通过 `store.state.myModule` 和 `store.state.nested.myModule` 访问模块的状态。\n\n* 模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，`vuex-router-sync` 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。\n* 可以使用 `store.unregisterModule(moduleName)` 来**动态卸载模块**。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。\n* 在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 preserveState 选项将其归档：`store.registerModule('a', module, { preserveState: true })`。\n* 当你设置 `preserveState: true` 时，该模块会被注册，action、mutation 和 getter 会被添加到 store 中，但是 state 不会。这里假设 store 的 state 已经包含了这个 module 的 state 并且你不希望将其覆写。\n\n##### 模块重用\n有时我们可能需要创建一个模块的多个实例，例如：\n\n* 创建多个 store，他们公用同一个模块 (例如当 runInNewContext 选项是 false 或 'once' 时，为了在服务端渲染中避免有状态的单例)\n* 在一个 store 中多次注册同一个模块\n\n\n使用一个函数来声明模块状态（仅 2.3.0+ 支持）：\n```JavaScript\nconst MyReusableModule = {\n  state () {\n    return {\n      foo: 'bar'\n    }\n  },\n  // mutation, action 和 getter 等等...}\n```\n\n<br/>\n<br/>\n<br/>\n\n### 项目结构\n\n一些需要遵守的规则：\n\n* 应用层级的状态应该集中到单个 store 对象中。\n* 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。\n* 异步逻辑都应该封装到 action 里面。\n\n<br/>\n<br/>\n<br/>\n\n### 表单处理\n\n严格模式中，表单元素使用 v-modal 可能导致错误：\n```html\n<input v-model=\"obj.message\">\n```\n假设 obj 是在计算属性中返回的 Vuex store的对象，则有两种解决方案：\n\n<br/>\n\n#### 用 `:value` 和 `@input/@change` 替代 `v-modal`\n给 `<input>` 中绑定 `value`，然后侦听 `input` 或 `change` 事件，在事件回调中调用 action ：\n```html\n<input :value=\"message\" @input=\"updateMessage\">\n```\n\n```javascript\n// ...\ncomputed: {\n  ...mapState({\n    message: state => state.obj.message\n  })\n},\nmethods: {\n  updateMessage (e) {\n    this.$store.commit('updateMessage', e.target.value)\n  }\n}\n```\n\n```javascript\n// vuex 的 mutation 函数...\nmutations: {\n  updateMessage (state, message) {\n    state.obj.message = message\n  }\n}\n```\n\n<br/>\n\n#### 双向绑定 计算属性\n使用带有 `setter` 的双向绑定计算属性：\n```html\n<input v-model=\"message\">\n```\n\n```javascript\n// ...\ncomputed: {\n  message: {\n    get () {\n      return this.$store.state.obj.message\n    },\n    set (value) {\n      this.$store.commit('updateMessage', value)\n    }\n  }\n}\n```\n\n<br/>\n<br/>\n<br/>\n","tags":["JavaScript","Vue"]},{"title":"JavaScript 面向对象的程序设计","url":"/2020/01/05/JavaScript-面向对象的程序设计/","content":"\n\n### 理解对象\n\n#### 属性类型\n**特性**：为了实现JavaScript 引擎的，只有内部才用的特性（attribute），描述了属性（property）的各种特征。\n\n* 在JavaScript 中不能直接访问它们。\n* 放在两对儿方括号中，例如[[Enumerable]]。\n\nECMAScript 中有两种 **属性**：<u>**数据属性**</u> 和 <u>**访问器属性**</u>。\n\n##### 数据属性\n包含 **一个数据值的位置**。在这个位置可以读取和写入值。数据属性有4 个描述其行为的特性：\n\n* **[[Configurable]]** ：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。\n* **[[Enumerable]]** ：表示能否通过for-in 循环返回属性。\n* **[[Writable]]** ：表示能否修改属性的值。\n* **[[Value]]** ：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为 undefined。\n\n<u>**修改属性默认的特性**</u>：使用ES5 的 `Object.defineProperty()` 方法（接收三个参数：属性所在的对象、属性名 和 一个描述符对象）：\n\n* 如果不指定，`configurable`、`enumerable` 和 `writable` 特性的默认值都是 false。\n* 一旦把属性定义为不可配置的，就不能再把它变回可配置了。\n\n##### 访问器属性\n包含一对儿 getter 和setter 函数（非必需）：\n\n* 在读取访问器属性时，会调用**getter 函数**，这个函数负责返回有效的值；\n* 在写入访问器属性时，会调用**setter 函数**并传入新值，这个函数负责决定如何处理数据。\n\n访问器属性有如下4 个特性：\n\n* **[[Configurable]]** ：表示能否通过delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。\n* **[[Enumerable]]** ：表示能否通过for-in 循环返回属性。\n* **[[Get]]** ：在读取属性时调用的函数。默认值为undefined。\n* **[[Set]]** ：在写入属性时调用的函数。默认值为undefined。\n\n<br/>\n\n#### 定义多个属性\nES 5 定义了 `Object.defineProperties()` 方法，利用这个方法可以通过描述符一次定义多个属性。\n\n<br/>\n\n#### 读取属性的特性\n使用ECMAScript 5 的 `Object.getOwnPropertyDescriptor()` 方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable 和value。\n\n\n<br/>\n<br/>\n<br/>\n\n### 创建对象\nObject 构造函数 或 对象字面量 创建单个对象，有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。\n\n<br/>\n\n#### 工厂模式\n工厂模式抽象了 创建具体对象的过程，在 JavaScript 中用函数来封装 以特定接口创建对象的细节：\n```javascript\nfunction createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function () {\n        alert(this.name);\n    };\n    return o;\n}\nvar person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = createPerson(\"Greg\", 27, \"Doctor\");\n```\n工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。\n\n<br/>\n\n#### 构造函数模式\n可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法：\n```javascript\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function () {\n        alert(this.name);\n    };\n}\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n```\n\n> - 按照惯例，**构造函数** 始终都应该以一个 **大写字母开头**，而非构造函数则应该以一个小写字母开头。\n> - 下划线开头是一种常用的记号，用于表示 **只能通过对象方法访问** 的属性。\n\n使用 **new 操作符** 调用构造函数实际上会经历以下 4 个步骤：\n\n(1) 创建一个新对象；\n(2) 将构造函数的作用域赋给新对象（因此this 就指向了这个新对象）；\n(3) 执行构造函数中的代码（为这个新对象添加属性）；\n(4) 返回新对象。\n\n对象的constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 **instanceof** 操作符要更可靠一些。\n\n**创建自定义的构造函数** 意味着将来可以将它的实例标识为一种特定的类型。\n\n1. 将构造函数 当做函数\n\n```javascript\n// 当作构造函数使用\nvar person = new Person(\"Nicholas\", 29, \"Software Engineer\");\nperson.sayName(); //\"Nicholas\"\n\n// 作为普通函数调用\nPerson(\"Greg\", 27, \"Doctor\"); // 添加到window\nwindow.sayName(); //\"Greg\"\n\n// 在另一个对象的作用域中调用\nvar o = new Object();\nPerson.call(o, \"Kristen\", 25, \"Nurse\");\no.sayName(); //\"Kristen\"\n```\n>**当在全局作用域中调用一个函数时，this 对象总是指向Global 对象（在浏览器中就是window 对象）**。\n\n2. 构造函数的问题\n\n使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。\n\n>ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。\n\n```javascript\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = sayName;\n}\nfunction sayName() {\n    alert(this.name);\n}\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n```\n把sayName()函数的定义转移到了 构造函数外部。而在构造函数内部，我们将sayName 属性设置成等于全局的sayName 函数。由于sayName 包含的是一个指向函数的指针，因此person1 和person2 对象就共享了在全局作用域中定义的同一个sayName()函数。\n\n这样做确实解决了两个函数做同一件事的问题，可是新问题又来了：\n\n1. 在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。\n2. 如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。\n\n这些问题可以通过使用 原型模式 来解决。\n\n<br/>\n\n#### 原型模式\n我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个 **指针**，指向一个对象，而这个对象的用途是 **包含可以由特定类型的所有实例共享的属性和方法**。使用原型对象的好处是 可以让所有对象实例共享它所包含的属性和方法。\n```javascript\nfunction Person() {\n}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function () {\n    alert(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName(); //\"Nicholas\"\nvar person2 = new Person();\nperson2.sayName(); //\"Nicholas\"\n\nalert(person1.sayName == person2.sayName); //true\n```\n\n##### 1. 理解原型对象\n无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype 属性所在函数的指针。\n\n当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 __`[[Prototype]]`__ （内部属性），指向构造函数的原型对象。虽然在脚本中没有标准的方式访问 `[[Prototype]]` ，但Firefox、Safari 和Chrome 在每个对象上都支持一个属性 `__proto__` ；而在其他实现中，这个属性对脚本则是完全不可见的。需要明确的是，这个连接存在于 **实例** 与 **构造函数的<u>原型对象</u>** 之间，而不是存在于实例与构造函数之间。\n\n\n{% asset_img 理解原型对象.png 理解原型对象 %}\n\n虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 **isPrototypeOf()** 方法来确定对象之间是否存在这种关系。\n```javascript\nalert(Person.prototype.isPrototypeOf(person1)); //true\n\nalert(Person.prototype.isPrototypeOf(person2)); //true\n```\n\nECMAScript 5 增加了一个新方法，叫 **Object.getPrototypeOf()** ，在所有支持的实现中，这个方法返回 `[[Prototype]]` 的值：\n```javascript\nalert(Object.getPrototypeOf(person1) == Person.prototype); //true\n\nalert(Object.getPrototypeOf(person1).name); //\"Nicholas\"\n```\n\n>读取对象属性：\n>\n>1. 搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；\n>2. 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。\n\n\n* 通过对象实例，可以访问保存在原型中的值，不能重写原型中的值；\n* 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；\n* 使用`delete` 操作符则可以完全删除实例属性，从而可以重新访问原型中的属性；\n\n使用 **hasOwnProperty()** 方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（它是从Object 继承来的）只在给定属性存在于对象实例中时，才会返回true。\n\n##### 2. 原型与 in 操作符\n有两种方式使用in 操作符：\n\n* **单独使用**：in 操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中；\n* **在 `for-in` 循环中使用**：返回的是所有能够 **通过对象访问的**、**可枚举的**（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。\n\n\n同时使用 `hasOwnProperty()` 方法和 `in` 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中：\n```javascript\nfunction hasPrototypeProperty(object, name){\n    return !object.hasOwnProperty(name) && (name in object);\n}\n```\n\n* 要取得对象上**所有<u>可枚举</u>的实例属性**，可以使用ES5 的 **Object.keys()** 方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组；\n* 如果你想要得到**所有实例属性**，无论它是否可枚举，都可以使用**Object.getOwnPropertyNames()** 方法。\n\n##### 3. 更简单的原型语法\n为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是：用一个包含所有属性和方法的 **对象字面量** 来重写整个原型对象：\n```javascript\nfunction Person() {\n}\nPerson.prototype = {\n    name: \"Nicholas\",\n    age: 29,\n    job: \"Software Engineer\",\n    sayName: function () {\n        alert(this.name);\n    }\n};\n```\n上述代码本质上完全 **重写了默认的prototype 对象**，因此 **constructor** 属性也就变成了新对象的constructor 属性（**指向Object 构造函数**），不再指向Person 函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor 已经无法确定对象的类型了。\n```javascript\n//重设构造函数，只适用于ECMAScript 5 兼容的浏览器\nObject.defineProperty(Person.prototype, \"constructor\", {\n    enumerable: false,\n    value: Person\n});\n```\n\n##### 4. 原型的动态性\n**可以随时为原型添加属性和方法**，并且修改能够**立即在所有对象实例中反映**出来；但如果是 **重写整个原型对象**，那么情况就不一样了：调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。\n\n>请记住：实例中的指针 [[Prototype]] 仅指向原型，而不指向构造函数。\n\n```javascript\nfunction Person() {\n}\nvar friend = new Person();\n\nPerson.prototype = {\n    constructor: Person,\n    name: \"Nicholas\",\n    age: 29,\n    job: \"Software Engineer\",\n    sayName: function () {\n        alert(this.name);\n    }\n};\n\nfriend.sayName(); //error\n```\n\n{% asset_img 原型的动态性.png 原型的动态性 %}\n\n重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。\n\n##### 5. 原生对象的原型\n所有原生引用类型（Object、Array、String，等等）都在其 **构造函数的原型** 上定义了方法。\n\n通过原生对象的原型，不仅可以 **取得所有默认方法的引用**，而且也可以 **定义新方法**。\n\n##### 6. 原型对象的问题\n\n1. 它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值；\n2. 原型中所有属性是被很多实例共享的，对于 **包含<u>引用类型值</u>的属性** 来说，问题就比较突出了：\n```javascript\nfunction Person() {\n}\nPerson.prototype = {\n    constructor: Person,\n    name: \"Nicholas\",\n    age: 29,\n    job: \"Software Engineer\",\n    friends: [\"Shelby\", \"Court\"],\n    sayName: function () {\n        alert(this.name);\n    }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\"Van\");\n\nalert(person1.friends);    //\"Shelby,Court,Van\"\nalert(person2.friends);    //\"Shelby,Court,Van\"\nalert(person1.friends === person2.friends);    //true\n```\n\n<br/>\n\n#### 组合使用 构造函数模式 和 原型模式\n\n**创建自定义类型** 的最常见方式。\n\n* 构造函数模式：定义 **实例属性**；\n* 原型模式：定义 **方法** 和 **共享属性**；\n* 支持向构造函数 **传递参数**。\n\n```javascript\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = [\"Shelby\", \"Court\"];\n}\n\nPerson.prototype = {\n    constructor: Person,\n    sayName: function () {\n        alert(this.name);\n    }\n}\n\nvar person1 = new Person(\"Nicholas\", 29, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\nperson1.friends.push(\"Van\");\n\nalert(person1.friends); //\"Shelby,Count,Van\"\nalert(person2.friends); //\"Shelby,Count\"\nalert(person1.friends === person2.friends); //false\nalert(person1.sayName === person2.sayName); //true\n```\n\n<br/>\n\n#### 动态原型模式\n动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型：\n```javascript\nfunction Person(name, age, job) {\n    //属性\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    \n    //方法\n    if (typeof this.sayName != \"function\") {\n        Person.prototype.sayName = function () {\n            alert(this.name);\n        };\n    }\n}\n\nvar friend = new Person(\"Nicholas\", 29, \"Software Engineer\");\nfriend.sayName();\n```\n**if 语句** 检查的可以是 **初始化之后应该存在的任何属性或方法** ——不必用一大堆if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用instanceof 操作符确定它的类型。\n\n<br/>\n\n#### 寄生构造函数模式\n寄生（parasitic）构造函数模式的基本思想是：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。\n```javascript\nfunction Person(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function () {\n        alert(this.name);\n    };\n    return o;\n}\n\nvar friend = new Person(\"Nicholas\", 29, \"Software Engineer\");\nfriend.sayName(); //\"Nicholas\"\n```\n构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个return 语句，可以重写调用构造函数时返回的值。\n\n这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改Array 构造函数，因此可以使用这个模式：\n```javascript\nfunction SpecialArray() {\n    //创建数组\n    var values = new Array();\n    //添加值\n    values.push.apply(values, arguments);\n    //添加方法\n    values.toPipedString = function () {\n        return this.join(\"|\");\n    };\n    //返回数组\n    return values;\n}\n\nvar colors = new SpecialArray(\"red\", \"blue\", \"green\");\nalert(colors.toPipedString());   //\"red|blue|green\"\n```\n\n* 返回的对象与构造函数或者与构造函数的原型属性之间没有关系；\n* 不能依赖instanceof 操作符来确定对象类型。\n\n<br/>\n\n#### 稳妥构造函数模式\n稳妥对象（durable objects）指的是 **没有公共属性**，而且 **其方法也不引用this** 的对象。\n\n稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：\n一是新创建对象的实例方法不引用this；\n二是不使用new 操作符调用构造函数。\n```javascript\nfunction Person(name, age, job) {\n    //创建要返回的对象\n    var o = new Object();\n    //可以在这里定义私有变量和函数\n    \n    //添加方法\n    o.sayName = function () {\n        alert(name);\n    };\n    //返回对象\n    return o;\n}\n\nvar friend = Person(\"Nicholas\", 29, \"Software Engineer\");\nfriend.sayName(); //\"Nicholas\"\n```\n\n<br/>\n<br/>\n<br/>\n\n### 继承\n>OO语言支持两种继承方式：\n>（1）接口继承：只继承 方法签名；\n>（2）实现继承：继承 实际的方法。\n\nECMAScript 只支持 **实现继承**，而且其实现继承主要是依靠 **原型链** 来实现的。\n\n<br/>\n\n#### 原型链\n基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。\n\n>构造函数、原型和实例的关系：\n>每个构造函数都有一个原型对象，\n>原型对象都包含一个指向构造函数的指针，\n>而实例都包含一个指向原型对象的内部指针。\n\n实现原型链的一种基本模式如下：\n```javascript\nfunction SuperType() {\n    this.property = true;\n}\nSuperType.prototype.getSuperValue = function () {\n    return this.property;\n};\n\nfunction SubType() {\n    this.subproperty = false;\n}\n//继承了SuperType\nSubType.prototype = new SuperType();\nSubType.prototype.getSubValue = function () {\n    return this.subproperty;\n};\n\nvar instance = new SubType();\nalert(instance.getSuperValue()); //true\n```\n实现的本质是重写原型对象，代之以一个新类型的实例。实例以及构造函数和原型之间的关系如图：\n\n{% asset_img 原型链.png 原型链 %}\n\n通过实现原型链，本质上是扩展了 原型搜索机制。调用 `instance.getSuperValue()` 会经历三个搜索步骤：1）搜索实例；2）搜索 `SubType.prototype`；3）搜索 `SuperType.prototype`，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。\n\n##### 1. 别忘记默认的原型\n> - 所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。\n> - 所有函数的默认原型都是Object 的实例，因此默认原型都会包含一个内部指针，指向 `Object.prototype` 。\n\n上述代码完整的原型链如下：\n\n{% asset_img 完整原型链.png 完整原型链 %}\n\n\n##### 2. 确定原型和实例的关系\n\n* 使用 __`instanceof`__ 操作符：测试实例与原型链中出现过的构造函数，结果就会返回true。\n* 使用 __`isPrototypeOf()`__ 方法：只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此 `isPrototypeOf()` 方法也会返回true。\n\n\n```javascript\nalert(instance instanceof Object); //true\nalert(instance instanceof SuperType); //true\nalert(instance instanceof SubType); //true\n\nalert(Object.prototype.isPrototypeOf(instance)); //true\nalert(SuperType.prototype.isPrototypeOf(instance)); //true\nalert(SubType.prototype.isPrototypeOf(instance)); //true\n```\n\n##### 3. 谨慎地定义方法\n\n* 给原型添加方法的代码一定要放在 **替换原型的语句之后**。\n* 在通过原型链实现继承时，**不能** 使用 **对象字面量** 创建原型方法，因为这样做就会重写原型链。\n\n\n##### 4. 原型链的问题\n\n* **最主要的问题**：包含引用类型值的原型。\n\n包含引用类型值的原型属性会被所有实例共享。\n\n要在构造函数中，而不是在原型对象中定义属性。\n\n* **第二个问题**：在创建子类型的实例时，不能向超类型的构造函数中传递参数。\n\n>注：被继承的类一般称为“**超类 / 父类**”，继承的类称为“**子类**”。\n\n<br/>\n\n#### 借用构造函数\n借用构造函数（constructor stealing）的技术（伪造对象 / 经典继承）：在**子类型**构造函数的内部调用**超类型**构造函数。\n\n>函数只不过是 **在特定环境中执行代码的对象**，因此通过使用 __`apply()`__ 和 __`call()`__ 方法也可以在（将来）新创建的对象上执行构造函数。\n\n```javascript\nfunction SuperType() {\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\n\nfunction SubType() {\n    //继承了SuperType\n    SuperType.call(this);\n}\n\nvar instance1 = new SubType();\ninstance1.colors.push(\"black\");\nalert(instance1.colors);   //\"red,blue,green,black\"\n\nvar instance2 = new SubType();\nalert(instance2.colors);   //\"red,blue,green\"\n```\n在新建的SubType 实例的环境下调用了SuperType 构造函数。这样一来，就会在新SubType 对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的colors 属性的副本了。\n\n借用构造函数，就可以 在子类型构造函数中向超类型构造函数 **传递参数**：\n```javascript\nfunction SuperType(name) {\n    this.name = name;\n}\n\nfunction SubType() {\n    //继承了SuperType，同时还传递了参数\n    SuperType.call(this, \"Nicholas\");\n    //实例属性\n    this.age = 29;\n}\n\nvar instance = new SubType();\nalert(instance.name); //\"Nicholas\";\nalert(instance.age); //29\n```\n为了确保 超类型构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。\n\n\n**借用构造函数的问题**：如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。\n\n<br/>\n\n#### 组合继承\n组合继承（combination inheritance）（伪经典继承）的思路是：使用 **原型链** 实现对原型属性和方法的继承，而通过 **借用构造函数** 来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。\n\n```javascript\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function () {\n    alert(this.name);\n};\n\nfunction SubType(name, age) {\n    //继承属性\n    SuperType.call(this, name);    //  第二次调用 SuperType()\n    this.age = age;\n}\n\n//继承方法\nSubType.prototype = new SuperType();     // 第一次调用 SuperType()\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function () {\n    alert(this.age);\n};\n\nvar instance1 = new SubType(\"Nicholas\", 29);\ninstance1.colors.push(\"black\");\nalert(instance1.colors); //\"red,blue,green,black\"\ninstance1.sayName(); //\"Nicholas\";\ninstance1.sayAge(); //29\n\nvar instance2 = new SubType(\"Greg\", 27);\nalert(instance2.colors); //\"red,blue,green\"\ninstance2.sayName(); //\"Greg\";\ninstance2.sayAge(); //27\n```\n`instanceof` 和 `isPrototypeOf()` 能够用于识别基于组合继承创建的对象。\n\n**组合继承的问题**：无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。\n\n<br/>\n\n#### 原型式继承\n借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。\n\n\n```javascript\nfunction object(o) {\n    function F() { }\n    F.prototype = o;\n    return new F();\n}\n\nvar person = {\n    name: \"Nicholas\",\n    friends: [\"Shelby\", \"Court\", \"Van\"]\n};\n\nvar anotherPerson = object(person);\nanotherPerson.name = \"Greg\";\nanotherPerson.friends.push(\"Rob\");\n\nvar yetAnotherPerson = object(person);\nyetAnotherPerson.name = \"Linda\";\nyetAnotherPerson.friends.push(\"Barbie\");\nalert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\"\n```\n从本质上讲，object()对传入其中的对象执行了一次 **浅拷贝**。\n\nECMAScript 5 通过新增 __`Object.create()`__ 方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象 和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create() 与 object() 方法的行为相同：\n```javascript\nvar person = {\n    name: \"Nicholas\",\n    friends: [\"Shelby\", \"Court\", \"Van\"]\n};\n\nvar anotherPerson = Object.create(person);\nanotherPerson.name = \"Greg\";\nanotherPerson.friends.push(\"Rob\");\n\nvar yetAnotherPerson = Object.create(person);\nyetAnotherPerson.name = \"Linda\";\nyetAnotherPerson.friends.push(\"Barbie\");\nalert(person.friends); //\"Shelby,Court,Van,Rob,Barbie\"\n```\n\n<br/>\n\n#### 寄生式继承\n寄生式（parasitic）继承：创建一个仅用于 **封装继承过程** 的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。。\n```javascript\nfunction object(o) {\n    function F() { }\n    F.prototype = o;\n    return new F();\n}\n\nfunction createAnother(original) {\n    var clone = object(original); //通过调用函数创建一个新对象\n    clone.sayHi = function () { //以某种方式来增强这个对象\n        alert(\"hi\");\n    };\n    return clone; //返回这个对象\n}\n\nvar person = {\n    name: \"Nicholas\",\n    friends: [\"Shelby\", \"Court\", \"Van\"]\n};\n\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi();   //\"hi\"\n```\n\n>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。\n\n<br/>\n\n#### 寄生组合式继承\n组合继承的问题如下：\n\n{% asset_img 组合继承的问题.png 组合继承的问题 %}\n\n\n所谓 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是 使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。\n\n```javascript\nfunction inheritPrototype(subType, superType) {\n    var prototype = object(superType.prototype); //创建对象\n    prototype.constructor = subType; //增强对象\n    subType.prototype = prototype; //指定对象\n}\n\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nSuperType.prototype.sayName = function () {\n    alert(this.name);\n};\n\nfunction SubType(name, age) {\n    SuperType.call(this, name);\n    this.age = age;\n}\n\ninheritPrototype(SubType, SuperType);\n\nSubType.prototype.sayAge = function () {\n    alert(this.age);\n};\n```\n上例中只调用了一次 SuperType 构造函数，并且因此避免了在`SubType.prototype` 上面创建不必要的、多余的属性。\n\n\n<br/>\n<br/>\n<br/>\n","tags":["JavaScript","JavaScript高级程序设计"]},{"title":"JavaScript 客户端检测","url":"/2020/01/05/JavaScript-客户端检测/","content":"\n\n### 能力检测\n又称 **特性检测**，指在 **编写代码之前** 先检测 **特定浏览器的能力**。\n\n例如，脚本在调用某个函数之前，可能要先检测该函数是否存在。这种检测方法将开发人员从考虑具体的浏览器类型和版本中解放出来，让他们把注意力集中到相应的能力是否存在上。\n\n采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。能力检测的基本模式如下：\n```javascript\nif (object.propertyInQuestion){\n    //使用object.propertyInQuestion\n}\n```\n需要注意：\n\n* 先检测达成目的的最常用的特性\n* 必须测试实际要用到的特性（检测某个或某几个特性并不能够确定浏览器）\n* 能力检测无法精确地检测特定的浏览器和版本\n\n\n想知道某个特性是否会 **按照适当方式行事**（而不仅仅是某个特性存在），要尽量使用 **typeof** 进行能力检测。\n\n由于 typeof 的行为不标准，在浏览器环境下测试任何对象的某个特性是否存在，可以使用下面这个函数：\n```javascript\n//作者：Peter Michaux\nfunction isHostMethod(object, property) {\n    var t = typeof object[property];\n    return t == 'function' ||\n        (!!(t == 'object' && object[property])) ||\n        t == 'unknown';\n}\n```\n如果知道自己的应用程序需要使用某些特定的浏览器特性，那么最好是 **一次性检测** **所有相关特性**，而不要分别检测：\n```javascript\n//确定浏览器是否支持Netscape 风格的插件\nvar hasNSPlugins = !!(navigator.plugins && navigator.plugins.length);\n//确定浏览器是否具有DOM1 级规定的能力\nvar hasDOM1 = !!(document.getElementById && document.createElement &&\n    document.getElementsByTagName);\n```\n\n<br/>\n<br/>\n<br/>\n\n### 怪癖检测\n怪癖检测（quirks detection）的目标是 **识别浏览器的特殊行为**。\n\n怪癖 = **浏览器实现中存在的bug**，例如早期的WebKit 中就存在一个怪癖，即它会在for-in 循环中返回被隐藏的属性。\n\n* 建议仅检测那些对你有直接影响的“怪癖”\n* 最好在脚本一开始就执行此类检测，以便尽早解决问题\n* 怪癖检测无法精确地检测特定的浏览器和版本\n\n<br/>\n<br/>\n<br/>\n\n### 用户代理检测\n通过检测 **用户代理字符串** 来识别浏览器。\n\n\n1. 识别**呈现引擎**\n    \n主要检测五大呈现引擎：\n**IE**、**Gecko**、**WebKit**、**KHTML** 和 **Opera**。\n\n要正确地识别呈现引擎，关键是 **检测顺序** 要正确：\n```\nOpera -> WebKit ( 关键字 AppleWebKit ) -> KHTML -> Gecko -> IE\n```\n    \n2. 识别**浏览器**\n\n苹果公司的Safari 浏览器和谷歌公司的Chrome 浏览器都使用WebKit 作为呈现引擎，但它们的 **JavaScript 引擎** 却不一样。\n\n3. 识别**平台**\n\n目前的三大主流平台是\n**Windows**、**Mac** 和 **Unix**（包括各种 **Linux**）。\n\n在确定平台时，检测 __`navigator.platform`__ ：可能的值包括\"Win32\"、\"Win64\"、\n\"MacPPC\"、\"MacIntel\"、\"X11\"和\"Linux i686\"，这些值在不同的浏览器中都是一致的。\n\n4. 识别**Windows 操作系统**\n\n>在Windows XP 之前，Windows 有两种版本，分别针对家庭用户和商业用户。针对家庭用户的版本分别是Windows 95、98 和Windows ME。而针对商业用户的版本则一直叫做Window NT，最后由于市场原因改名为Windows 2000。这两个产品线后来又合并成一个由Windows NT 发展而来的公共的代码基，代表产品就是Windows XP。随后，微软在Windows XP 基础上又构建了Windows Vista。\n\n5. 识别**移动设备**\n\n四种主要的移动设备平台：\n**iOS设备**、**Android操作系统**、**诺基亚N系列**、**Windows Mobile**。\n\n6. 识别**游戏系统**\n\n任天堂Wii 和Playstation 3 或者内置Web 浏览器，或者提供了浏览器下载。Wii 中的浏览器实际上是定制版的Opera，是专门为Wii Remote 设计的。Playstation 的浏览器是自己开发的，没有基于前面提到的任何呈现引擎。这两个浏览器中的用户代理字符串如下所示：\n```\nOpera/9.10 (Nintendo Wii;U; ; 1621; en)\n\nMozilla/5.0 (PLAYSTATION 3; 2.00)\n```\n\n\n<br/>\n\n完整的用户代理字符串检测脚本（包括检测呈现引擎、平台、Windows 操作系统、移动设备和游戏系统）：\n```javascript\nvar client = function () {\n\n    //呈现引擎\n    var engine = {\n        ie: 0,\n        gecko: 0,\n        webkit: 0,\n        khtml: 0,\n        opera: 0,\n        //完整的版本号\n        ver: null\n    };\n    \n    //浏览器\n    var browser = {\n        //主要浏览器\n        ie: 0,\n        firefox: 0,\n        safari: 0,\n        konq: 0,\n        opera: 0,\n        chrome: 0,\n        //具体的版本号\n        ver: null\n    };\n    \n    //平台、设备和操作系统\n    var system = {\n        win: false,\n        mac: false,\n        x11: false,\n        //移动设备\n        iphone: false,\n        ipod: false,\n        ipad: false,\n        ios: false,\n        android: false,\n        nokiaN: false,\n        winMobile: false,\n        //游戏系统\n        wii: false,\n        ps: false\n    };\n    \n    \n    //检测呈现引擎和浏览器\n    var ua = navigator.userAgent;\n    if (window.opera) {\n        engine.ver = browser.ver = window.opera.version();\n        engine.opera = browser.opera = parseFloat(engine.ver);\n    } else if (/AppleWebKit\\/(\\S+)/.test(ua)) {\n        engine.ver = RegExp[\"$1\"];\n        engine.webkit = parseFloat(engine.ver);\n        //确定是Chrome 还是Safari\n        if (/Chrome\\/(\\S+)/.test(ua)) {\n            browser.ver = RegExp[\"$1\"];\n            browser.chrome = parseFloat(browser.ver);\n        } else if (/Version\\/(\\S+)/.test(ua)) {\n            browser.ver = RegExp[\"$1\"];\n            browser.safari = parseFloat(browser.ver);\n        } else {\n            //近似地确定版本号\n            var safariVersion = 1;\n            if (engine.webkit < 100) {\n                safariVersion = 1;\n            } else if (engine.webkit < 312) {\n                safariVersion = 1.2;\n            } else if (engine.webkit < 412) {\n                safariVersion = 1.3;\n            } else {\n                safariVersion = 2;\n            }\n            browser.safari = browser.ver = safariVersion;\n        }\n    } else if (/KHTML\\/(\\S+)/.test(ua) || /Konqueror\\/([^;]+)/.test(ua)) {\n        engine.ver = browser.ver = RegExp[\"$1\"];\n        engine.khtml = browser.konq = parseFloat(engine.ver);\n    } else if (/rv:([^\\)]+)\\) Gecko\\/\\d{8}/.test(ua)) {\n        engine.ver = RegExp[\"$1\"];\n        engine.gecko = parseFloat(engine.ver);\n        //确定是不是Firefox\n        if (/Firefox\\/(\\S+)/.test(ua)) {\n            browser.ver = RegExp[\"$1\"];\n            browser.firefox = parseFloat(browser.ver);\n        }\n    } else if (/MSIE ([^;]+)/.test(ua)) {\n        engine.ver = browser.ver = RegExp[\"$1\"];\n        engine.ie = browser.ie = parseFloat(engine.ver);\n    }\n    \n    //检测浏览器\n    browser.ie = engine.ie;\n    browser.opera = engine.opera;\n    \n    //检测平台\n    var p = navigator.platform;\n    system.win = p.indexOf(\"Win\") == 0;\n    system.mac = p.indexOf(\"Mac\") == 0;\n    system.x11 = (p == \"X11\") || (p.indexOf(\"Linux\") == 0);\n    \n    //检测Windows 操作系统\n    if (system.win) {\n        if (/Win(?:dows )?([^do]{2})\\s?(\\d+\\.\\d+)?/.test(ua)) {\n            if (RegExp[\"$1\"] == \"NT\") {\n                switch (RegExp[\"$2\"]) {\n                    case \"5.0\":\n                        system.win = \"2000\";\n                        break;\n                    case \"5.1\":\n                        system.win = \"XP\";\n                        break;\n                    case \"6.0\":\n                        system.win = \"Vista\";\n                        break;\n                    case \"6.1\":\n                        system.win = \"7\";\n                        break;\n                    default:\n                        system.win = \"NT\";\n                        break;\n                }\n            } else if (RegExp[\"$1\"] == \"9x\") {\n                system.win = \"ME\";\n            } else {\n                system.win = RegExp[\"$1\"];\n            }\n        }\n    }\n    \n    //移动设备\n    system.iphone = ua.indexOf(\"iPhone\") > -1;\n    system.ipod = ua.indexOf(\"iPod\") > -1;\n    system.ipad = ua.indexOf(\"iPad\") > -1;\n    system.nokiaN = ua.indexOf(\"NokiaN\") > -1;\n    //windows mobile\n    if (system.win == \"CE\") {\n        system.winMobile = system.win;\n    } else if (system.win == \"Ph\") {\n        if (/Windows Phone OS (\\d+.\\d+)/.test(ua)) {\n            ;\n            system.win = \"Phone\";\n            system.winMobile = parseFloat(RegExp[\"$1\"]);\n        }\n    }\n   \n    //检测iOS 版本\n    if (system.mac && ua.indexOf(\"Mobile\") > -1) {\n        if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(ua)) {\n            system.ios = parseFloat(RegExp.$1.replace(\"_\", \".\"));\n        } else {\n            system.ios = 2; //不能真正检测出来，所以只能猜测\n        }\n    }\n    //检测Android 版本\n    if (/Android (\\d+\\.\\d+)/.test(ua)) {\n        system.android = parseFloat(RegExp.$1);\n    }\n    \n    //游戏系统\n    system.wii = ua.indexOf(\"Wii\") > -1;\n    system.ps = /playstation/i.test(ua);\n    \n    //返回这些对象\n    return {\n        engine: engine,\n        browser: browser,\n        system: system\n    };\n}();\n```\n用户代理检测是客户端检测的 **最后一个选择**，一般适用于下列情形：\n\n* 不能直接准确地使用能力检测或怪癖检测\n* 同一款浏览器在不同平台下具备不同的能力\n* 为了跟踪分析等目的需要知道确切的浏览器\n\n<br/>\n<br/>\n<br/>\n","tags":["JavaScript","JavaScript高级程序设计"]},{"title":"JavaScript BOM","url":"/2020/01/05/JavaScript-BOM/","content":"\n\n>**BOM** = browser Object Model 浏览器对象模型\n\nBOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。其中，**浏览器之间共有的对象** 成为了事实标准。\n\nW3C 为了把浏览器中JavaScript 最基本的部分标准化，已经将 **BOM的主要方面** 纳入了 **HTML5 的规范**中。\n\n<br/>\n<br/>\n<br/>\n\n### window对象\nBOM 的核心对象是window，它表示 **浏览器的一个实例**。\n在浏览器中，window 对象有双重角色：\n\n1. 通过JavaScript 访问浏览器窗口的一个接口；\n2. ECMAScript 规定的Global 对象。\n\n<br/>\n\n#### 全局作用域\n由于window 对象同时扮演着ECMAScript 中Global 对象的角色，因此 **所有在全局作用域中声明的变量、函数 都会变成window 对象的属性和方法**。\n\n><u>定义全局变量</u> 与 <u>在window 对象上直接定义属性</u> 的差别：\n>全局变量不能通过delete 操作符删除，而直接在window 对象上定义的属性可以。\n\n* 使用`var` 语句添加的window 属性有一个名为 `[[Configurable]]` 的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。\n* IE8及更早版本 在遇到使用delete删除window 属性的语句时，不管该属性最初是如何创建的，都会抛出错误，以示警告。IE9 及更高版本不会抛出错误。\n* 尝试访问未声明的变量会抛出错误，但是**通过 <u>查询window 对象</u>，可以知道某个可能未声明的变量是否存在**。\n\n<br/>\n\n#### 窗口关系及框架\n\n* 如果页面中包含框架，则每个框架都拥有自己的window 对象，并且保存在 **frames 集合**中。\n* 在frames集合中，可以通过 **数值索引**（从0 开始，从左至右，从上到下）或者 **框架名称** 来访问相应的window 对象。\n* 每个window 对象都有一个 **name 属性**，其中包含框架的名称（注意，除非最高层窗口是通过 `window.open()` 打开的，否则其window 对象的 `name` 属性不会包含任何值）。\n\n>对于 <u>在一个框架中</u> 编写的任何代码来说，其中的 <u>window 对象</u> 指向的都是 <u>那个框架的特定实例</u>，而非最高层的框架。\n\n\n**与框架有关的对象**（window对象）：\n\n* **top 对象**：始终指向 **最高（最外）层的框架**，也就是浏览器窗口（使用它可以确保在一个框架中正确地访问另一个框架）；\n* **parent（父）对象**：始终指向当前框架的 **直接上层框架**（在某些情况下，parent 有可能等于top；在没有框架的情况下，parent 一定等于top，此时它们都等于window）；\n* **self 对象**：**始终指向window**；实际上，self 和window 对象可以互换使用（引入self 对象的目的只是为了与top 和parent 对象相对应）。\n\n以下是一个包含框架的页面：\n```html\n<html>\n<head>\n    <title>Frameset Example</title>\n</head>\n<frameset rows=\"160,*\">\n    <frame src=\"frame.htm\" name=\"topFrame\">\n        <frameset cols=\"50%,50%\">\n            <frame src=\"anotherframe.htm\" name=\"leftFrame\">\n                <frame src=\"yetanotherframe.htm\" name=\"rightFrame\">\n        </frameset>\n</frameset>\n</html>\n```\n在 **最高层窗口** 中，通过代码来访问上述代码中每个框架的不同方式如下：\n\n{% asset_img 窗口关系.png 窗口关系 %}\n\n<br/>\n\n#### 窗口位置\n>窗口相对于屏幕左边和上边的位置：\n> - **screenLeft** 和 **screenTop** —— Safari、Chrome、IE、Opera；\n> - **screenX** 和 **screenY** —— Firefox、Safari、Chrome。\n\n**跨浏览器获取 窗口左边和上边的位置**：\n```javascript\nvar leftPos = (typeof window.screenLeft == \"number\") ?\n    window.screenLeft : window.screenX;\nvar topPos = (typeof window.screenTop == \"number\") ?\n    window.screenTop : window.screenY;\n```\n>注意：\n>\n>在IE、Opera 中，screenLeft 和screenTop 中保存的是 **从屏幕左边和上边到由window 对象表示的<u>页面可见区域</u>的距离**。换句话说，如果window 对象是最外层对象，而且浏览器窗口紧贴屏幕最上端——即y 轴坐标为0，那么screenTop 的值就是位于页面可见区域上方的浏览器工具栏的像素高度。但是，在Chrome、Firefox 和Safari 中，screenY 或screenTop中保存的是 **<u>整个浏览器窗口</u>相对于屏幕的坐标值**，即在窗口的y 轴坐标为0 时返回0。\n>\n>Firefox、Safari 和Chrome **始终返回页面中每个框架的top.screenX 和top.screenY 值**。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window 对象使用screenX 和screenY 每次也都会返回相同的值。而IE 和Opera 则会给出框架相对于屏幕边界的精确坐标值。\n>\n>最终结果，就是 **无法** 在跨浏览器的条件下取得窗口左边和上边的精确坐标值。\n\n\n将窗口精确地移动到一个新位置：\n```javascript\n//将窗口移动到屏幕左上角\nwindow.moveTo(0, 0);\n//将窗向下移动100 像素\nwindow.moveBy(0, 100);\n//将窗口移动到(200,300)\nwindow.moveTo(200, 300);\n//将窗口向左移动50 像素\nwindow.moveBy(-50, 0);\n```\n这两个方法可能会被浏览器禁用；而且，在Opera 和IE 7（及更高版本）中默认就\n是禁用的。另外，这两个方法都不适用于框架，只能对最外层的window 对象使用。\n\n<br/>\n\n#### 窗口大小\n>跨浏览器确定一个窗口的大小不是一件简单的事。\n>IE9+、Firefox、Safari、Opera 和Chrome 均为此提供了4 个属性：**innerWidth**、**innerHeight**、**outerWidth** 和**outerHeight**。在IE9+、Safari 和Firefox中，outerWidth 和outerHeight 返回浏览器窗口本身的尺寸（无论是从最外层的window 对象还是从某个框架访问）。在Opera 中，这两个属性的值表示页面视图容器①的大小。而innerWidth 和innerHeight则表示该容器中页面视图区的大小（减去边框宽度）。在Chrome 中，outerWidth、outerHeight 与innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。\n>\n>IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过DOM 提供了页面可见区域的相关信息。\n>\n>在IE、Firefox、Safari、Opera 和Chrome 中，**document.documentElement.clientWidth** 和**document.documentElement.clientHeight** 中保存了页面视口的信息。在IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过 **document.body.clientWidth** 和 **document.body.clientHeight** 取得相同信息。而对于混杂模式下的Chrome，则无论通过document.documentElement还是document.body 中的clientWidth 和clientHeight 属性，都可以取得视口的大小。\n\n虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小：\n```javascript\nvar pageWidth = window.innerWidth,\n    pageHeight = window.innerHeight;\n    \nif (typeof pageWidth != \"number\") {\n    if (document.compatMode == \"CSS1Compat\") { // 标准模式\n        pageWidth = document.documentElement.clientWidth;\n        pageHeight = document.documentElement.clientHeight;\n    } else {\n        pageWidth = document.body.clientWidth;\n        pageHeight = document.body.clientHeight;\n    }\n}\n```\n使用 `resizeTo()` 和 `resizeBy()` 方法可以调整浏览器窗口的大小：\n```javascript\n//调整到100×100\nwindow.resizeTo(100, 100);\n//调整到200×150\nwindow.resizeBy(100, 50);\n//调整到 300×300\nwindow.resizeTo(300, 300);\n```\n在Opera和IE7（及更高版本）中默认就是禁用的。另外，这两个方法同样不适用于框架，而只能对最外层的window 对象使用。\n\n<br/>\n\n#### 导航 & 打开窗口\n__`window.open()`__ 方法：\n（1）导航到一个特定的URL；\n（2）打开一个新的浏览器窗口。\n\n>这个方法可以接收4 个参数：\n>1. 要加载的URL；\n>2. 窗口目标；\n>3. 一个特性字符串；\n>4. 一个表示 <u>新页面是否取代浏览器历史记录中当前加载页面</u> 的布尔值。\n\n通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。如果为window.open()传递了第二个参数，而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。第二个参数也可以是下列任何一个特殊的窗口名称：_self、_parent、_top 或_blank。\n\n1. **弹出窗口**\n\n如果给 `window.open()` 传递的第二个参数并不是一个已经存在的窗口或框架，那么该方法就会根据在第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏和状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不打开新窗口的情况下，会忽略第三个参数。\n\n第三个参数是一个 **逗号分隔的设置字符串**，表示在新窗口中都显示哪些特性。其中，名值对以**等号**表示（注意，整个特性字符串中 <u>不允许出现空格</u>）。\n\n`window.open()` 方法会返回一个指向新窗口的引用。\n\n调用 `close()` 方法还可以关闭 `window.open()`  新打开的窗口。弹出窗口关闭之后，窗口的引用仍然还在，但除了检测其 **closed 属性**之外，已经没有其他用处了\n\n新创建的window 对象有一个 __`opener`__ 属性，其中保存着打开它的原始窗口对象。这个属性只在弹出窗口中的最外层window 对象（top）中有定义，而且指向调用 `window.open()` 的窗口或框架。\n\n虽然弹出窗口中有一个指针指向打开它的原始窗口，但原始窗口中并没有这样的指针指向弹出窗口。窗口并不跟踪记录它们打开的弹出窗口。\n\n>有些浏览器（如IE8 和Chrome）会在 **独立的进程** 中运行每个标签页。当一个标签页打开另一个标签页时，**如果两个window 对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中**。在Chrome中，将新创建的标签页的opener 属性设置为null，即表示在单独的进程中运行新标签页。\n\n2. **弹出窗口屏蔽程序**\n\n如果是浏览器 **内置的屏蔽程序** 阻止的弹出窗口，那么 **window.open()很可能会返回null**。此时，只要检测这个返回的值就可以确定弹出窗口是否被屏蔽了：\n```javascript\nvar wroxWin = window.open(\"http://www.wrox.com\", \"_blank\");\nif (wroxWin == null) {\n    alert(\"The popup was blocked!\");\n}\n```\n如果是 **浏览器扩展或其他程序** 阻止的弹出窗口，那么`window.open()`通常会抛出一个错误。因此，要想准确地检测出弹出窗口是否被屏蔽，必须在检测返回值的同时，将对 `window.open()` 的调用封装在一个`try-catch` 块中：\n```javascript\nvar blocked = false;\ntry {\n    var wroxWin = window.open(\"http://www.wrox.com\", \"_blank\");\n    if (wroxWin == null) {\n        blocked = true;\n    }\n} catch (ex) {\n    blocked = true;\n}\nif (blocked) {\n    alert(\"The popup was blocked!\");\n}\n```\n\n<br/>\n\n#### 间歇调用 & 超时调用\n>JavaScript 是一个**单线程**序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript **任务队列**。这些任务会按照将它们添加到队列的顺序执行。\n\nJavaScript 是 **单线程**语言，但它允许通过设置 **超时值** 和 **间歇时间值** 来调度代码 <u>在特定的时刻</u> 执行。\n\n1. 超时调用\n\n**超时调用** 需要使用window 对象的 __`setTimeout()`__ 方法。setTimeout()的第二个参数告诉JavaScript 再过多长时间 **把当前任务添加到 JavaScript任务队列**中。<u>如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行</u>。\n\n调用 `setTimeout()` 之后，该方法会返回一个**数值ID**，表示超时调用。这个超时调用ID 是**计划执行代码的唯一标识符**，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用 `clearTimeout()` 方法并将相应的超时调用ID 作为参数传递给它。\n\n2. 间歇调用\n\n**间歇调用** 的方法是 __`setInterval()`__ ，它会按照 <u>指定的时间间隔</u> **重复执行** 代码，直至<u>**间歇调用被取消**</u>或者<u>**页面被卸载**</u>。\n\n调用 `setInterval()` 方法同样也会返回一个 **间歇调用ID**，该ID 可用于在将来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用 __`clearInterval()`__ 方法并传入相应的间歇调用ID。\n```javascript\nvar num = 0;\nvar max = 10;\nvar intervalId = null;\nfunction incrementNumber() {\n    num++;\n    //如果执行次数达到了max 设定的值，则取消后续尚未执行的调用\n    if (num == max) {\n        clearInterval(intervalId);\n        alert(\"Done\");\n    }\n}\nintervalId = setInterval(incrementNumber, 500);\n```\n使用超时调用来实现：\n```javascript\nvar num = 0;\nvar max = 10;\nfunction incrementNumber() {\n    num++;\n    //如果执行次数未达到max 设定的值，则设置另一次超时调用\n    if (num < max) {\n        setTimeout(incrementNumber, 500);\n    } else {\n        alert(\"Done\");\n    }\n}\nsetTimeout(incrementNumber, 500);\n```\n\n\n>一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。\n\n\n<br/>\n\n#### 系统对话框\n\n* 浏览器通过 `alert()`、`confirm()` 和 `prompt()` 方法可以调用系统对话框向用户显示消息。\n* 系统对话框与在浏览器中显示的网页没有关系，也不包含HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由CSS 决定。\n* 通过这几个方法打开的对话框都是 **同步** 和 **模态** 的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。\n\n\n<br/>\n<br/>\n<br/>\n\n\n### location对象\nlocation 提供了与 **当前窗口中加载的文档** 有关的信息，还提供了一些导航功能。\n\nlocation 对象是很特别的一个对象，因为它既是window 对象的属性，也是document 对象的属性；换句话说，`window.location` 和 `document.location` 引用的是同一个对象。\n\n**location 对象的作用：**\n（1）保存着当前文档的信息；\n（2）它将URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段\n\n![1553e212e5f94576dba0e8d40aaa45c1.png](en-resource://database/631:1)\n{% asset_img location对象.png location对象 %}\n\n\n<br/>\n\n#### 查询字符串参数\n\n```javascript\nfunction getQueryStringArgs() {\n    //取得查询字符串并去掉开头的问号\n    var qs = (location.search.length > 0 ? location.search.substring(1) : \"\"),\n        //保存数据的对象\n        args = {},\n        //取得每一项\n        items = qs.length ? qs.split(\"&\") : [],\n        item = null,\n        name = null,\n        value = null,\n        //在for 循环中使用\n        i = 0,\n        len = items.length;\n    //逐个将每一项添加到args 对象中\n    for (i = 0; i < len; i++) {\n        item = items[i].split(\"=\");\n        name = decodeURIComponent(item[0]);\n        value = decodeURIComponent(item[1]);\n        if (name.length) {\n            args[name] = value;\n        }\n    }\n    return args;\n}\n```\n\n<br/>\n\n#### 位置操作\n使用location 对象可以通过很多方式来改变浏览器的位置。\n\n##### assign(URL) 方法\n立即打开新URL 并在浏览器的历史记录中生成一条记录。\n```javascript\nlocation.assign(\"http://www.wrox.com\");\n```\n\n##### href 属性\n如果是将 `location.href` 或 `window.location` 设置为一个URL 值，也会以该值调用 `assign()`方法。\n```javascript\nwindow.location = \"http://www.wrox.com\";\nlocation.href = \"http://www.wrox.com\";\n```\n\n##### hash 、search、hostname、pathname、port 属性\n修改location 对象的属性也可以改变当前加载的页面，浏览器的历史记录中会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。\n```javascript\n//假设初始URL 为http://www.wrox.com/WileyCDA/\n\n//将URL 修改为\"http://www.wrox.com/WileyCDA/#section1\"\nlocation.hash = \"#section1\";\n\n//将URL 修改为\"http://www.wrox.com/WileyCDA/?q=javascript\"\nlocation.search = \"?q=javascript\";\n\n//将URL 修改为\"http://www.yahoo.com/WileyCDA/\"\nlocation.hostname = \"www.yahoo.com\";\n\n//将URL 修改为\"http://www.yahoo.com/mydir/\"\nlocation.pathname = \"mydir\";\n\n//将URL 修改为\"http://www.yahoo.com:8080/WileyCDA/\"\nlocation.port = 8080;\n```\n每次修改location 的属性（hash 除外），页面都会以新URL 重新加载。\n\n>在IE8、Firefox 1、Safari 2+、Opera 9+和Chrome 中，修改hash 的值会在浏览器的历史记录中生成一条新记录。在IE 的早期版本中，hash 属性不会在用户单击“后退”和“前进”按钮时被更新，而只会在用户单击包含hash 的URL 时才会被更新。\n\n##### replace() 方法\n\n* 只接受一个参数，即要导航到的URL；\n* 不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面。\n\n##### reload() 方法\n重新加载当前显示的页面。如果调用reload()时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数true。\n```javascript\nlocation.reload(); //重新加载（有可能从缓存中加载）\n\nlocation.reload(true); //重新加载（从服务器重新加载）\n```\n位于reload()调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。为此，最好将reload()放在代码的最后一行。\n\n<br/>\n<br/>\n<br/>\n\n### navigator对象\n\nnavigator对象：识别客户端浏览器的事实标准。\n\n<br/>\n\n#### 检测插件\n检测浏览器中是否安装了特定的插件：\n\n* 对于 **非IE浏览器**：\n使用 __`plugins`__ 数组，该数组中每一项都包含下列属性：\n\n    1. **name** ：插件的名字；\n    2. **description**：插件的描述；\n    3. **filename**：插件的文件名；\n    4. **length**：插件所处理的 MIME 类型数量。\n\n>一般来说，name 属性中会包含检测插件必需的所有信息，但有时候也不完全如此。\n\n    在检测插件时，需要像下面这样循环迭代每个插件并将插件的name 与给定的名字进行比较：\n```javascript\n//检测插件（在IE 中无效）\nfunction hasPlugin(name) {\n    name = name.toLowerCase();\n    for (var i = 0; i < navigator.plugins.length; i++) {\n        if (navigator.plugins[i].name.toLowerCase().indexOf(name) > -1) {\n            return true;\n        }\n    }\n    return false;\n}\n//检测Flash\nalert(hasPlugin(\"Flash\"));\n//检测QuickTime\nalert(hasPlugin(\"QuickTime\"));\n```\n\n* 对于 **IE浏览器**：\n在IE 中检测插件的唯一方式就是使用专有的 **ActiveXObject** 类型，并**尝试创建一个特定插件的实例**。IE 是以 COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其 **COM标识符**。\n```javascript\n//检测IE 中的插件\nfunction hasIEPlugin(name) {\n    try {\n        new ActiveXObject(name);\n        return true;\n    } catch (ex) {\n        return false;\n    }\n}\n//检测Flash\nalert(hasIEPlugin(\"ShockwaveFlash.ShockwaveFlash\"));\n//检测QuickTime\nalert(hasIEPlugin(\"QuickTime.QuickTime\"));\n```\n\n典型的做法是 <u>针对每个插件分别创建检测函数</u>，而不是使用前面介绍的通用检测方法：\n```javascript\n//检测所有浏览器中的Flash\nfunction hasFlash() {\n    var result = hasPlugin(\"Flash\");\n    if (!result) {\n        result = hasIEPlugin(\"ShockwaveFlash.ShockwaveFlash\");\n    }\n    return result;\n}\n\n//检测所有浏览器中的QuickTime\nfunction hasQuickTime() {\n    var result = hasPlugin(\"QuickTime\");\n    if (!result) {\n        result = hasIEPlugin(\"QuickTime.QuickTime\");\n    }\n    return result;\n}\n\n//检测Flash\nalert(hasFlash());\n//检测QuickTime\nalert(hasQuickTime());\n```\n<br/>\n\n#### 注册处理程序\nFirefox 2 为navigator 对象新增了 **registerContentHandler()** 和 **registerProtocolHandler()** 方法（这两个方法是在HTML5 中定义的）。这两个方法可以让一个站点指明它可以处理特定类型的信息。随着RSS 阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。\n\n<br/>\n<br/>\n<br/>\n\n### screen对象\nscreen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。\n\n<br/>\n<br/>\n<br/>\n\n### history对象\nhistory 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history 是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history 对象与特定的window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的URL。不过，借由用户访问过的页面列表，同样可以在不知道实际URL 的情况下实现后退和前进。\n\n使用 **go()** 方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个**整数值**。负数表示向后跳转（类似于单击浏览器的“后退”按钮），正数表示向前跳转（类似于单击浏览器的“前进”按钮）。也可以给go()方法传递一个**字符串参数**，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。如果历史记录中不包含该字符串，那么这个方法什么也不做。\n\n另外，还可以使用两个简写方法 **back()** 和 **forward()** 来代替go()。顾名思义，这两个方法可以模仿浏览器的“后退”和“前进”按钮。\n\nhistory 对象还有一个 **length 属性**，保存着历史记录的数量。这个数量包括所有历史记录，即所有向后和向前的记录。对于加载到窗口、标签页或框架中的第一个页面而言，history.length 等于0。\n\n\n<br/>\n<br/>\n<br/>\n","tags":["JavaScript","JavaScript高级程序设计"]},{"title":"JavaScript 函数表达式","url":"/2020/01/05/JavaScript-函数表达式/","content":"\n\n定义函数的方式：\n（1）函数声明：函数声明提升；\n（2）函数表达式：创建的函数是 匿名函数，在使用前必须先赋值。\n\n>**函数声明提升**（function declaration hoisting）：在执行代码之前会先读取函数声明。\n>&emsp;&emsp;**匿名函数**（anonymous function）：匿名函数的 name 属性是空字符串。\n\n<br/>\n<br/>\n<br/>\n\n### 递归\n递归函数：一个函数通过 **名字** 调用自身。\n__`arguments.callee`__  是一个 **指向正在执行的函数的指针**，因此可以用它来实现对函数的递归调用。\n```javascript\nfunction factorial(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num - 1);\n    }\n}\n```\n但在严格模式下，不能通过脚本访问 `arguments.callee`，访问这个属性会导致错误。不过，可以使用 **命名函数表达式** 来达成相同的结果：\n```javascript\nvar factorial = (function f(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * f(num - 1);\n    }\n});\n```\n以上代码创建了一个名为 `f()` 的命名函数表达式，然后将它赋值给变量 `factorial`。**即便把函数赋值给了另一个变量，函数的名字f 仍然有效。**\n\n<br/>\n<br/>\n<br/>\n\n### 闭包\n\n>**闭包**：有权访问 **另一个函数 作用域中的变量** 的函数。\n>**创建闭包** 的常见方式：在一个函数内部 创建另一个函数。\n>\n>闭包会携带包含它的函数的作用域，因此比其他函数 **占用更多内存**，可通过**赋值 null** 来解除对匿名函数的引用，以便释放内存（JS垃圾回收机制）。\n>\n>**闭包的作用**：（1）模仿块级作用域；（2）在对象中创建私有变量。\n\n**ABOUT 函数调用：**\n>当某个**函数被调用**时：\n>（1）会创建一个 **执行环境**（execution context）及相应的 **作用域链**。\n>（2）使用 <u>arguments 和 其他命名参数的值</u> 来 **初始化** 函数的 **活动对象**（activation object）。\n>\n>  *注意*：在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为 **作用域链终点** 的 **全局执行环境**。\n\n**ABOUT 执行环境：**\n>后台的每个 **执行环境** 都有一个表示变量的对象——**变量对象**。\n> - **全局环境** 的变量对象 <u>始终存在</u>。\n> - **局部环境** 的变量对象，则只在 <u>函数执行的过程中</u> 存在。\n\n**ABOUT 作用域链：**\n> - **作用域链** 本质上是一个 **指向变量对象的指针列表**，它 **只引用** 但不实际包含变量对象。\n> - 无论什么时候在函数中访问一个变量时，就会 <u>从作用域链中</u> 搜索具有相应名字的变量。\n> - 一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。\n> - **在另一个函数内部定义的函数（闭包）** 会将包含函数（即外部函数）的活动对象添加到它的作用域链中。包含函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象（*<u>换句话说，包含函数执行完毕后，其执行环境的**作用域链会被销毁**，但其 **活动对象仍被保留在内存**中，直到匿名函数被销毁</u>*）。\n\n```javascript\n// 比较函数（闭包）\nfunction createComparisonFunction(propertyName) {\n    return function (object1, object2) {\n        var value1 = object1[propertyName];\n        var value2 = object2[propertyName];\n        if (value1 < value2) {\n            return -1;\n        } else if (value1 > value2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\n\n//创建函数\nvar compareNames = createComparisonFunction(\"name\");\n//调用函数\nvar result = compareNames({ name: \"Nicholas\" }, { name: \"Greg\" });\n//解除对匿名函数的引用（以便释放内存）\ncompareNames = null;\n```\n\n{% asset_img 闭包.png JavaScript闭包 %}\n\n<br/>\n\n#### 闭包与变量\n作用域链 **引发的问题**：闭包只能取得 包含函数中任何变量的 **最后一个值**。\n```javascript\nfunction createFunctions() {\n    var result = new Array();\n    for (var i = 0; i < 10; i++) {\n        result[i] = function () {\n            return i;\n        };\n    }\n    return result;\n}\n```\n这个函数会返回一个函数数组，每个函数都返回10。\n>原因分析：因为每个函数的作用域链中都保存着createFunctions() 函数的活动对象， 所以它们引用的都是同一个变量i 。当createFunctions()函数返回后，变量i 的值是10，此时每个函数都引用着保存变量i 的同一个变量对象，所以在每个函数内部i 的值都是10。\n\n\n我们可以通过 **创建另一个匿名函数** 强制让闭包的行为符合预期：\n```javascript\nfunction createFunctions() {\n    var result = new Array();\n    for (var i = 0; i < 10; i++) {\n        result[i] = function (num) {\n            return function () {\n                return num;\n            };\n        }(i);\n    }\n    return result;\n}\n```\n上述函数返回的函数数组中，每个函数会返回 各自不同的索引值。\n\n>原因分析：在这个版本中，我们 **没有直接把闭包赋值给数组**，而是\n>（1）定义了一个**匿名函数**，并将 **立即执行该匿名函数的结果** 赋给数组。\n>（2）匿名函数有一个 **参数num**，也就是最终的函数要返回的值。\n>（3）在调用每个匿名函数时，我们传入了 **变量i**。\n>（4）由于 **函数参数** 是 **按值传递** 的，所以就会 **将变量i 的当前值复制给参数num**。\n>（5）而在这个**匿名函数内部**，又创建并返回了一个**访问num 的闭包**。\n>\n>这样一来，result 数组中的每个函数 <u>都有自己num 变量的一个副本</u> ，因此就可以返回各自不同的数值了。\n\n<br/>\n\n#### this对象\n在闭包中使用 this对象 可能引发的问题：\n**匿名函数** 的**执行环境具有全局性**，其 this对象通常指向 **window**。\n\n>this 对象是在运行时基于函数的执行环境绑定的：\n> - 在全局函数中，this 等于window；\n> - 当函数被作为某个对象的方法调用时，this 等于那个对象。\n\n```javascript\nvar name = \"The Window\";\nvar object = {\n    name: \"My Object\",\n    getNameFunc: function () {\n        return function () {\n            return this.name;\n        };\n    }\n};\nalert(object.getNameFunc()()); //\"The Window\"（在非严格模式下）\n```\n为什么匿名函数没有取得其包含作用域（或外部作用域）的this 对象呢？\n每个函数在被调用时都会自动取得两个特殊变量：`this` 和 `arguments` 。内部函数在搜索这两个变量时，只会搜索到其**活动对象**为止。\n```javascript\nvar name = \"The Window\";\nvar object = {\n    name: \"My Object\",\n    getNameFunc: function () {\n        var that = this;\n        return function () {\n            return that.name;\n        };\n    }\n};\nalert(object.getNameFunc()()); //\"My Object\"\n```\n在定义匿名函数之前，我们把 this对象 赋值给了一个名叫 `that` 的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声名的一个变量。\n\n<br/>\n\n#### 内存泄漏\n在低版本IE（<IE9）中，如果 闭包的作用域链中 保存着一个HTML 元素，那么就意味着该元素将无法被销毁。\n```javascript\nfunction assignHandler() {\n    var element = document.getElementById(\"someElement\");\n    element.onclick = function () {\n        alert(element.id);\n    };\n}\n```\n以上代码创建了一个作为element 元素事件处理程序的闭包，而这个闭包则又创建了一个 **循环引用**。element 的引用数至少为1，因此它所占用的内存永远不会被回收。\n```javascript\nfunction assignHandler() {\n    var element = document.getElementById(\"someElement\");\n    var id = element.id; // 消除循环引用\n    element.onclick = function () {\n        alert(id);\n    };\n    // 闭包会引用 包含函数的整个活动对象，其中包含element\n    element = null; // 消除对 DOM对象的引用，以减少其引用数\n}\n```\n\n<br/>\n<br/>\n<br/>\n\n### 模仿块级作用域\n> - JavaScript 没有块级作用域；\n> - JavaScript 中，多次声明了同一个变量，js会对后续的声明视而不见，但是会执行后续声明中的变量初始化。\n\n**匿名函数** 可以用来 **模仿块级作用域** 并 **避免多次声明同一变量**。\n用作块级作用域（通常称为**私有作用域**）的匿名函数的语法如下：\n```javascript\n(function () {\n    //这里是块级作用域\n})();\n```\n**将函数声明包含在一对圆括号中，表示它实际上是一个<u>函数表达式</u>。而紧随其后的另一对圆括号会<u>立即调用</u>这个函数。** \n\n无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：\n```javascript\nfunction outputNumbers(count) {\n    (function () {\n        for (var i = 0; i < count; i++) {\n            alert(i);\n        }\n    })();\n    alert(i); //导致一个错误！\n}\n```\n在匿名函数中定义的任何变量，都会在执行结束时被销毁。\n\n>这种技术经常 在全局作用域中被用在函数外部，从而 **限制向全局作用域中添加过多的变量和函数**。\n>这种做法可以 **减少闭包占用的内存问题**，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。\n\n<br/>\n<br/>\n<br/>\n\n### 私有变量\n>**私有变量**：任何在函数中定义的变量，包括 <u>函数参数</u>、<u>局部变量</u>、<u>在函数内部定义的其他函数</u>。（不能在函数外部访问这些变量）\n>**特权方法**（privileged method）：有权访问私有变量和私有函数的公有方法。\n>\n>在对象上 **创建特权方法** 的方式：\n>（1）在构造函数中定义特权方法；\n>（2）静态私有变量。\n\n在构造函数中定义特权方法：\n```javascript\nfunction MyObject() {\n    //私有变量和私有函数\n    var privateVariable = 10;\n    function privateFunction() {\n        return false;\n    }\n    //特权方法\n    this.publicMethod = function () {\n        privateVariable++;\n        return privateFunction();\n    };\n}\n```\n缺点：必须使用 <u>*构造函数模式*</u> 来达到这个目的。\n**构造函数模式** 的缺点：针对每个实例都会创建同样一组新方法。\n使用 *静态私有变量* 来实现特权方法可以避免这个问题。\n\n<br/>\n\n#### 静态私有变量\n>**静态私有变量**：在 <u>**私有作用域**</u> 中定义私有变量或函数。\n```javascript\n(function () {\n    //私有变量和私有函数\n    var privateVariable = 10;\n    function privateFunction() {\n        return false;\n    }\n    //构造函数\n    MyObject = function () {\n    };\n    //公有/特权方法\n    MyObject.prototype.publicMethod = function () {\n        privateVariable++;\n        return privateFunction();\n    };\n})();\n```\n在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。\n<u>注意点</u>：\n\n1. 这个模式在定义构造函数时并没有使用函数声明，而是使用了 **函数表达式**；\n2. 定义构造函数时，没有使用 `var` 关键字。\n\n>（1）函数声明只能创建 局部函数；\n>（2）初始化未经声明的变量，总是会创建一个 全局变量；但在严格模式下，给未经声明的变量赋值会导致错误。\n\n这个模式 与 在构造函数中定义特权方法 的**主要区别**，就在于 私<u>**有变量和函数是由实例共享的**</u>。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。\n\n<br/>\n\n#### 模块模式\n>**模块模式**（module pattern）：为 单例 创建私有变量和特权方法。\n>**单例**（singleton）：只有一个实例的对象。\n>\n>按照惯例，JavaScript 是以 **对象字面量** 的方式来创建单例对象的。\n\n```javascript\nvar singleton = function () {\n    //私有变量和私有函数\n    var privateVariable = 10;\n    function privateFunction() {\n        return false;\n    }\n    //特权/公有方法和属性\n    return {\n        publicProperty: true,\n        publicMethod: function () {\n            privateVariable++;\n            return privateFunction();\n        }\n    };\n}();\n```\n这个模块模式使用了一个 <u>返回对象的匿名函数</u>。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。\n\n简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 **Object 的实例**，因为最终要<u>通过一个对象字面量来表示</u>它。\n\n<br/>\n\n#### 增强的模块模式\n>  增强的模块模式 适合：\n>（1）单例必须是 **某种类型的实例**；\n>（2）必须 **添加** 某些 **属性或方法** 对其加以增强。\n\n```javascript\nvar singleton = function () {\n    //私有变量和私有函数\n    var privateVariable = 10;\n    function privateFunction() {\n        return false;\n    }\n    //创建对象\n    var object = new CustomType();\n    //添加特权/公有属性和方法\n    object.publicProperty = true;\n    object.publicMethod = function () {\n        privateVariable++;\n        return privateFunction();\n    };\n    //返回这个对象\n    return object;\n}();\n```\n\n>实现**自定义类型**的特权方法：（1）构造函数模式；（2）原型模式。\n>实现**单例**的特权方法：（1）模块模式；（2）增强的模块模式。\n\n\n<br/>\n<br/>\n<br/>\n","tags":["JavaScript","JavaScript高级程序设计"]},{"title":"ES6 - 字符串的扩展","url":"/2020/01/05/ES6-字符串的扩展/","content":"\n\n本文仅为学习笔记，详情请见[阮一峰《ECMAScript 入门》](http://es6.ruanyifeng.com/)\n\n<br/>\n\n### 字符的 Unicode 表示法\n\nJavaScript 共有 6 种方法可以**表示一个字符**：\n```javascript\n'\\z' === 'z'  // true\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n'\\u{7A}' === 'z' // true\n```\n\nES6 加强了对 Unicode 的支持，允许采用 `\\uxxxx` 形式表示一个字符，其中 `xxxx`表示字符的 **Unicode 码点**。\n\n但是，这种表示法只限于码点在 `\\u0000` ~ `\\uFFFF` 之间的字符。超出这个范围的字符，必须用 **两个双字节** 的形式表示。\n```javascript\n\"\\u0061\"\n// \"a\"\n\n\"\\uD842\\uDFB7\"\n// \"𠮷\"\n\"\\u20BB7\"\n// \" 7\"\n// 如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。\n```\n\nES6 对这一点做出了改进，只要 **将码点放入大括号**，就能正确解读该字符。\n```javascript\n\"\\u{20BB7}\"\n// \"𠮷\"\n\n\"\\u{41}\\u{42}\\u{43}\"\n// \"ABC\"\n\nlet hello = 123;\nhell\\u{6F} // 123\n\n'\\u{1F680}' === '\\uD83D\\uDE80'\n// true\n```\n上面代码中，最后一个例子表明，**大括号表示法与四字节的 UTF-16 编码是等价**的。\n\n\n<br/>\n<br/>\n<br/>\n\n\n### 字符串的遍历器接口\n\nES6 为字符串添加了遍历器接口，使得字符串可以被 **`for...of` 循环遍历**。\n```javascript\nfor (let codePoint of 'foo') {\n  console.log(codePoint)\n}\n// \"f\"\n// \"o\"\n// \"o\"\n```\n除了遍历字符串，这个遍历器最大的优点是 **可以识别大于0xFFFF的码点**，传统的for循环无法识别这样的码点。\n```javascript\nlet text = String.fromCodePoint(0x20BB7);\n\nfor (let i = 0; i < text.length; i++) {\n  console.log(text[i]);}\n// \" \"\n// \" \"\nfor (let i of text) {\n  console.log(i);}\n// \"𠮷\"\n```\n上面代码中，字符串text只有一个字符，但是 `for` 循环会认为它包含两个字符（都不可打印），而 `for...of` 循环会正确识别出这一个字符。\n\n<br/>\n<br/>\n<br/>\n\n\n### 直接输入 U+2028 和 U+2029\n\nJavaScript 字符串允许 **直接输入字符**，以及 **输入字符的转义形式**。\n```javascript\n'中' === '\\u4e2d' // true\n```\n但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，**只能** 使用 **转义形式**：\n\n1. **U+005C**：反斜杠（reverse solidus)\n2. **U+000D**：回车（carriage return）\n3. **U+2028**：行分隔符（line separator）\n4. **U+2029**：段分隔符（paragraph separator）\n5. **U+000A**：换行符（line feed）\n\n\n>**JSON 格式** 允许字符串里面 **直接使用** U+2028（行分隔符）和 U+2029（段分隔符）。\n\n服务器输出的 JSON 被 `JSON.parse` 解析，就有可能直接报错。\n\n<br/>\n<br/>\n<br/>\n\n\n### JSON.stringify() 的改造\n\n根据标准，JSON 数据必须是 UTF-8 编码。\n\n>UTF-8 标准规定，**`0xD800` 到 `0xDFFF` 之间的码点，不能单独使用，必须配对使用** 。比如，`\\uD834\\uDF06`是两个码点，但是必须放在一起配对使用，代表字符 𝌆。这是为了表示码点大于 `0xFFFF` 的字符的一种变通方法。单独使用 `\\uD834` 和 `\\uDFO6` 这两个码点是不合法的，或者颠倒顺序也不行，因为`\\uDF06\\uD834`并没有对应的字符。\n\n\n`JSON.stringify()` 的问题在于，它可能返回 `0xD800` 到 `0xDFFF` 之间的单个码点。\n```javascript\nJSON.stringify('\\u{D834}') // \"\\u{D834}\"\n```\n为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。\n```javascript\nJSON.stringify('\\u{D834}') // \"\"\\\\uD834\"\"\nJSON.stringify('\\uDF06\\uD834') // \"\"\\\\udf06\\\\ud834\"\"\n```\n\n<br/>\n<br/>\n<br/>\n\n### 模板字符串\n\n>**模板字符串**（template string）是增强版的字符串，用 **反引号（`）** 标识。它可以当作普通字符串使用，也可以用来定义 **多行字符串**，或者 **在字符串中嵌入变量**。\n\n```javascript\n// 普通字符串\n`In JavaScript '\\n' is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n// 字符串中嵌入变量\nlet name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n```javascript\nlet greeting = `\\`Yo\\` World!`;\n```\n如果使用模板字符串表示多行字符串，**所有的 空格 和 缩进 都会被保留**在输出之中。\n```javascript\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`);\n```\n可以使用 `trim` 方法消除字符串首尾的空白字符（换行符、空格及连续空格、制表符tab）：\n```javasccript\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`.trim());\n```\n\n模板字符串中 **嵌入变量**，需要将变量名写在 `${}` 之中。\n```javascript\nfunction authorize(user, action) {\n  if (!user.hasPrivilege(action)) {\n    throw new Error(\n      // 传统写法为\n      // 'User '\n      // + user.name\n      // + ' is not authorized to do '\n      // + action\n      // + '.'\n      `User ${user.name} is not authorized to do ${action}.`);\n  }}\n```\n大括号内部可以放入任意的 JavaScript 表达式，可以 **进行运算**，以及 **引用对象属性**。\n```javascript\nlet x = 1;\nlet y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\n\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// \"3\"\n```\n模板字符串之中还能 **调用函数**：\n```javascript\nfunction fn() {\n  return \"Hello World\";\n}\n\n`foo ${fn()} bar`\n// foo Hello World bar\n```\n如果大括号中的值不是字符串，将按照一般的规则转为字符串。\n\n\n模板字符串甚至还能嵌套：\n```javascript\nconst tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n\n// 使用方法如下\nconst data = [\n    { first: '<Jane>', last: 'Bond' },\n    { first: 'Lars', last: '<Croft>' },\n  ];\n\nconsole.log(tmpl(data));\n// <table>\n//\n//   <tr><td><Jane></td></tr>\n//   <tr><td>Bond</td></tr>\n//\n//   <tr><td>Lars</td></tr>\n//   <tr><td><Croft></td></tr>\n//\n// </table>\n```\n如果需要引用模板字符串本身，在需要时执行，可以写成函数。\n```javascript\nlet func = (name) => `Hello ${name}!`;\nfunc('Jack') // \"Hello Jack!\"\n```\n上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。\n\n<br/>\n<br/>\n<br/>\n\n### 实例：模板编译\n（待补充）\n\n<br/>\n<br/>\n<br/>\n\n### 标签模板\n\n“标签模板”功能（tagged template）：“标签模板”可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。\n```javascript\nalert`123`\n// 等同于\nalert(123)\n```\n标签模板其实不是模板，而是 **函数调用** 的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。\n\n但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\n```javascript\nlet a = 5;\nlet b = 10;\n\ntag`Hello ${ a + b } world ${ a * b }`;\n// 等同于\ntag(['Hello ', ' world ', ''], 15, 50);\n// 这是函数实际的调用方式\n```\n函数tag依次会接收到多个参数。\n```javascript\nfunction tag(stringArr, value1, value2){\n  // ...\n}\n\n// 等同于\nfunction tag(stringArr, ...values){\n  // ...\n}\n```\n`tag`函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。`tag`函数的其他参数，都是模板字符串各个变量被替换后的值。\n```javascript\nlet total = 30;\nlet msg = passthru`The total is ${total} (${total*1.05} with tax)`;\n\nfunction passthru(literals) {\n  let result = '';\n  let i = 0;\n\n  while (i < literals.length) {\n    result += literals[i++];\n    if (i < arguments.length) {\n      result += arguments[i];\n    }\n  }\n\n  return result;\n}\n\nmsg // \"The total is 30 (31.5 with tax)\"\n```\npassthru函数采用 rest 参数的写法如下：\n```javascript\nfunction passthru(literals, ...values) {\n  let output = \"\";\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += literals[index] + values[index];\n  }\n\n  output += literals[index]\n  return output;}\n```\n\n“标签模板”的重要应用：\n\n（1） **过滤 HTML 字符串，防止用户输入恶意内容**。\n```javascript\nlet message =\n  SaferHTML`<p>${sender} has sent you a message.</p>`;\n\nfunction SaferHTML(templateData) {\n  let s = templateData[0];\n  for (let i = 1; i < arguments.length; i++) {\n    let arg = String(arguments[i]);\n\n    // Escape special characters in the substitution.\n    s += arg.replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\");\n\n    // Don't escape special characters in the template.\n    s += templateData[i];\n  }\n  return s;\n}\n\n// sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。\nlet sender = '<script>alert(\"abc\")</script>'; // 恶意代码\nlet message = SaferHTML`<p>${sender} has sent you a message.</p>`;\n\nmessage\n// <p>&lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message.</p>\n```\n（2）多语言转换（国际化处理）\n```javascript\ni18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`\n// \"欢迎访问xxx，您是第xxxx位访问者！\"\n```\n\n（3）模拟 Mustache 之类的模板库（添加条件判断、循环处理等功能）\n```javascript\n// 下面的hashTemplate函数\n// 是一个自定义的模板处理函数\nlet libraryHtml = hashTemplate`\n  <ul>\n    #for book in ${myBooks}\n      <li><i>#{book.title}</i> by #{book.author}</li>\n    #end\n  </ul>\n`;\n```\n\n（4）在 JavaScript 语言之中嵌入其他语言\n```javascript\njsx`\n  <div>\n    <input\n      ref='input'\n      onChange='${this.handleChange}'\n      defaultValue='${this.state.value}' />\n      ${this.state.value}\n   </div>\n`\n```\n上面的代码通过 `jsx` 函数，<u>将一个 **DOM 字符串**转为 **React 对象**</u>。\n\n\n模板处理函数的第一个参数（模板字符串数组），还有一个raw属性，保存转义后的原字符串。\n```javascript\ntag`First line\\nSecond line`\n\nfunction tag(strings) {\n  console.log(strings.raw[0]);\n  // strings.raw[0] 为 \"First line\\\\nSecond line\"\n  // 打印输出 \"First line\\nSecond line\"\n}\n```\n上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[\"First line\\nSecond line\"]，那么strings.raw数组就是[\"First line\\\\nSecond line\"]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\n视为\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。\n\n<br/>\n<br/>\n<br/>\n","tags":["ECMAScript","JavaScript"]},{"title":"ES6 - 变量的解构赋值","url":"/2019/11/21/ES6-变量的解构赋值/","content":"\n\n本文仅为学习笔记，详情请见[阮一峰《ECMAScript 入门》](http://es6.ruanyifeng.com/)\n\n> **解构**（Destructuring）：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值。\n\n<br/>\n\n>**常见用途**：\n> （1）交换变量的值；\n> （2）从函数返回多个值；\n> （3）函数参数的定义；\n> （4）提取 JSON 数据；\n> （5）函数参数的默认值；\n> （6）遍历 Map 结构；\n> （7）输入模块的指定方法。\n\n<br/>\n\n### 数组的解构赋值\n\n#### 基本用法\n本质上，这种写法属于“**模式匹配**”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于undefined。\n```javascript\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n```\n\n另一种情况是 **不完全解构**，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\n\n```javascript\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n```\n\n对于 **Set 结构**，也可以使用数组的解构赋值。\n```javascript\nlet [x, y, z] = new Set(['a', 'b', 'c']);\nx // \"a\"\n```\n\n事实上，只要某种数据结构具有 **Iterator 接口**，都可以采用数组形式的解构赋值。\n```javascript\nfunction* fibs() {\n  let a = 0;\n  let b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }}\n\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。\n\n<br/>\n\n#### 默认值\n\n解构赋值允许指定默认值。\n\n只有当一个数组成员**严格等于undefined**，默认值才会生效。\n```javascript\nlet [foo = true] = [];\nfoo // true\n\nlet [x, y = 'b'] = ['a']; // x='a', y='b'\nlet [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n\nlet [x = 1] = [null];\nx // null\n```\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\n```javascript\nfunction f() {\n  console.log('aaa');}\n\nlet [x = f()] = [1];\n\n// 上述代码等价于\nlet x;\nif ([1][0] === undefined) {\n  x = f();\n } else {\n  x = [1][0];\n }\n```\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n```javascript\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError: y is not defined\n```\n\n>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。\n\n<br/>\n<br/>\n\n### 对象的解构赋值\n\n#### 基本用法\n\n对象的解构与数组有一个重要的不同。数组的元素是 **按次序排列** 的，变量的取值由它的位置决定；而对象的属性**没有次序**，**变量必须与属性同名**，才能取到正确的值。\n\n如果解构失败，变量的值等于undefined。\n```javascript\nlet { bar, foo } = { foo: 'aaa', bar: 'bbb' };\nfoo // \"aaa\"\nbar // \"bbb\"\nlet { baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // undefined\n```\n\n**对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量**。\n```javascript\n// 例一\nlet { log, sin, cos } = Math;\n\n// 例二\nconst { log } = console;log('hello') // hello\n```\n上面代码的例一将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将console.log赋值到log变量。\n\n\n对象的解构赋值是下面形式的简写：\n```JavaScript\nlet { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };\n```\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。\n```javascript\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n```\n上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。\n\n与数组一样，解构也可以用于 嵌套结构的对象：\n```javascript\nconst node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // Object {start: Object}\nstart // Object {line: 1, column: 5}\n```\n解构赋值中，`：`前边的 loc、start 都是模式，不是变量。\n\n注意，对象的解构赋值可以取到继承的属性。\n```javascript\nconst obj1 = {};\nconst obj2 = { foo: 'bar' };\nObject.setPrototypeOf(obj1, obj2);\n\nconst { foo } = obj1;\nfoo // \"bar\"\n```\n上面代码中，对象obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性。\n\n<br/>\n\n#### 默认值\n\n默认值生效的条件是，对象的属性值严格等于undefined。\n```javascript\nvar {x: y = 3} = {};\ny // 3\nvar {x: y = 3} = {x: 5};\ny // 5\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n\nvar {x = 3} = {x: undefined};\nx // 3\nvar {x = 3} = {x: null};\nx // null\n```\n<br/>\n\n#### 注意点\n\n（1）<u>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</u>\n```javascript\n// 错误的写法\nlet x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n```\n上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。\n```javascript\n// 正确的写法\nlet x;\n({x} = {x: 1});\n```\n上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。\n\n（2）<u>解构赋值允许等号左边的模式之中，不放置任何变量名。</u>因此，可以写出非常古怪的赋值表达式。\n```javascript\n({} = [true, false]);\n({} = 'abc');\n({} = []);\n// 以上表达式毫无意义，但语法合法\n```\n\n（3）<u>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</u>\n```javascript\nlet arr = [1, 2, 3];\nlet {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n```\n上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“**属性名表达式**”。（对象的扩展）\n\n<br/>\n<br/>\n\n### 字符串的解构赋值\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个 **类似数组的对象**。\n\n类似数组的对象都有一个 **length属性**，因此还可以对这个属性解构赋值。\n```javascript\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\nlet {length : len} = 'hello';\nlen // 5\n```\n<br/>\n<br/>\n\n### 数值和布尔值的解构赋值\n\n>**解构赋值的规则**：只要等号右边的值不是对象或数组，就先将其转为对象。\n\n```javascript\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n\nlet { prop: x } = undefined; // TypeError\nlet { prop: y } = null; // TypeError\n```\n上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。\n\n由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。\n\n<br/>\n<br/>\n\n### 函数参数的解构赋值\n\n函数的参数也可以使用解构赋值。\n```javascript\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [ 3, 7 ]\n```\n上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是 `x` 和 `y` 。\n\n函数参数的解构也可以使用默认值。\n```javascript\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n```\n\nundefined就会触发函数参数的默认值。\n```javascript\n[1, undefined, 3].map((x = 'yes') => x);\n// [ 1, 'yes', 3 ]\n```\n\n<br/>\n<br/>\n\n### 圆括号问题\n\n>ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。\n>\n>建议只要有可能，就不要在模式中放置圆括号。\n\n#### 不能使用圆括号的情况\n\n1. 变量声明语句\n```javascript\n// 全部报错\nlet [(a)] = [1];\n\nlet {x: (c)} = {};let ({x: c}) = {};let {(x: c)} = {};let {(x): c} = {};\n\nlet { o: ({ p: p }) } = { o: { p: 2 } };\n```\n\n2.  函数参数（属于变量声明）\n```javascript\n// 报错\nfunction f([(z)]) { return z; }\n// 报错\nfunction f([z,(x)]) { return x; }\n```\n\n3. 赋值语句的模式\n```javascript\n// 全部报错\n({ p: a }) = { p: 42 };\n([a]) = [5];\n\n[({ p: a }), { x: c }] = [{}, {}];\n```\n<br/>\n\n#### 可以使用圆括号的情况\n\n**<u>赋值语句</u> 的 <u>非模式部分</u>**，可以使用圆括号。\n```javascript\n[(b)] = [3]; // 正确\n({ p: (d) } = {}); // 正确\n[(parseInt.prop)] = [3]; // 正确\n```\n<br/>\n<br/>\n\n### 用途\n\n（1）**交换变量的值**\n```javascript\nlet x = 1;\nlet y = 2;\n\n[x, y] = [y, x];\n```\n\n（2）**从函数返回多个值**\n函数只能返回一个值，如果要返回多个值，只能将它们放在 **数组** 或 **对象** 里返回。有了解构赋值，取出这些值就非常方便。\n```javascript\n// 返回一个数组\nfunction example() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = example();\n  \n// 返回一个对象\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nlet { foo, bar } = example();\n```\n\n（3）**函数参数的定义**\n解构赋值可以方便地将 **一组参数** 与 **变量名** 对应起来。\n```javascript\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n```\n\n（4）**提取 JSON 数据**\n```javascript\nlet jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n\n（5）**函数参数的默认值**\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n} = {}) {\n  // ... do stuff\n};\n```\n指定参数的默认值，就避免了在函数体内部再写 `var foo = config.foo || 'default foo';` 这样的语句。\n\n（6）**遍历 Map 结构**\n任何部署了 Iterator 接口的对象，都可以用 `for...of` 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，**获取键名和键值** 就非常方便。\n```javascript\nconst map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n```\n\n（7）**输入模块的指定方法**\n加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n<br/>\n<br/>\n<br/>\n","tags":["ECMAScript","JavaScript"]},{"title":"ES6 - let和const命令","url":"/2019/11/21/ES6-let和const命令/","content":"\n\n\n本文仅为学习笔记，详情请见[阮一峰《ECMAScript 入门》](http://es6.ruanyifeng.com/)\n\n\n### let命令\n\n* `let`声明的变量只在它所在的代码块有效；\n* `for`循环 的计数器，适合使用 `let`命令（设置循环变量的那部分是 父作用域，循环体内部 是一个单独的自作用域）；\n* `let` 命令**不存在变量提升**；\n* **暂时性死区**（TDZ=temporal dead zone）：在代码块内，使用 `let`声明变量之前，该变量不可用；\n* 暂时性死区 意味着 `typeof` 不再是一个百分之百安全的操作（作为比较，如果一个变量根本没有被声明，使用 `typeof` 反而不会报错）\n* `let` **不允许**在相同作用域内，**重复声明**同一变量（不能在函数内部重新声明参数）；\n\n\n<br/>\n<br/>\n\n### 块级作用域\n\nES5 只有全局作用域和函数作用域，没有块级作用域，这会导致：\n\n1. 内层变量可能会覆盖外层变量（变量提升）；\n2. 用来计数的循环变量泄露为全局变量。\n\n<br/>\n\nES6块级作用域\n\nlet实际上为 JavaScript 新增了块级作用域。\n\nES6 允许块级作用域的任意嵌套。\n\n块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。\n```javascript\n// IIFE 写法\n(function () {\n  var tmp = ...;\n  ...}());\n// 块级作用域写法\n{\n  let tmp = ...;\n  ...}\n```\n\nES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。\n\n考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要， **块级作用域内部，优先使用函数表达式** 。\n\n<br/>\n<br/>\n\n### const命令\n\n* const声明 **只读常量**；\n* const一旦声明变量，就必须 **立即初始化**，不能留到以后赋值；\n* 只在声明所在的 **块级作用域** 内有效；\n* const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用；\n* 不可重复声明。\n\n>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\n>\n>如果真的想将对象冻结，应该使用Object.freeze方法。\n>\n>`const foo = Object.freeze({});`\n\n<br/>\n<br/>\n\n### ES6 声明变量的六种方法\n\n* var 命令\n* function 命令\n* let 命令\n* const 命令\n* import 命令\n* class 命令\n\nES5 只有两种声明变量的方法：var命令和function命令。\n\n<br/>\n<br/>\n\n### 顶层对象的属性\n\n>**顶层对象**，在浏览器环境指的是**window对象**，在 Node 指的是**global对象**。\n\nES5 之中，顶层对象的属性与全局变量是等价的。\n```javascript\nwindow.a = 1;\na // 1\n\na = 2;\nwindow.a // 2\n```\n\n这导致了几个问题：\n\n1. 没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；\n2. 程序员很容易不知不觉地就创建了全局变量（比如打字出错）；\n3. 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。\n\n\n从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩：\n\n1. 为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；\n2. let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。\n\n```javascript\nvar a = 1;\n// 如果在 Node 的 REPL 环境，可以写成 global.a\n// 或者采用通用方法，写成 this.a\nwindow.a // 1\nlet b = 1;\nwindow.b // undefined\n```\n\n<br/>\n<br/>\n\n### globalThis 对象\n\nJavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。\n\n* 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window；\n* 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self；\n* Node 里面，顶层对象是global，但其他环境都不支持。\n\n同一段代码为了能够在各种环境，都能**取到顶层对象**，现在一般是使用 **this变量**，但是有局限性：\n\n* 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块；\n* 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined；\n* 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。\n\n暂时可用的解决方案：\n```javascript\n// 方法一\n(typeof window !== 'undefined'\n   ? window\n   : (typeof process === 'object' &&\n      typeof require === 'function' &&\n      typeof global === 'object')\n     ? global\n     : this);\n\n// 方法二\nvar getGlobal = function () {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');};\n```\n\n现在有一个提案，在语言标准的层面，<u>引入 **globalThis** 作为 **顶层对象**</u>。\n\n也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。\n\n**垫片库global-this** 模拟了这个提案，可以在所有环境拿到globalThis。\n\n\n<br/>\n<br/>\n<br/>","tags":["ECMAScript","JavaScript"]},{"title":"大约在冬季","url":"/2019/11/20/大约在冬季/","content":"\n\n-26-\n\n感谢爱过的人和事\n\n经历过的美好瞬间\n\n让我无惧年龄的增长\n\n‴ Be soft, be powerful ","tags":["生活"]},{"title":"侧耳倾听 Vol.5","url":"/2019/11/07/侧耳倾听-Vol-5/","content":"\n\n_\\#抄句子\\#_\n\n\n> 「我所有的自負皆來自我的自卑；\n&emsp;&emsp;&emsp;所有的英雄氣概都來自於我的軟弱。\n&emsp;&emsp;&emsp;嘴裡振振有詞是因為心裡滿是懷疑，\n&emsp;&emsp;&emsp;深情是因為痛恨自己無情。\n&emsp;&emsp;&emsp;這世界沒有一件事情是虛空而生的，\n&emsp;&emsp;&emsp;站在光里，背後就會有陰影；\n&emsp;&emsp;&emsp;這深夜裡一片寂靜，\n&emsp;&emsp;&emsp;是因為你還沒有聽見聲音。」\n&emsp;&emsp;&emsp;—— 馬良 《坦白書》\n\n\n<br/>\n\n> 「世界要妳努力考取功名 \n&emsp;&emsp;&emsp;但真誠才是最大的本領」","tags":["生活","侧耳倾听"]},{"title":"【大数据组件】YARN简介","url":"/2019/10/24/【大数据组件】YARN简介/","content":"\n\n\n**Apache YARN** ( Yet Another Resource Negotiator ) 是 hadoop 2.0 引入的 **集群资源管理系统** 。用户可以将各种服务框架部署在 YARN 上，由 YARN 进行统一地管理和资源分配。\n{% asset_img hadoop生态圈.png hadoop生态圈 %}\n\n<br/>\n\n## YARN架构\n\nYARN 的基本思想是：\n\n将 MapReduce 1 中的 JobTracker的 **资源管理** 和 **作业调度** 两个功能分开，分别由 **ResourceManager** 和 **ApplicationMaster** 进程来实现。\n\nYARN 支持多种计算框架 运行在一个集群当中，比如 MapReduce（批处理）、Strom（在线处理）、Spark、Flink 等。\n\n下图展示了 YARN 资源调度的流程：\n{% asset_img yarn资源调度流程.png yarn资源调度流程 %}\n\n* **ResourceManager** ：**全局**，负责整个集群的资源管理和调度；\n* **ApplicationMaster** ：每个 job 有一个 ApplicationMaster，负责应用程序相关的事务，比如 任务调度、任务监控和容错等；\n* **NodeManager** ：客户端框架，负责containers，监控他们的 资源使用（CPU、内存、磁盘、网络）并上报给 ResourceManager.\n* * *\n{% asset_img hadoop生态圈.png hadoop生态圈 %}\n\n<br/>\n\n### ResourceManager\n\n`ResourceManager` 通常在独立的机器上以后台进程的形式运行，它是整个集群资源的主要协调者和管理者。\n\n`ResourceManager` 负责给用户提交的所有应用程序分配资源，它根据应用程序优先级、队列容量、ACLs、数据位置等信息，做出决策，然后以共享的、安全的、多租户的方式制定分配策略，调度集群资源。\n\n**主要功能**：\n\n1. 与客户端交互，处理来自客户端的请求；\n2. 启动和管理 ApplicationMaster，并在它失败时 进行重启；\n3. 管理 NodeManager，接受来自 NM的资源汇报信息，下达管理指令；\n4. 资源调度和管理，接受 来自 AM的资源申请请求，并让 NM为之分配资源。\n\n<br/>\n\n### NodeManager\n\n`NodeManager` 是 YARN 集群中的单个计算节点的管理者。主要负责该节点内所有容器Container 的生命周期的管理，监视资源和跟踪节点健康。具体如下：\n\n* 启动时向 `ResourceManager` 注册并定时发送心跳消息，等待 `ResourceManager` 的指令；\n* 维护 `Container` 的生命周期，监控 `Container` 的资源使用情况；\n* 管理任务运行时的相关依赖，根据 `ApplicationMaster` 的需要，在启动 `Container` 之前将需要的程序及其依赖拷贝到本地。\n\n<br/>\n\n### ApplicationMaster\n\n在用户提交一个应用程序时，YARN 会启动一个轻量级的进程 `ApplicationMaster`。`ApplicationMaster` 负责协调来自 `ResourceManager` 的资源，并通过 `NodeManager` 监视容器内资源的使用情况，同时还负责任务的监控与容错。具体如下：\n\n* 根据应用的运行状态来决定动态计算资源需求；\n* 向 `ResourceManager` 申请资源，监控申请的资源的使用情况；\n* 跟踪任务状态和进度，报告资源的使用情况和应用的进度信息；\n* 负责任务的容错。\n\n<br/>\n\n### Container\n\n`Container` 是 YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等。当 AM 向 RM 申请资源时，RM 为 AM 返回的资源是用 `Container` 表示的。YARN 会为每个任务分配一个 `Container`，该任务只能使用该 `Container` 中描述的资源。`ApplicationMaster` 可在 `Container` 内运行任何类型的任务。例如，`MapReduce ApplicationMaster` 请求一个容器来启动 map 或 reduce 任务，而 `Giraph ApplicationMaster` 请求一个容器来运行 Giraph 任务。\n\n<br/>\n<br/>\n<br/>\n\n\n## YARN工作原理简述\n{% asset_img yarn工作原理简述.png yarn工作原理简述 %}\n\n\n1. `Client` 提交作业到 YARN 上；\n2. `Resource Manager` 选择一个 `Node Manager`，启动一个 `Container` 并运行 `Application Master` 实例；\n3. `Application Master` 根据实际需要向 `Resource Manager` 请求更多的 `Container` 资源（如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务）；\n4. `Application Master` 通过获取到的 `Container` 资源执行分布式计算。\n\n<br/>\n<br/>\n<br/>\n\n\n## YARN工作原理详述\n{% asset_img yarn工作原理详述.png yarn工作原理详述 %}\n\n\n1. **作业提交**\n\nclient 调用 job.waitForCompletion 方法，向整个集群提交 MapReduce 作业 (第 1 步) 。新的作业 ID(应用 ID) 由资源管理器分配 (第 2 步)。作业的 client 核实作业的输出, 计算输入的 split, 将作业的资源 (包括 Jar 包，配置文件, split 信息) 拷贝给 HDFS(第 3 步)。 最后, 通过调用资源管理器的 submitApplication() 来提交作业 (第 4 步)。\n\n2. **作业初始化**\n\n当资源管理器收到 submitApplciation() 的请求时, 就将该请求发给调度器 (scheduler), 调度器分配 container, 然后资源管理器在该 container 内启动应用管理器进程, 由节点管理器监控 (第 5 步)。\n\nMapReduce 作业的应用管理器是一个主类为 MRAppMaster 的 Java 应用，其通过创造一些 bookkeeping 对象来监控作业的进度, 得到任务的进度和完成报告 (第 6 步)。然后其通过分布式文件系统得到由客户端计算好的输入 split(第 7 步)，然后为每个输入 split 创建一个 map 任务, 根据 mapreduce.job.reduces 创建 reduce 任务对象。\n\n3. **任务分配**\n\n如果作业很小, 应用管理器会选择在其自己的 JVM 中运行任务。\n\n如果不是小作业, 那么应用管理器向资源管理器请求 container 来运行所有的 map 和 reduce 任务 (第 8 步)。这些请求是通过心跳来传输的, 包括每个 map 任务的数据位置，比如存放输入 split 的主机名和机架 (rack)，调度器利用这些信息来调度任务，尽量将任务分配给存储数据的节点, 或者分配给和存放输入 split 的节点相同机架的节点。\n\n4. **任务运行**\n\n当一个任务由资源管理器的调度器分配给一个 container 后，应用管理器通过联系节点管理器来启动 container(第 9 步)。任务由一个主类为 YarnChild 的 Java 应用执行， 在运行任务之前首先本地化任务需要的资源，比如作业配置，JAR 文件, 以及分布式缓存的所有文件 (第 10 步。 最后, 运行 map 或 reduce 任务 (第 11 步)。\n\nYarnChild 运行在一个专用的 JVM 中, 但是 YARN 不支持 JVM 重用。\n\n5. **进度和状态更新**\n\nYARN 中的任务将其进度和状态 (包括 counter) 返回给应用管理器, 客户端每秒 (通 mapreduce.client.progressmonitor.pollinterval 设置) 向应用管理器请求进度更新, 展示给用户。\n\n6. **作业完成**\n\n除了向应用管理器请求作业进度外, 客户端每 5 分钟都会通过调用 waitForCompletion() 来检查作业是否完成，时间间隔可以通过 mapreduce.client.completion.pollinterval 来设置。作业完成之后, 应用管理器和 container 会清理工作状态， OutputCommiter 的作业清理方法也会被调用。作业的信息会被作业历史服务器存储以备之后用户核查。\n\n\n<br/>\n<br/>\n<br/>","tags":["大数据"]},{"title":"【大数据组件】HDFS简介","url":"/2019/10/21/【大数据组件】HDFS简介/","content":"\n\n>**HDFS** = Hadoop Distributed File System\n>\n>**Hadoop 分布式文件系统**\n>\n>分布式文件系统：统一管理 分布在集群上 的文件系统。\n\n<br/>\n<br/>\n\n## 简述\n### HDFS 优点与局限\n\n优点：\n1. **高度容错性**，适合部署在 廉价的机器上；\n2. 提供 **高吞吐量** 的数据访问，适用于 **大规模数据集（Large Data Set）**；\n3. **流式读取** 文件系统数据，一次写入，多次读取，不能修改，只能追加。能保证数据的一致性。\n\n>注：大规模数据集，指 10^2 MB/GB/TB/PB 级别。\n\n局限：\n1. 不支持 低延迟访问（毫秒级）；\n2. 不适合 大量的小文件存储；\n3. 不支持 并发写入；\n4. 不支持修改。\n\n<br/>\n### 设计思想\n**分而治之** — 将大文件、大批量文件，分布式存放在大量服务器上，以便于采取 分而治之 的方式对海量数据进行分析运算。\n\n<br/>\n### 作用\n在 大数据系统 中，为各类分布式运算框架（如：MapReduce、spark、tez 等），提供 **数据存储** 服务。\n\n<br/>\n### 基本概念\n一个分布式文件系统，用于存储文件，通过统一的 <u>**命名空间（目录树）**</u> 来定位文件。\n\n\nHDFS是一个 **主/从（Mater/Slave）体系结构** ，HDFS集群拥有一个NameNode和一些DataNode。NameNode管理文件系统的元数据，DataNode存储实际的数据。\n\n从用户角度看，HDFS 通过 **目录路径** 对文件执行 **CRUD** 操作（Create、Read、Update、Delete）。\n\n\n* * *\n\n<u>**HDFS客户端**</u>：就是客户端。\n1、提供一些命令来管理、访问 HDFS，比如启动或者关闭HDFS。\n2、与 DataNode 交互，读取或者写入数据；读取时，要与 NameNode 交互，获取文件的位置信息；写入 HDFS 的时候，Client 将文件切分成 一个一个的Block，然后进行存储。\n3、文件切分。文件上传 HDFS 时，Client 将文件切分成一个个的 Block，然后进行存储。\n\n<u>**NameNode**</u>：即Master，\n1、管理 HDFS 的名称空间。\n2、管理数据块（Block）映射信息\n3、配置副本策略\n4、处理客户端读写请求。\n\n<u>**DataNode**</u>：就是Slave。NameNode 下达命令，DataNode 执行实际的操作。\n1、存储实际的数据块。\n2、执行数据块的读/写操作。\n\n<u>**Secondary NameNode**</u>：并非 NameNode 的热备。当NameNode 挂掉的时候，它并不能马上替换 NameNode 并提供服务。\n1、辅助 NameNode，分担其工作量。\n2、定期合并 fsimage和fsedits，并推送给NameNode。\n3、在紧急情况下，可辅助恢复 NameNode。\n\n{% asset_img hdfs架构.png hdfs架构 %}\n<br/>\n\n{% asset_img hdfs架构2.png hdfs架构2 %}\n\n\n* * *\n\n<br/>\n<br/>\n### 从HDFS读取内容\n1、首先调用DistributedFileSystem对象的open方法，其实获取的是一个DistributedFileSystem的实例。\n\n2、DistributedFileSystem通过RPC(远程过程调用)获得文件的第一批block的locations，同一block按照重复数会返回多个locations，这些locations按照hadoop拓扑结构排序，距离客户端近的排在前面。\n\n3、前两步会返回一个FSDataInputStream对象，该对象会被封装成 DFSInputStream 对象，DFSInputStream可以方便的管理DataNode和NameNode数据流。客户端调用read方法，DFSInputStream就会找出离客户端最近的DataNode并连接DataNode。\n\n4、数据从DataNode源源不断的流向客户端。\n\n5、如果第一个block块的数据读完了，就会关闭指向第一个block块的DataNode连接，接着读取下一个block块。这些操作对客户端来说是透明的，从客户端的角度来看只是读一个持续不断的流。\n\n6、如果第一批block都读完了，DFSInputStream就会去NameNode拿下一批blocks的location，然后继续读，如果所有的block块都读完，这时就会关闭掉所有的流。\n{% asset_img hdfs读取数据.png hdfs读取数据 %}\n\n\n<br/>\n<br/>\n### 向HDFS写入内容\n\n1.客户端通过调用DistributedFileSystem的create方法，创建一个新的文件。\n\n2.DistributedFileSystem通过RPC（远程过程调用）调用NameNode，去创建一个没有blocks关联的新文件。创建前，NameNode会做各种校验，比如文件是否存在，客户端有无权限去创建等。如果校验通过，NameNode 就会记录下新文件，否则就会抛出IO异常。\n\n3.前两步结束后会返回 FSDataOutputStream 的对象，和读文件的时候相似，FSDataOutputStream 被封装成 DFSOutputStream，DFSOutputStream 可以协调NameNode和 DataNode。客户端开始写数据到DFSOutputStream，DFSOutputStream会把数据切成一个个小packet，然后排成队列data queue。\n\n4.DataStreamer 会去处理接受 data queue，它先问询 NameNode 这个新的 block 最适合存储的在哪几个DataNode里，比如重复数是3，那么就找到3个最适合的DataNode，把它们排成一个 pipeline。DataStreamer 把 packet 按队列输出到管道的第一个 DataNode 中，第一个 DataNode又把 packet 输出到第二个 DataNode 中，以此类推。\n\n5.DFSOutputStream 还有一个队列叫 ack queue，也是由 packet 组成，等待DataNode的收到响应，当pipeline中的所有DataNode都表示已经收到的时候，这时akc queue才会把对应的packet包移除掉。\n\n6.客户端完成写数据后，调用close方法关闭写入流。\n\n7.DataStreamer 把剩余的包都刷到 pipeline 里，然后等待 ack 信息，收到最后一个ack 后，通知 DataNode 把文件标示为已完成。\n{% asset_img hdfs写入数据.png hdfs写入数据 %}\n\n\n<br/>\n<br/>\n### 副本存放策略\n\n一般情况下副本系数为3，HDFS的副本放置策略是：将第一个副本放在本地节点，将第二个副本放在本地机架上的另一个节点，而第三个副本放到不同机架上的节点。\n\n这种方式减少了机架间的写流量，从而提高了写的性能。机架故障的机率远小于节点故障。这种方式并不影响数据可靠性和可用性的限制，并且它确实减少了读操作的网络聚合带宽，因为文件块仅存在两个不同的机架，而不是三个。\n\n文件的副本不是均匀的分布在机架当中，1/3的副本在同一个节点上，1/3副本在同一个机架上，另外1/3个副本均匀地分布在其他机架上。\n\n<br/>\n\n**流水线复制**\n\n假设HDFS副本系数为3，当本地暂时文件积累到一个数据块大小时，client会从NameNode获取一个列表用于存放副本。然后client开始向第一个DataNode数据传输，第一个DataNode一小部分一小部分地接收数据，将每一部分写入本地仓库，并同一时间传输该部分到列表中的第二个DataNode节点。第二个DataNode也是这样，一小部分一小部分地接收数据，写入本地仓库，并同一时候转发给下一个节点，数据以流水线的方式从前一个DataNode拷贝到下一个DataNode。最后，第三个DataNode接收数据并存储到本地。因此，DataNode能流水线地从前一个节点接收数据，并同一时间转发给下一个节点，数据以流水线的方式从前一个DataNode拷贝到下一个DataNode，并以相反的方向Ack前一个Node。\n{% asset_img hdfs副本存放策略.png hdfs副本存放策略 %}\n\n\n<br/>\n<br/>\n### HA机制\n**HA = high availability 高可用性**\n\n背景：NameNode 单点故障（SPOF=single point of failure）。\n\n在 HA 机制下，可以运行一个 **Hot Standby**，作为 **热备份**（待机状态），在 Active NameNode 故障时，替代原有的 NN 成为新的 NN 提供服务。这一过程对用户透明，由客户端库完成。\n\n<u>**主要实现逻辑**</u>：\n\n1. 主备需 共享 edit log 存储；\n2. DataNode 需要同时往 主备NN 发送 Block Report；\n3. 客户端需要配置 failover 模式（失效备援模式，对用户透明）；\n4. Standby 替代 Secondary NameNode.\n\n\n\nNameNode的切换通过代failover controller来实现。failover controller有多种实现，默认实现使用ZooKeeper来保证只有一个Namenode处于active状态。\n\n每个Namenode运行一个轻量级的failover controller进程，该进程使用简单的心跳机制来监控Namenode的存活状态并在Namenode失败时触发failover。Failover可以由运维手动触发，例如在日常维护中需要切换主Namenode，这种情况graceful(优雅的) failover，非手动触发的failover称为ungraceful failover。\n\n在ungraceful failover的情况下，没有办法确定失败（被判定为失败）的节点是否停止运行，也就是说触发failover后，之前的主Namenode可能还在运行。QJM一次只允许一个Namenode写edit log，但是之前的主Namenode仍然可以接受读请求。Hadoop使用fencing来杀掉之前的Namenode。Fencing通过收回之前Namenode对共享的edit log的访问权限、关闭其网络端口使得原有的Namenode不能再继续接受服务请求。使用STONITH技术也可以将之前的主Namenode关机。\n\n\n* * *\n<br/>\n**扩展：大数据存储生态圈简介**\n\nHive与Hbase的数据一般都存储在HDFS上。HDFS为他们提供了高可靠性的底层存储支持。\n\n**Hive**\n\nHive不支持更改数据的操作，Hive基于数据仓库，提供静态数据的动态查询。其使用类SQL语言，底层经过编译转为MapReduce程序，在Hadoop上运行，数据存储在HDFS上。\n\n**HBase**\n\nHbase是Hadoop database，即Hadoop数据库。它是一个适合于非结构化数据存储的数据库，HBase基于列的而不是基于行的模式。\n\nHBase是Google Bigtable的开源实现，类似Google Bigtable利用GFS作为其文件存储系统，HBase利用HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据。\n\n\n\n<br/>\n<br/>\n<br/>\n\n\n\n","tags":["大数据"]},{"title":"Vue.js 插件","url":"/2019/10/20/Vue-js-插件/","content":"\n\n插件的使用方式：\n```javascript\nVue.use(MyPlugin)\nVue.use(MyPlugin, {\n    // 参数\n})\n```\n\n<br/>\n\n## 前端路由 与 vue-router\n\n**单页面富应用（SPA）**= **前后端分离** +  **前端路由**。\n**<u>前后端分离</u>** 的开发模式是：后端只提供 API 来返回数据，前端通过 Ajax 获取数据后，再用一定的方式渲染到页面里（后端专注于 数据，前端专注于 交互和可视化；web与移动端可共享一套 API ；首屏渲染 需要加载 js 和 css ）。\n**<u>前端路由</u>** ：由前端来维护一个路由规则。有两种实现：\n\n1. **利用 url 的 hash**，即锚点（#）：JavaScript 通过 hashChange 事件监听 url 的变化，IE7 及以下需要用轮询；\n2. **利用 HTML5 的 History 模式**：需要服务端支持。\n\n\n### vue-router\n\n路由不同的页面，实际上是 **动态加载不同的组件**。其中，每个页面对应一个组件，也就是对应一个 `.vue` 文件。\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport HelloWorld from '@/components/HelloWorld'\nimport First from '@/components/views/First'\n\nVue.use(Router)\n\nexport default new Router({\n  routes: [ {\n      path: '/first',\n      name: 'First',\n      component: First\n    }, {\n      path: '/',\n      name: 'HelloWorld',\n      component: HelloWorld\n    }, {\n      path: '*',  // 访问的路径不存在，则重定向到 HelloWorld\n      name: 'HelloWorld',\n      component: HelloWorld\n    }]\n})\n```\nRouters 里每一项的 `path` 属性就是指定 当前匹配的路径，可以带参数； `component` 是映射的组件。webpack 会把每一个路由都打包为一个 js 文件，在请求到该页面时，才去加载这个页面的 js，即异步实现的 **懒加载（按需加载）**。\n\n在 new Router() 的参数中，设置 `mode: 'history'` 会开启 HTML5 的 history 模式；默认使用 `‘#’`来设置路径。\n\n在 Vue 根实例中，通过 **<router-view>** 来挂载所有的路由组件。运行网页时，<router-view> 会根据当前路由 动态渲染 不同的页面组件。网页中一些公共部分，如顶部导航栏、侧边导航栏、底部版权信息等，可以直接写在 根实例 中，与 <router-view> 同级。\n通过 `this.$route` 可以访问当前路由的具体信息。\n\n\n### 路由跳转\n\nvue-router 有两种跳转页面的方法：\n\n1. 使用内置的 `<router-link>` 组件，它默认会被渲染成 <a>；\n2. 使用 router 实例的事件方法，如 `this.$router.push(targetUrl)` ；\n\n其中，使用 <router-link> 在 HTML5 的 history 模式下会被拦截点击，避免浏览器重新加载页面。<router-link> 的常用 prop 有：\n\n|     属性名     | 作用                                                  |\n| -------------- | ----------------------------------------------------- |\n|        to      | 指定要跳转的路径                                      |\n|        tag     | 指定渲染成什么标签                                    |\n|     replace    | 不会留下 History 记录                                 |\n|  active-class  | 修改默认的 路由匹配成功时的类名（router-link-active） |\n\n<br/>\n\n$router 的常用方法：\n\n| 方法名   | 作用                                          |\n| -------- | --------------------------------------------- |\n| push     | 添加要跳转到的新路径，会产生新的 history 记录 |\n| replace  | 替换当前的 history 记录                       |\n| go       | 在 history 记录中向前或后退多少步，参数是整数 |\n\n### vue-router 导航钩子\n\nvue-router 提供了 导航钩子 **beforeEach** 和 **afterEach** ，分别在路由即将改变前和改变后触发。通过这两个钩子，可以做一些事情来提升用户体验：\n```javascript\n/**\n * beforeEach 在路由即将改变前触发\n * @param to, 即将要进入的目标的路由对象\n * @param from, 当前导航即将要离开的路由对象\n * @param next, 调用该方法后，才能进入下一个钩子\n */\n\nrouter.beforeEach((to, from, next) => {\n  // 在页面路由改变时，统一设置网页标题\n  window.document.title = to.meta.title;\n  // 网页登录校验，未登录则跳转至登录页\n  if(window.localStorage.getItem('token')) {\n    next();\n  } else {\n    next('/login');\n  }\n});\n\n/**\n * afterEach 在路由改变后触发\n */\n\nrouter.afterEach((to, from, next) => {\n  // 切换页面后，滚动条返回顶端（滚动条默认保持上一个页面停留的位置）\n  window.scrollTo(0, 0);\n});\n```\n\n<br/>\n<br/>\n<br/>\n\n## 状态管理 与 Vuex\n\n### 状态管理与使用场景\n\n一个组件可以分为 数据（model）和 视图（view），其基本的运行模式是：数据更新时，视图也会自动更新；在视图中又可以绑定一些事件，触发 methods 里指定的方法，从而可以改变数据、更新视图。\n\n在实际业务中，会有 **跨组件共享数据** 的需求（非父子组件：跨级组件、兄弟组件），而 **Vuex** 的设计，就是用来 **统一管理组件状态** 的。\n\n### Vuex 基本用法\n\nnpm安装：\n```javascript\nnpm install --save vuex\n```\n\n在项目入口文件 main.js 里，通过 Vue.use() 使用：\n```javascript\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\nconst store = new Vuex.Store({\n    // vuex 的配置\n    state: {\n        count: 0,\n        list: [1, 5, 8, 10, 26, 35]\n    },\n    mutations: {\n        increament(state, n=1) {\n            state.count += n;\n        },\n        decrease(state) {\n            state.count --;\n        }\n    },\n    getters: {\n        filteredList: state => {\n            return state.list.filter( item => item < 10 );\n        },\n        listCount: (state, getters) => {\n            return getters.filteredList.length;\n        }\n    }，\n    actions: {\n        increment (context) {\n            context.commit('increment');\n        }\n    }\n});\n\nnew Vue({\n// ...\nstore,  // 使用 vuex\n// ...\n\n})\n```\n\n仓库 store 包含了应用的数据（状态）和操作过程。Vuex 里的数据都是响应式的，任何组件使用同一 store 的数据时，只要 store 的数据变化，对应的组件就会立即更新。\n\n数据保存在 Vuex 选项的 **state** 字段内，在任何组件内，可以直接通过 `$store.state.` 读取（注意：来自 store 的数据只能读取，不能手动改变）。\n\n改变 store 中数据的唯一途径就是 显示地提交 **mutations**，它是 Vuex的第二个选项，用来**直接修改 state 里的数据**。\n\n1. 在组件内，通过 this.$store.commit 方法来执行 mutations（组件只负责提交一个事件名， Vuex 对应的 mutations 来完成业务逻辑）：\n\n```javascript\nmethods: {\n    handleIncrement () {\n        this.$store.commit( 'increment' );\n    }\n}\n```\nmutations 的第二个参数 可以是 数字、字符串或对象等类型，当一个参数不够用时，可以传入一个对象，无限扩展。\n\n2. 提交 mutation 的另一种方式是：直接使用包含 type 属性的对象：\n```javascript\n// main.js\nmutations: {\n    increment (state, params) {\n        state.count += params.count;\n    }\n}\n\n// index.vue\nthis.$store.commit({\n    type: 'increment',\n    count: 10\n});\n```\n注意：mutation 里尽量不要 异步操作数据。\n\n### Vuex 高级用法\n\n#### getters\n\n将获取 store 中的数据的方法提取出来，放在 getters 中，便于统一管理。getter 可以依赖其他的 getter，把 getter 作为第二个参数即可。\n\n```javascript\n// index.vue\n\n<template>\n    <div>\n        <div>{{ list }}</div>\n        <div>{{ listCount }}</div>\n    </div>\n</template>\n\n<script>\n    export default {\n        computed: {\n            list () {\n                return this.$store.getters.filteredList;\n            },\n            listCount () {\n                return this.$store.getters.listCount;\n            }\n        }\n    }\n</script>\n```\n\n#### actions\n\nactions 里面提交的是 mutation，并且可以 **异步操作** 业务逻辑。\n\naction 在组件内通过 **$store.dispatch** 触发。\n\n```javascript\nmethods: {\n    handleActionIncrement () {\n        this.$store.dispatch( 'increment' );\n    }\n}\n```\n现在我们通过 Promise 异步方案 来模拟一次 延迟提交mutation：\n```javascript\n// main.js\n\nconst store = new Vuex.Store({\n    // ...\n    \n    actions: {\n        asyncIncrement (context) {\n            return new Promise( resolve => {\n                setTimeout(() => {\n                    context.commit('increment');\n                    resolve();\n                }, 1000);\n            });\n        }\n    },\n    \n    // ...\n});\n\n// index.vue\n\n<template>\n    <div>\n        {{ count }}\n        <button @click=\"handleAsyncIncrement\">async +1</button>\n    </div>\n</template>\n\n<script>\n    export default {\n        computed: {\n            count () {\n                return this.$store.state.count;\n            }\n        },\n        methods: {\n            handleAsyncIncrement () {\n                this.$store.dispatch('asyncIncrement').then( () => {\n                    console.log(this.$store.state.count); // 1\n                });\n            }\n        }\n    }\n</script>\n```\n\n> 建议：\n> &emsp;&emsp;涉及改变数据的，就使用 mutations；\n> &emsp;&emsp;存在业务逻辑的，就用 actions。\n\n<br/>\n#### modules\n\n**modules** 用来 **将 store 分割到不同模块**。当你的项目足够大时，store 里的 state、getters、mutations、actions 会非常多，都放在 main.js 里显得不是很友好，而使用 modules 可以将它们写到不同的文件中。**每个 module 拥有自己的 state、getters、mutations、actions** ，而且可以 **多层嵌套**。\n\n```javascript\nconst moduleA = {\n    state: { ... },\n    mutations: { ... },\n    actions: { ... },\n    getters: { ... }\n}\nconst moduleB = {\n    state: { ... },\n    mutations: { ... },\n    actions: { ... },\n    getters: { \n        sumCount (state, getters, rootState) {\n            return state.count + rootState.count;\n        }\n    }\n}\n\nconst store = new Vuex.Store({\n    modules: {\n        a: moduleA,\n        b: moduleB\n    }\n})\n\nstore.state.a   // moduleA 的状态 \nstore.state.b   // moduleB 的状态\n```\nmodule 的 mutation 和 getter 接收的第一个参数 state 是 **当前模块的状态**。在 actions 和 getters 中，可以接受第三个参数 **rootState**，来访问 **根节点的状态**。\n\n<br/>\n<br/>\n<br/>","tags":["JavaScript","Vue.js实战"]},{"title":"Vue.js 使用webpack","url":"/2019/10/20/Vue-js-使用webpack/","content":"\n\n## 前端工程化 与 webpack\n\n在webpack 的世界里，一张图片、一个 css 甚至一个字体，**每个文件**都是一个 **模块（Module）**，彼此存在依赖关系；webpack 就是用来处理 **模块间的依赖关系**，并把它们进行**打包**的。\n&emsp;&emsp;webpack 的主要适用场景是 **单页面富应用**（SPA）。SPA 通常是由一个 html 文件和一堆按需加载的 js 组成。\n&emsp;&emsp;ES6 语法中的 **export** 和 **import** 是用来 **导出和导入模块**的。一个模块就是一个 js 文件，它拥有独立的作用域，里面定义的变量外部无法获取。如果使用 npm 安装了一些库，在 webpack 中可以直接导入。\n```javascript\nimport Vue from 'vue';\nimport $ from 'jquery';\n```\n<br/>\n<br/>\n<br/>\n\n## webpack 基础配置\n\n### 安装\n初始化项目配置：\n```javascript\nnpm init\n```\n\n本地局部安装 webpack：\n```javascript\nnpm install webpack --save-dev\n```\n本地局部安装 webpack-dev-server：\n```javascript\nnpm install webpack-dev-server --save-dev\n```\n`--save-dev` 指 **作为开发依赖** 来安装。\n&emsp;&emsp;webpack-dev-server 提供的服务有：启动一个服务器、热更新、接口代理 等。\n\n\n### 核心概念\n\nwebpack 就是一个 `.js` 配置文件，即 webpack.config.js 。\n&emsp;&emsp;在 `package.json` 文件的 scripts 选项中添加快速启动 webpack-dev-server 服务的脚本：\n```javascript\n// ...\n\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n    \"start\": \"npm run dev\",\n    // ...\n  },\n\n// ...\n```\n当运行 `npm run dev` 命令时，就会执行 `webpack-dev-server --inline --progress --config build/webpack.dev.conf.js`  命令。\n\n\nwebpack 核心配置项：\n\n* 入口（Entry）：webpack 从哪里开始寻找依赖；\n* 出口（Output）：配置编译后的 文件存储位置 和 文件名；\n* 加载器（Loaders）：module对象的rules属性中，可以指定一系列 loaders，每个loader 都必须包含 test 和 use 两个选项。use 选项的值可以是 数组（编译顺序：从后往前）或 字符串；\n* 插件（Plugins）\n\n```javascript\nentry: {\n    app: './src/main.js'  // 单入口\n  },\n  output: {\n    path: config.build.assetsRoot, // 打包后，文件的输出目录\n    filename: '[name].js',\n    publicPath: process.env.NODE_ENV === 'production'\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath // 资源文件的引用目录\n  },\n```\n\n打包命令：\n```javascript\nwebpack --progress --hide-modules\n```\n\n<br/>\n<br/>\n<br/>\n\n## 单文件组件\n\n在使用 webpack 构建 Vue 项目的时候，可以使用一种新的构建模式：**.vue 单文件组件** 。在 webpack 中使用 `vue-loader` 就可以对 `.vue` 格式的文件进行处理。\n\n为了支持图片、文字等文件，需要安装 `url-loader` 和 `file-loader` ：\n```javascript\n{\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url-loader?limit=1024',\n },\n```\n`\"?limit=1024\"` 是指如果文件小于 `1kb`，就以 `base64` 的形式加载，不会生成一个文件。\n\n使用 单页面富应用（SPA）技术，即最终只有**一个 html 文件**，其余都是 **静态资源**。\n\n\n<br/>\n<br/>\n<br/>\n","tags":["JavaScript","Vue.js实战"]},{"title":"Vue.js Render函数","url":"/2019/10/20/Vue-js-Render函数/","content":"\n\n## Virtual DOM\n\nVirtual DOM 是一个轻量级的 Javascript 对象，在状态发生变化时，Virtual DOM 会进行 Diff 运算，只更新需要被替换的 DOM，而不是重绘。\n&emsp;&emsp;在Vue.js 2.0 中，Virtual DOM 是通过一种 **VNode 类** 表达的，每个 DOM 元素或组件 都对应一个 VNode 对象。\n\n```javascript\nexport interface VNode {\n    tag?: string; // 当前节点的标签名\n    data?: VNodeData; // 当前节点的数据对象\n    children?: VNode[]; // 子节点数组\n    text?: string; // 当前节点的文本\n    elm?: Node; // 当前虚拟节点 对应的真实的 DOM 节点\n    ns?: string; // 节点的 namespace\n    context?: Vue; // 编译作用域\n    key?: string | number; // 节点的标识，有利于 patch 的优化\n    componentOptions?: VNodeComponentOptions; // 创建组件实例时，用到的选项信息\n    componentInstance?: Vue; //\n    parent?: VNode; // 组件的占位节点\n    raw?: boolean; // 原始 html\n    isStatic?: boolean; // 静态节点的标识\n    isRootInsert: boolean; // 是否作为根节点插入\n    isComment: boolean; // 是否是 注释节点\n    isCloned?: boolean; // 是否是 克隆节点\n}\nexport interface VNodeData {\n    key?: string | number;\n    slot?: string;\n    scopedSlots?: { [key: string]: scopedSlot };\n    ref?: string;\n    tag?: string;\n    staticClass?: string;\n    class?: any;\n    staticStyle?: { [key: string]: any };\n    style?: Object[] | Object;\n    props?: { [key: string]: any };\n    attrs?: { [key: string]: any };\n    domProps?: { [key: string]: any };\n    hook?: { [key: string]: Funcion };\n    on?: { [key: string]: Function | Function[] };\n    nativeOn?: { [key: string]: Function | Function[] };\n    transition?: Object;\n    show?: boolean;\n    inlineTemplate?: {\n        render: Function;\n        staticRenderFns: Function[];\n    };\n    directives?: VNodeDirective[];\n    keepAlive?: boolean;\n}\n```\n\n\nVNode 主要可分为如下5类：\n\n* **TextVNode** 文本节点\n* **ElementVNode** 普通元素节点\n* **ComponentVNode** 组件节点\n* **EmptyVNode** 没有内容的注释节点\n* **CloneVNode** 克隆节点（可以为以上任意类型）\n\n<br/>\n<br/>\n<br/>\n\n## Render 函数\n\nRender 函数通过 `createElement` 参数来创建 Virtual DOM，有利于精简代码结构。\n\n<br/>\n<br/>\n<br/>\n\n## createElement 用法\n\n### 基本参数\n\ncreateElement 构成了 Vue Virtual DOM 的模板，它有 3 个参数：\n```javascript\ncreateElement(\n    /**\n     * {String | Object | Function} 一个HTML标签 / 组件选项 / 一个函数\n     * 必须 Return 上述其中一个\n     */\n    'div',\n    /**\n     * {Object} 一个对应属性的数据对象（可选）\n     * 可以在 template 中使用\n     */\n    {},\n    /**\n     * {String | Array} 子节点（VNode）（可选）\n     */\n    [\n        createElement('h1', 'hello world'),\n        createElement(MyComponent, {\n            props: { someProp: 'foo' }\n        }),\n        'bar'\n    ]\n)\n```\n\n&emsp;&emsp;其中，第 2 个参数 “数据对象” 的具体选项如下：\n```javascript\n{\n    // 和 v-bind: class 一样的API\n    'class': {\n        foo: true,\n        bar: false\n    },\n    // 和 v-bind: style 一样的API\n    style: {\n        color: 'red',\n        fontSize: '14px'\n    },\n    // 正常的 HTML 特性\n    attrs: {\n        id: 'foo'\n    },\n    // 组件props\n    props: {\n        myProp: 'bar'\n    },\n    // DOM 属性\n    domProps: {\n        innerHTML: 'baz'\n    },\n    // 自定义事件监听器“on”\n    // 不支持如 v-on: keyup.enter 的修饰器\n    // 需要手动匹配 keyCode\n    on: {\n        click: this.clickHandler\n    },\n    // 仅对于组件，用于监听原生事件\n    // 而不是组件使用 vm.$emit 触发的自定义事件]\n    nativeOn: {\n        click: this.nativeClickHandler\n    },\n    // 自定义指令\n    directives: [{\n        name: 'my-custom-directive',\n        value: '2',\n        expression: '1 + 1',\n        arg: 'foo',\n        modifiers: {\n            bar: true\n        }\n    }],\n    // 作用域 slot\n    // {name: props => VNode | Array<VNode>}\n    scopedSlots: {\n        default: props => h('span', props.text)\n    },\n    // 具名slot\n    slot: 'name-of-slot',\n    // 其他特殊顶层属性\n    key: 'myKey',\n    ref: 'myRef'\n}\n```\n\n### 约束\n\n所有的组件树中，如果 VNode 是 **组件** 或 **含有组件的 slot**，那么 **VNode 必须唯一**。\n&emsp;&emsp;重复渲染多个组件的方法如下：\n```javascript\n/* 重复渲染多个组件 */\n<div id=\"app\">\n    <ele></ele>\n</div>\n<script>\n// 局部声明组件\nvar Child = {\n    render: function(createElement) {\n        return createElement('p', 'text');\n    }\n};\nVue.component('ele', {\n    render: function(createElement) {\n        return createElement('div', \n            Array.apply(null, {\n                length: 5\n            }).map(function() {\n                return createElement(Child);\n            })\n        );\n    }\n});\nvar app = new Vue({\n    el: '#app'\n});\n</script>\n```\n\n对于含有组件的 slot，复用时 需要将 slot 的每个子节点都克隆一份（深度克隆）：\n```javascript\n/* 复用含有组件的slot，需要将slot的每个子节点都clone一份 */\n\n<div id=\"app\">\n    <ele>\n        <div>\n            <Child></Child>\n        </div>\n    </ele>\n</div>\n\n<script>\n// 全局注册组件\nVue.component('Child', {\n    render: function(createElement) {\n        return createElement('p', 'text');\n    }\n});\nVue.component('ele', {\n    render: function(createElement) {\n        // 克隆 slot 节点的方法\n        function cloneVNode(vnode) {\n            // 递归遍历所有子节点，并克隆(工厂函数)\n            const clonedChildren = vnode.children && \n            vnode.children.map(function(v) {\n                return cloneVNode(v);\n            });\n\n            const cloned = createElement(\n                vnode.tag,\n                vnode.data,\n                clonedChildren\n            );\n            // VNode 关键属性\n            cloned.text = vnode.text;\n            cloned.isComment = vnode.isComment;\n            cloned.componentOptions = vnode.componentOptions;\n            cloned.elm = vnode.elm;\n            cloned.context = vnode.context;\n            cloned.ns = vnode.ns;\n            cloned.isStatic = vnode.isStatic;\n            cloned.key = vnode.key;\n\n            return cloned;\n        }\n\n        const vNodes = this.$slots.default;\n        const clonedVNodes = vNodes.map(function(vnode) {\n            return cloneVNode(vnode);\n        });\n\n        return createElement('div', [\n            vNodes,\n            clonedVNodes\n        ]);\n    }\n});\n\n\nvar app = new Vue({\n    el: '#app'\n});\n</script>\n```\n\n### 使用 JavaScript 代替模板功能\n\n在 Render 函数中，**不能使用 Vue 内置的指令**，无论要实现什么功能，都可以用原生 JavaScript。\n例如，使用 JS 的for 循环来实现 v-for 如下：\n```javascript\n/* JS 实现 v-for */\n<div id=\"app\">\n    <ele :list=\"list\"></ele>\n</div>\n<script>\nVue.component('ele', {\n    render: function(createElement) {\n        var nodes = [];\n        for(var i = 0; i < this.list.length; i++) {\n            nodes.push(createElement('p', this.list[i]));\n        }\n        return createElement('div', nodes);\n    },\n    props: {\n        list: {\n            type: Array\n        }\n    }\n});\nvar app = new Vue({\n    el: '#app',\n    data: {\n        list: [\n            '《Vue.js 实战》',\n            '《JavaScript 高级程序设计》',\n            '《JavaScript 语言精粹》'\n        ]\n    }\n});\n</script>\n```\n\nRender 函数里也没有与 **v-model** 对应的API；对于 **事件修饰符** 和 **按键修饰符**，基本也需要自己实现。下面给出一个简单的发送聊天内容的场景模拟：\n```javascript\n/* 聊天发送内容的简单模拟 */\n<div id=\"app\">\n    <ele></ele>\n</div>\n<script>\nVue.component('ele', {\n    render: function(createElement) {\n        var _this = this;\n        // 渲染聊天内容列表\n        if (this.list.length) {\n            var listNode = createElement('ul', this.list.map(function(item) {\n                return createElement('li', item);\n            }));\n        } else {\n            var listNode = createElement('p', '暂无聊天内容');\n        }\n        // \n        return createElement('div', [\n            listNode,\n            createElement('input', {\n                attrs: {\n                    placeholder: '输入内容，按回车键发送'\n                },\n                style: {\n                    width: '200px'\n                },\n                on: {\n                    keyup: function(evt) {\n                        // 如果不是回车键，不发送数据\n                        if (evt.keyCode !== 13) return;\n                        // 添加输入的内容到聊天列表\n                        _this.list.push(evt.target.value);\n                        // 发送后，清空输入框\n                        evt.target.value = '';\n                    }\n                }\n            })\n        ]);\n    },\n    data: function() {\n        return {\n            value: '',\n            list: []\n        }\n    }\n});\nvar app = new Vue({\n    el: '#app'\n});\n</script>\n```\n<br/>\n<br/>\n<br/>\n\n## 函数化组件\n\n将 **functional 布尔值选项**设置为 true，可以使组件 **无状态** 和 **无实例**，即 没有 data 和 this上下文。这样用 render 函数返回虚拟节点可以更容易渲染。\n&emsp;&emsp;使用函数化组件时，Render 函数通过第二个参数 context 来提供 **临时上下文**。组件需要的 **data、props、slots、children、parent** 都是通过这个上下文来传递的。比如， `this.level` 要改写为 `context.props.level`， `this.$slots.default `改写为 `context.children` 。\n\n```javascript\n/* 用函数化组件 展示一个 根据数据 智能选择不同组件 的场景 */\n\n<div id=\"app\">\n    <smart-item :data=\"data\"></smart-item>\n    <button @click=\"change('img')\">切换为图片组件</button>\n    <button @click=\"change('video')\">切换为视频组件</button>\n    <button @click=\"change('text')\">切换为文本组件</button>\n</div>\n<script>\n// 图片组件选项\nvar ImgItem = {\n    props: ['data'],\n    render: function(createElement) {\n        return createElement('div', [\n            createElement('p', '图片组件'),\n            createElement('img', {\n                attrs: {\n                    src: this.data.url\n                }\n            }),\n        ])\n    }\n};\n// 视频组件选项\nvar VideoItem = {\n    props: ['data'],\n    render: function(createElement) {\n        return createElement('div', [\n            createElement('p', '视频组件'),\n            createElement('video', {\n                attrs: {\n                    src: this.data.url,\n                    controls: 'controls',\n                    autoplay: 'autoplay'\n                }\n            }),\n        ])\n    }\n};\n// 纯文本组件选项\nvar TextItem = {\n    props: ['data'],\n    render: function(createElement) {\n        return createElement('div', [\n            createElement('p', '纯文本组件'),\n            createElement('p', this.data.text),\n        ])\n    }\n};\n// 自定义 smart-item 组件\nVue.component('smart-item', {\n    // 函数化组件\n    functional: true,\n    render: function(createElement, context) {\n        // 根据传入的数据，智能判断显示哪种组件\n        function getComponent() {\n            var data = context.props.data;\n            // 判断 prop: data 的 type 字段是属于哪种类型的组件\n            if (data.type === 'img') return ImgItem;\n            if (data.type === 'video') return VideoItem;\n            return TextItem;\n        }\n        return createElement(\n            getComponent(),\n            {\n                props: {\n                    // 把 smart-item 的 prop: data 传给上面智能选择的组件\n                    data: context.props.data\n                }\n            },\n            context.children\n        )\n    },\n    props: {\n        data: {\n            type: Object,\n            required: true\n        }\n    }\n});\nvar app = new Vue({\n    el: '#app',\n    data: {\n        data: {}\n    },\n    methods: {\n        // 切换不同类型组件的数据\n        change: function(type) {\n            if (type === 'img') {\n                this.data = {\n                    type: 'img',\n                    url: 'https://raw.githubusercontent.com/iview/iview/master/assets/logo.png'\n                }\n            } else if (type === 'video') {\n                this.data = {\n                    type: 'video',\n                    url: 'http://vjs/zencdn.net/v/oceans.mp4'\n                }\n            } else if (type === 'text') {\n                this.data = {\n                    type: 'text',\n                    content: '这是一段纯文本'\n                }\n            }\n        }\n    },\n    created: function() {\n        // 初始化时，默认设置 图片组件 的数据\n        this.change('img');\n    }\n})\n</script>\n```\n\n上述代码中，smart-item 和 3个功能组件 都有 `prop: data`，这里通过 `createElement` 函数把 `getComponent()` 返回的对象设置为第一个参数，通过第二个参数 `context` 把 `smart-item` 的`data` 传递到选择的组件里的 `prop: data`，组件渲染出不同的内容。\n\n总的来说，函数化组件 主要适用于以下两个场景：\n\n* 程序化地在多个组件中选择一个.\n* 在将 children，props，data 传递给子组件之前 操作它们.\n\n<br/>\n<br/>\n<br/>\n\n## JSX\n使用 Render 函数最不友好的地方在于，当子节点嵌套较多时，使用 createElement 难以书写及阅读出 DOM结构。\n&emsp;&emsp;**JSX** 是一种看起来像 HTML，但实际是 **JavaScript 的语法扩展**，它用更接近 DOM 结构的形式 来描述一个组件的 UI 和状态信息。Vue.js 提供了插件 `babel-plugin-transform-vue-jsx` 来支持 JSX 语法。\n\n\n<br/>\n<br/>\n<br/>\n","tags":["JavaScript","Vue.js实战"]},{"title":"Vue.js 基础语法","url":"/2019/10/20/Vue-js-基础语法/","content":"\n\nVue.js 简介：\n\n* 用于构建用户界面的 **渐进式框架**；\n* 使用 **Virtual DOM**（**数据驱动** DOM）；\n* 提供 **响应式、组件化** 的视图组件；\n* 只关注核心库（声明式渲染+组件系统），其余交给其他库实现：\n    * 客户端路由：**Vue Router**\n    * 大规模状态管理：**Vuex**\n    * 构建工具：**Vue CLI**\n\n<br/>\n<img width=\"80%\">\n{% asset_img 虚拟dom.png Vue虚拟DOM %}\n</img>\n<img width=\"80%\">\n{% asset_img 依赖追踪.png Vue依赖追踪 %}\n</img>\n\n## vue 指令\n\n以下指令 可使用 *对象语法*、*数组语法* 或 `data`、`methods`、`computed` 选项：\n* **v-on**   绑定事件监听器（事件 / 按键修饰符）\n* **v-bind**   （1）动态更新 HTML元素；（2）class 与 style 的绑定。\n\n以下指令用于 在**表单**中双向数据绑定：\n* **v-model**    双向绑定数据\n\n以下指令用于 **组件**：\n* **v-slot**   具名插槽\n\n以下指令 可用在内置标签 `<template>` 上：\n* **v-if / v-else-if / v-else**  条件渲染\n* **v-show**   改变元素的 CSS属性 display\n* **v-for**   列表渲染指令（可用于 Array，Object）\n\n其他常用指令：\n* **v-cloak**  Vue实例 结束编译时，从绑定的 HTML元素上移除\n* **v-once**  定义它的元素/组件 只渲染一次\n* **v-html**  \n* **v-pre**   跳过编译过程\n\n### 语法糖\n\n* v-bind 可简写为 ` : ` ;\n* v-on 可简写为 `@`\n\n>语法糖：\n>&emsp;&emsp;在不影响功能的情况下，添加某种方法 实现同样的效果。\n\n\n### Vue 检测数组更新\nVue 包含了一组观察 **数组变异** 的方法，如下：\n\n* **push()  /  pop()**\n* **shift()  /  unshift()**\n* **splice()**\n* **sort()  /  reverse()**\n\n也包含一些 **非变异方法**，如下：\n\n* **filter()**\n* **concat()**\n* **slice()**\n\n注意，以下数组操作，**Vue 不能检测**到，也不会触发视图更新：\n\n* **通过索引直接设置项**：app.books[3] = { ... };\n* **修改数组长度**：app.books.length = 1;\n\n<br/>\n<br/>\n<br/>\n\n## vue 实例选项\n\n* **el**  指定一个页面中已存在的 DOM元素，来挂载 Vue实例\n* **data**   声明应用内需要双向绑定的数据\n* **computed**   计算属性（函数形式 /  `{ get: Function, set: Function }`）\n    1. 文本插值；\n    2. 动态地设置元素样式名class、内联样式style；\n    3. 使用组件时，动态传递props\n* **methods**   声明方法\n* **components**   声明组件\n* **props**   父组件传值\n* **filters**   声明过滤器（用于简单的 文本转换）\n\n<br/>\n<br/>\n<br/>\n\n## vue 实例生命周期钩子\n\n* **beforeCreate / created**  创建\n* **beforeMount / mounted**  挂载（挂载后 `$el` 才可用）\n* **beforeUpdate / updated**  数据更新\n* **activated / deactivated**  keep-alive组件 激活/停用 时（vue-router）\n* **beforeDestroy / destroyed**  销毁\n\n<img width=\"80%\">\n{% asset_img Vue生命周期.png Vue生命周期 %}\n</img>\n\n**父子组件 生命周期 执行顺序：**\n\n* 加载渲染\n```javascript\n父 beforeCreate -> 父 created -> 父 beforeMount ->\n子 beforeCreate -> 子 created -> 子 beforeMount ->\n子 mounted -> 父 mounted\n```\n* 子组件更新\n```javascript\n父 beforeUpdate -> 子 beforeUpdate -> \n子 updated -> 父 updated\n```\n* 父组件更新\n```javascript\n父 beforeUpdate -> 父 updated\n```\n* 销毁\n```javascript\n父 beforeDestroy -> 子 beforeDestroy ->\n子 destroyed -> 父 destroyed\n```\n\n\n\n更多详情请见：[VueJs API文档](https://cn.vuejs.org/v2/api/index.html)\n\n\n\n<br/>\n<br/>\n<br/>\n\n\n\n\n\n\n\n\n\n\n","tags":["JavaScript","Vue.js实战"]},{"title":"ESLint 代码检查工具","url":"/2019/09/26/ESLint-代码检查工具/","content":"\n\n\n# 关于 ESLint\n\nESLint 是一个插件化的 javascript 代码检测工具，借助 ESLint，可将 **静态代码分析** 和 **问题代码协助修复** 集成到 **编码**、**提交** 和 **打包** 过程中，及早发现并协助修复代码中：\n\n1. 有语法错误的部分\n2. 不符合约定的样式准则的部分\n3. 不符合约定的最佳实践的部分\n\n在项目开发中获得如下收益：\n\n1. 在执行代码之前发现并修复语法错误，减少调试耗时和潜在 bug\n2. 保证项目的 **编码风格统一**，提高可维护性\n3. 督促团队成员在编码时遵守约定的最佳实践，提高代码质量\n\n<br/>\n<br/>\n\n# 安装\n<br/>\n## 全局安装\n\n```javascript\n$ npm install -g eslint\n```\n初始化配置文件\n```javascript\n$ eslint --init\n```\n\n## 局部安装\n```javascript\n$ npm install eslint --save-dev\n```\n初始化配置文件\n```javascript\n$ ./node_modules/.bin/eslint --init\n```\n\n<br/>\n<br/>\n\n# 规则配置模式\n```javascript\n规则名： [ 错误级别， 附加选项 ]\n规则名： 错误级别\n```\n\nESLint 定义了 **三种错误级别**：\n\n* **\"off\"** 或 **0** - 关闭，不校验该规则\n\n* **\"warn\"** 或 **1** - 警告，不影响 exit code\n\n* **\"error\"** 或 **2** - 错误，触发该规则时 exit code 为 1\n\n\n<br/>\n<br/>\n\n# webpack 中配置 eslint （vue版）\n```javascript\n{\n  test: /\\.(js|vue)$/,\n  loader: 'eslint-loader',\n  enforce: 'pre',\n  include: [resolve('src'), resolve('test')],\n  options: {\n    formatter: require('eslint-friendly-formatter'),\n    emitWarning: !config.dev.showEslintErrorsInOverlay\n  }\n}\n```\n\n<br/>\n<br/>\n\n# vue-cli 的 .eslintrc.js 配置文件：\n\n```javascript\nmodule.exports = {\n  //此项是用来告诉eslint找当前配置文件不能往父级查找\n  root: true,\n  \n  //此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析\n  parser: 'babel-eslint',\n  \n  //此项是用来指定javaScript语言类型和风格，sourceType用来指定js导入的方式，默认是script，此处设置为module，指某块导入方式\n  parserOptions: {\n    sourceType: 'module'\n  },\n  \n  //此项指定环境的全局变量，下面的配置指定为浏览器环境\n  env: {\n    browser: true,\n  },\n  \n  //https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style\n  // 此项是用来配置标准的js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错\n  extends: 'standard',\n  \n  // required to lint *.vue files\n  // 此项是用来提供插件的，插件名称省略了eslint-plugin-，下面这个配置是用来规范html的\n  plugins: [\n    'html'\n  ],\n  \n  // add your custom rules here\n  // 下面这些rules是用来设置从插件来的规范代码的规则，使用必须去掉前缀eslint-plugin-\n  // 主要有如下的设置规则，可以设置字符串也可以设置数字，两者效果一致\n  // \"off\" -> 0 关闭规则\n  // \"warn\" -> 1 开启警告规则\n  //\"error\" -> 2 开启错误规则\n  // 了解了上面这些，下面这些代码相信也看的明白了\n  'rules': {\n  \n    // allow paren-less arrow functions\n    'arrow-parens': 0,\n    \n    // allow async-await\n    'generator-star-spacing': 0,\n    \n    // allow debugger during development\n    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0\n    \n    \n    \n    'no-multi-str': 2, // 字符串不能用\\换行\n    'no-unreachable': 2, // 不能有无法执行的代码\n    'no-use-before-define': 2, // 违背顶以前不能使用\n    'no-with': 2, // 禁用with\n    'arrow-spacing': 0, // => 的前/后括号\n    'brace-style': [1, '1tbs'], // 大括号风格\n    'comma-style': [2, '1ast'], // 逗号风格，换行是在行首还是行尾\n    'curly': [2, 'all'], // 必须使用 if(){} 中的{}\n    'indent': [2, 4], //缩进风格\n    'use-isnan': 2, // 禁止比较时使用 NaN，只能用 isNan()\n    'semi-spacing': [0, {\"before\": false, \"after\": true}], // 分号前后空格\n    'spaced-comment': 0, // 注释风格要不要空格\n    'space-before-blocks': [0, 'always'], // 不以新行开始的代码块 { 前要不要空格\n    'eol-last': 0, // 文件 不以单一的换行符结束\n    'space-before-function-paren': [0, \"always\"], // 函数定义时，括号前面是否要空格\n    'no-trailing-space': 0, // 一行结束空格\n    'quotes': [0, 'single'], // 引号类型 '' \"\" ``\n  }\n}\n\n```\n\n<br/>\n<br/>\n\n# VSCode 集成\n\n**代码提示**\n工具： VSCode ESLint 插件\n使用：在 VSCode 设置中将 `eslint.enable` 设置为 `true`\n\n**代码修复**\n工具：VSCode Prettier 插件\n使用：在 VSCode 设置中将 `prettier.eslintIntegration` 设置为 `true`，prettier 插件执行格式化时将使用 prettier-eslint 完成下述操作：\n\n1. 使用 prettier 格式化代码\n2. 对上一步格式化过的代码执行 `eslint --fix`\n\n","tags":["工具"]},{"title":"vscode 快捷键（windows）","url":"/2019/09/23/vscode-快捷键（windows）/","content":"\n\n**【Ctrl + Shift + P】**    打开命令面板\n&emsp;&emsp;**【Ctrl + U】**   返回上一个光标位置\n&emsp;&emsp;**【Home/End】**    光标移动至行首或行尾\n&emsp;&emsp;**【Ctrl + Home/End】**    光标移动至文档的开头或末尾\n&emsp;&emsp;**【Ctrl + D】**    选中单词（第二次按下，会找到文档中下一次出现该单词的位置 并选中单词）\n&emsp;&emsp;**【Alt + 上下】**    代码移动\n&emsp;&emsp;**【Ctrl + /】**    行注释\n&emsp;&emsp;**【Alt + Shift + F】**    格式化整个文档\n&emsp;&emsp;**【Alt + 鼠标点击】**    多光标\n&emsp;&emsp;**【Alt + Shift + I】**    在选中的多行代码的 每一行 （已选中内容）后边都会添加光标\n&emsp;&emsp;**【Ctrl + P】**    快速打开文件\n&emsp;&emsp;**【Ctrl + G】**    快速跳转（代码行）\n&emsp;&emsp;**【Ctrl + Shift + O】**    符号跳转（符号：文件名、函数名、css类名）\n&emsp;&emsp;**【F12】**    跳转至 函数定义处\n&emsp;&emsp;**【Ctrl + F12】**    跳转至 函数实现处\n&emsp;&emsp;**【Shift + F12】**    引用跳转（先将光标移动到 函数/类 上）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["工具"]},{"title":"侧耳倾听 Vol.4","url":"/2019/09/16/侧耳倾听-Vol-4/","content":"\n\n_\\#抄句子\\#_\n\n\n> 「春有百花秋有月，夏有涼風冬有雪。\n&emsp;&emsp;&emsp;若無閒事掛心頭，便是人間好時節。」\n\n\n</br>\n\n> 「晴秋上午 隨便走走 不一定要快樂」  &emsp;—— 木心\n\n\n</br>\n\n> 「 我希望你嚮往生命的盎然 \n&emsp;&emsp;&emsp;不會受傷 \n&emsp;&emsp;&emsp;會熱愛生活 \n&emsp;&emsp;&emsp;我想和你一起遊戲人間 \n&emsp;&emsp;&emsp;愛得坦蕩 \n&emsp;&emsp;&emsp;呼吸都想念我 」   &emsp;—— 賈平凹\n\n\n</br>\n\n> 「一個傷痛著的人置身一個陌生的環境是幸福的，因為你不必在熟悉的人和風景面前故作堅強，你完全可以放縱地流淚。」   &emsp;—— 《世界上所有的夜晚》 遲子建\n\n</br>","tags":["生活","侧耳倾听"]},{"title":"YoungFront 框架","url":"/2019/09/16/YoungFront框架/","content":"\n\n\n## YFjs 组件库\n一个基于 AMD规范 的组件库，内含简洁 SPA 框架，便于快速构建单页面应用系统。\n&emsp;&emsp;其中大部分是第三方库，如 jQuery、RequireJs、Bootstrap 等的开源库和框架是这个组件库的核心依赖。\n&emsp;&emsp;YFjs不仅能够帮助我们快速使用弹出框、美化后的下拉框和单/复选框、滚动条等UI组件，也能使用JSON转换、Cookie处理、日期格式处理等工具插件，更能配合内含的 SPA 框架快速构建一个单页面应用系统，让我们的前端开发更便捷。\n\n{% asset_img yfjs-content.png yfjs目录结构 %}\n\n\n### 引入组件库\n在 head 标签内引入组件库的入口 JS 文件 yfjs.js 即可：\n```html\n<script src=\"[yfjs-lib path]/yfjs.js\"></script>\n```\n\n入口 JS 文件会 **自动引入** 基本样式文件、核心 JS 库文件等组件库的相关静态资源。\n\n### 入口配置\n\n在引入组件库的入口 JS 文件时，我们可以通过定义以下属性来扩展组件库的功能。\n* **data-cache**: 全局缓存开关，默认为 true。设为 false 则关闭缓存\n* **data-debug**: 调试模式开关，默认为 false，使用压缩后的资源。设为 true 时将使用未压缩的资源\n* **data-debug-css**: 基本样式文件的调试模式开关，默认为 data-debug。为 false 时引入压缩后的基本样式文件，否则引入未压缩的基本样式文件\n* **data-debug-module**: 组件模块的调试模式开关，默认为 data-debug。为 false 时引入压缩后的组件模块文件，否则引入未压缩的组件模块文件\n* **data-base**: 应用访问基路径，默认继承 <base> 标签值。\n* **data-base-require**: 应用内自定义模块引入基路径，默认相对于 data-base。\n* **data-base-css**: 是否引入组件库的基本样式文件，默认为 true。设为 false 时不引入基本样式文件。\n* **data-compatible**: 是否引入所有兼容脚本，默认为 false。设为 true 时自动判断兼容性并引入兼容脚本。\n* **data-compatible-modernizr**: 是否引入 Modernizr 兼容脚本，默认为 data-compatible。了解 Modernizr。\n* **data-compatible-respond**: 是否引入 respond 兼容脚本（兼容 Media Query），默认为 data-compatible。\n* **data-compatible-html5**: 是否引入 html5shiv 兼容脚本（兼容 HTML5 新元素），默认为 data-compatible。\n* **data-compatible-es5**: 是否引入 es5 兼容脚本（兼容 ES5 API），默认为 data-compatible。\n* **data-compatible-es6**: 是否引入 es6 兼容脚本（兼容 ES6 API），默认为 data-compatible。\n* **data-compatible-json**: 是否引入 JSON 兼容脚本（兼容 JSON.parse 和 JSON.stringify），默认为 data-compatible。\n* **data-main**: 应用入口 JS 文件。\n\n```html\n<script src=\"[yfjs-lib path]/yfjs.js?v=0.8.2\" \n            data-cache=\"false\" \n            data-debug=\"true\"\n> </script>\n```\n\n## yfjs/spa 框架\n一个 SPA（单页面应用）框架，风格简洁，配置和约定共同驱动。\n\n### 配置应用入口\n\n\n```html\n<script src=\"/yfjs-lib/yfjs.js\" \n    data-main=\"app\" \n    data-base-require=\"app\" \n    data-cache=\"false\"\n> </script>\n```\n\n* **data-main**: 应用的入口 JS 文件。建议为 app。\n* **data-base-require**: 引入本地资源的基路径。建议为 app。\n* **data-cache**: 全局缓存开关，控制模板文件、JS 文件等是否缓存。默认开启缓存，设置为 false 则关闭缓存。 \n\n### 构建应用目录\n\n{% asset_img content-structure.png 构建应用目录 %}\n\n\n### 编写首页内容\n编写应用入口文件内容，引入框架 yfjs/spa ：\n```javascript\ndefine(['yfjs/spa'], function(SPA) { \n    SPA.create(); \n});\n```\n在视图目录下创建文件 home.js，并编写内容：\n```javascript\ndefine(['App'], function(App) { \n    return App.View({\n        layout: \"default\"\n    }); \n});\n```\n在视图模板目录下创建文件 home.html，并编写内容：\n```html\n<div class=\"container\"> \n    <h1>Hello World!</h1> \n</div>\n```\n在布局目录下创建布局文件 default.js，并编写内容：\n```javascript\ndefine(['App'], function() {\n    return App.Layout();\n});\n```\n在布局模板目录下创建文件 default.html，并编写内容：\n```html\n<div class=\"container\"> \n    {{{body}}} \n</div>\n```\n\n### 使用布局\n\n将**页面的公共部分**抽离成布局，提升页面的渲染效率。\n\n### 约定与配置\n\nyfjs/spa 框架是一个 <u>**配置和约定共同驱动**</u> 的框架。配置的是**功能接口**，约定的是**路由等规则**。\n\n**约定规则 — 路由约定**\n\n框架内置了页面路由，页面的定向遵守框架既定规则：\n\n* 页面的路由在 URL 上默认体现为 hash 模式。即形如 http://127.0.0.1/#/path?param1=value1，则页面路径为\" /path \"，其后内容为页面的参数。\n* 页面路径对应视图目录 views下的同路径同名的 JavaScript 文件。\n* 页面的默认模板对应模板目录 templates下的同路径同名的 HTML 文件。\n* 页面使用的布局（若存在）对应布局目录 layouts下的同路径同名的 JavaScript 文件。\n* 页面布局的默认模板对应布局模板目录 templates/layouts下的同路径同名的 HTML 文件。\n\n**约定规则 — 分层渲染**\n\n为了充分体现单页面应用的局部加载、按需加载的特性，框架将页面内容进行了区段划分，并由上至下分层渲染。\n&emsp;&emsp;框架将当前页面窗口定义为 App 层（应用层），页面主体内容定义为 View 层（视图层），页面外层布局定义为 Layout 层（布局层）。其中 View 层可任意嵌套并定义加载时机，在最上层的 View 层可指定采用的 Layout 层。App 层则负责整体状态切换、页面路由等。\n\n{% asset_img spa-widgets.png yfjs/spa分层渲染 %}\n\n\n**配置和扩展**\n\n在应用入口文件 /app/app.js 中，为当前应用指定一些配置项：\n```javascript\nSPA.create({ \n    // 配置项 baseUrl \n    baseUrl: { \n        style: \"/assets/css\",    // 设置样式文件基路径\n        resource: \"/assets\"    // 设置其他资源基路径\n     }, \n    // 扩展功能 \n    doSomething: function() { \n        return \"do \" + this.getSomething(); \n     }, \n    getSomething: function() { \n        return \"something.\"; \n    } \n});\n```\n\n在创建一个视图实例 /views/home.js 时，配置扩展功能如下：\n```javascript\nApp.View({\n    // 配置项 layout 布局\n    layout: \"default\",\n    // 配置项 ready 页面渲染后执行\n    ready: function() {\n        console.log(\n            this.doSomething()\n        );\n    },\n    // 扩展功能\n    doSomething: function() {\n        // 调用 App 实例的扩展功能\n        App.doSomething();\n    }\n});\n```\n\n### 应用层\n框架结构的顶层。\n&emsp;&emsp;应用层主要负责路由自动切换、维护全局状态、提供全局功能等。应用开始启动后，框架将自动生成一个应用实例来负责应用层的一应事务。\n\n\n### 视图/布局层\n\n在框架下渲染每个页面的层级结构称为视图（View）层。视图层可以定义自己的布局（Layout）层，布局层主要负责实现多个视图层共有的渲染效果（如公用的 header 页头，banner 图，footer 页脚等）。多个视图层可以共用一个布局层。\n\n### 实例的生命周期\n\n应用实例从页面开始初次加载时创建，一直存在到页面顶层窗口关闭。期间页面内容的更新由内置的路由器（Router）自动加载视图层进行处理。这个过程称为 **应用实例生命周期**。\n页面的访问由 url 中的 hash 部分自动触发。应用层会通过内置的页面路由监控这个触发事件，并开始路由页面。每个页面视图脚本从被加载到开始，到自身内容从页面中移除的过程，称为 **视图实例生命周期**。\n视图页面内容加载完成后，如果定义了布局层，会继续加载布局层内容。布局层脚本从被加载到开始，到布局内容从页面中移除的过程，称为 **布局实例生命周期**。\n\n>更多详细信息，请访问： [YoungFront 官网](http://jinzhk.github.io/yfjs/)\n","tags":["JavaScript","YoungFront"]},{"title":"侧耳倾听 Vol.3","url":"/2019/08/19/侧耳倾听-Vol-3/","content":"\n\n\n_\\#抄句子\\#_\n\n\n> 「你任何為人稱道的美麗不及我第一次遇見你」  &emsp;—— 馬頔\n\n\n</br>\n\n> 「知識和感覺比金錢更能決定一個人的階級」  &emsp;—— 《身份的焦慮》阿蘭·德波頓\n\n\n</br>\n\n> \"The woman I like is so powerful that a man has to be courageous to approach her.\" &emsp;&emsp; ——  Alexander McQueen \n\n\n</br>","tags":["生活","侧耳倾听"]},{"title":"JavaScript 引用类型","url":"/2019/08/15/JavaScript-引用类型/","content":"\n\n\n在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。\n\n<br/>\n\n# Object 类型\n> Object 是一个基础类型，其他所有类型都从Object 继承了基本的行为。\n\n创建 Object 实例有两种方式：\n 1. 使用 new 操作符后跟 Object 构造函数；\n 2. 使用对象字面量表示法（属性名可以使用字符串）。\n\n> 对象字面量表示法 也是向函数传递大量可选参数的首选方式；\n> 最好的做法是 对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。\n\n访问对象属性：\n\n 1. 点表示法；\n 2. 方括号表示法（将要访问的属性以 **字符串** 的形式放在方括号中）。\n\n> 方括号语法的主要优点是可以通过 **变量** 来访问属性\n\n\n<br/>\n<br/>\n<br/>\n\n# Array 类型\nECMAScript 数组与其他语言中数组的不同之处：\n 1. ECMAScript 数组的每一项可以保存 **任何类型** 的数据；\n 2. ECMAScript 数组的 **大小**是可以 **动态调整** 的。\n\n创建数组的基本方式有两种：\n 1. 使用 Array 构造函数；\n 2. 使用数组字面量表示法。\n\n在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值；如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加 1 的长度。数组最后一项的索引始终是 length-1。\n\n数组的项数保存在其 length 属性中，这个属性始终会返回 0 或更大的值。数组的 length 属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。\n\n## 检测数组\n确定某个对象是不是数组：\n\n 1.  **value instanceof Array**  （instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array 构造函数）\n 2.  **Array.isArray( value )**  方法 （确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的）\n\n## 转换方法\n -  **toLocaleString()** ：创建一个数组值的以逗号分隔的字符串；为了取得每一项的值，调用的是每一项的toLocaleString()方法；\n -  **toString()** ：返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串；为了创建这个字符串会调用数组每一项的toString()方法；\n -  **valueOf()** ：返回的还是数组。\n\n## 栈方法\nLIFO 后进先出，推入 与 弹出 只发生在 **栈顶** 。\n\n - **push() 方法** ：推入，可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度；\n - **pop() 方法** ：弹出，从数组末尾移除最后一项，减少数组的length 值，然后返回移除的项。\n\n## 队列方法\nFIFO 先进先出，推入 发生在队尾，移除 发生在队列头部。\n\n -  **push() 方法**\n -  **shift() 方法** ：移除数组中的第一个项并返回该项，同时将数组长度减1。\n\n>  **unshift()方法** ：在数组前端添加任意个项并返回新数组的长度\n\n```javascript\nvar colors = new Array(); //创建一个数组\nvar count = colors.unshift(\"red\", \"green\"); //推入两项\n// unshift 插入顺序 与 参数顺序 一致，该语句得到的 colors == [\"red\", \"green\"];\n```\n\n## 重排序方法\n -  **reverse() 方法** ：反序；\n -  **sort() 方法** ：默认升序（会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串）。sort() 方法可以接收一个 **比较函数** 作为参数。\n \n> 1. 比较函数接收两个参数，如果第一个参数应该位于第二个 **之前** 则返回一个 **负数** ，如果两个参数 **相等** 则返回 **0** ，如果第一个参数应该位于第二个 **之后** 则返回一个 **正数** ；\n> 2. 对于 **数值类型** 或者其 **valueOf() 方法会返回数值类型的对象类型** ，可以使用一个更简单的比较函数。这个函数只要用 **第二个值减第一个值** 即可。\n\n## 操作方法\n -  **concat() 方法** ：先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。\n -  **slice() 方法** ：接受一或两个参数，即要返回项的 **起始** 和 **结束** 位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项；如果有两个参数，该方法返回起始和结束位置之间的项（不包括结束位置的项）。\n -  **splice() 方法**：主要用途是向数组的中部插入项，使用方式有如下三种：\n\t - **删除** ：指定2 个参数 <要删除的第一项的位置， 要删除的项数>；\n\t - **插入** ：提供3 个参数 <起始位置， 0（要删除的项数）\n，要插入的项，…>\n\t - **替换** ：指定3 个参数 <起始位置，要删除的项数，要插入的任意数量的项>；始终都会返回一个数组，该数组中包含从原始数组中删除的项\n\n> 如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置；如果结束位置小于起始位置，则返回空数组。\n\n## 位置方法\n - indexOf()  ：从数组的开头（位置0）开始向后查找；\n - lastIndexOf() ：从数组的末尾开始向前查找。\n\n这两个方法都\n1. 接收两个参数：**要查找的项** 和（可选的）表示**查找起点位置**的索引；\n2. 都返回要查找的项在数组中的位置，或者在没找到的情况下返回 -1；\n3. 在比较第一个参数与数组中的每一项时，会使用 **全等** 操作符\n\n```javascript\nvar person = { name: \"Nicholas\" };\nvar people = [{ name: \"Nicholas\" }];\nvar morePeople = [person];\nalert(people.indexOf(person)); //-1\nalert(morePeople.indexOf(person)); //0\n/* \t在这里查找的时候，所比较的是对象。\n*\t在 people 这个数组中的这个 {name:“Nicholas”} 和 person 并不是同一个对象，而morepeole 中和 person 是同一个对象（因为直接引用了它）。\n*\t因此第一个会返回 -1（无法找到），第二个是 0。\n*/\n```\n\n## 迭代方法\n数组中定义了5 个迭代方法，分别对 **数组中的每一项** 运行给定函数：\n - **every()** ：如果该函数对**每一项都返回true**，则返回true；\n - **some()** ：如果该函数对**任一项返回true**，则返回true；\n - **filter()** ：返回该函数会返回true 的项组成的**数组** （用于 查询符合某些条件的所有数组项）；\n - **map()** ：返回每次函数调用的结果组成的**数组**；\n - **forEach()** ：没有返回值。\n\n每个方法都接收两个参数：\n1. 要在每一项上运行的 **函数**；\n2. （可选的）运行该函数的作用域对象——影响this 的值。\n\n> 传入这些方法中的函数会接收三个参数：\n> 1.  数组项的值；\n> 2. 该项在数组中的位置；\n> 3. 数组对象本身。\n\n## 归并方法\nECMAScript 定义了两个归并数组的方法，可以迭代数组的所有项，然后构建一个最终返回的值：\n\n - **reduce() 方法** ：从数组的第一项开始，逐个遍历到最后；\n - **reduceRight() 方法** ： 从数组的最后一项开始，向前遍历到第一项。\n\n这两个方法都接收两个参数：\n1. 一个在每一项上 **调用的函数**；\n2. （可选的）作为归并基础的初始值。\n\n> 传给reduce()和reduceRight()的函数接收4 个参数：\n> 1. 前一个值；\n> 2. 当前值；\n> 3. 项的索引；\n> 4. 数组对象。\n>  <br/>\n> \n> 这个函数返回的任何值都会作为 **第一个参数** 自动传给下一项。**第一次迭代发生在数组的第二项上**，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。\n\n\n\n<br/>\n<br/>\n<br/>\n\n# Date 类型\nDate类型 使用自 **UTC（Coordinated Universal Time，国际协调时间）** 1970 年1 月1 日午夜（零时）开始经过的 **毫秒数** 来保存日期。\n\n使用 Date 构造函数，创建一个日期对象：\n\n```javascript\nvar now = new Date();\n```\n**不传递参数** 的情况下，新创建的对象自动获得 **当前日期和时间**；\n如果想根据 **特定的日期和时间** 创建日期对象，必须传入表示 **该日期的毫秒数**。\nECMAScript 提供了三个方法，以获取日期的毫秒数：\n- **Date.parse()** ：接收一个**表示日期的字符串参数**，然后尝试根据这个字符串返回相应日期的毫秒数；如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。\n- **Date.UTC()** ：参数分别是 **年份**、**基于0 的月份**（0 - 11）、月中的哪一天（1 - 31）、小时数（0 - 23）、分钟、秒以及毫秒数；返回表示日期的毫秒数。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。\n- **Data.now()** ：返回表示调用这个方法时的日期和时间的毫秒数（可用于分析代码；在不支持它的浏览器中，使用+操作符把Data 对象转换成字符串，也可以达到同样的目的）。\n\n> 实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Date.parse()。<br/>\n> 如同模仿Date.parse()一样，Date 构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT 来创建。\n\n## 日期格式化方法\n将日期格式化为字符串的方法 如下：\n\n - **toDateString()** ——以特定于实现的格式显示星期几、月、日和年；\n - **toTimeString()** ——以特定于实现的格式显示时、分、秒和时区；\n - **toLocaleDateString()** ——以特定于地区的格式显示星期几、月、日和年；\n - **toLocaleTimeString()** ——以特定于地区的格式显示时、分、秒；\n - **toUTCString()** ——以特定于实现的格式完整的UTC 日期。\n\n## 日期/时间组件方法\n\n> UTC 日期指的是在没有时区偏差的情况下（将日期转换为GMT 时间）的日期值\n\n常用方法如下：\n\n - **getFullYear()**  ：取得4位数的年份（如2007而非仅07）；\n - **getMonth()** ： 返回日期中的月份，其中0表示一月，11表示十二月；\n - **getDate()** ： 返回日期月份中的天数（1到31）；\n - **getDay()** ： 返回日期中星期的星期几（其中0表示星期日，6表示星期六）；\n<br/>\n - **setFullYear(年)** ： 设置日期的年份；\n - **setMonth(月)** ： 设置日期的月份。传入的月份值必须大于0，超过11则增加年份；\n - **setDate(日)** ： 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份；\n\n\n<br/>\n<br/>\n<br/>\n\n# RegExp 类型\n\n - 以 **字面量形式** 创建 正则表达式：\n```javascript\nvar expression = / pattern / flags ;\n```\n - 使用 **RegExp 构造函数** 创建 正则表达式：\n 它接收两个参数：一个是要匹配的字符串模式（所有元字符都必须 **双重转义**，那\n些已经转义过的字符也是如此），另一个是可选的标志字符串。\n\n```javascript\nvar pattern1 = /[bc]at/i;\nvar pattern2 = new RegExp(\"[bc]at\", \"i\");\n```\n\n正则表达式的匹配模式支持下列 3 个标志：\n -  **g** ：表示 **全局**（global）模式；\n -  **i** ：表示 **不区分大小写**（case-insensitive）模式；\n -  **m** ：表示 **多行**（multiline）模式。\n\n模式中使用的所有元字符都必须转义。正则表达式中的 **元字符** 包括：\n\t ( [ { \\ ^ $ | ) ? * + .]} \n\n> 注意：\n> 使用正则表达式字面量和使用RegExp 构造函数创建的正则表达式不一样。\n> 在ECMAScript 3 中，正则表达式字面量始终会共享同一个RegExp 实例，\n> 而使用构造函数创建的每一个新RegExp 实例都是一个新实例。\n\n## RegExp 实例属性\nRegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。\n-  global：布尔值，表示是否设置了g 标志。\n-  ignoreCase：布尔值，表示是否设置了i 标志。\n-  lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0 算起。\n-  multiline：布尔值，表示是否设置了m 标志。\n-  source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。\n\n## RegExp实例方法\n- **exec()**  ：exec() 接受一个参数，即 要应用模式的字符串，然后返回 **包含第一个匹配项信息的数组**；或者在没有匹配项的情况下返回null。\n\n> 返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，**index** 表示匹配项在字符串中的位置，而 **input** 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。\n\n- **test()** ：在模式与该参数匹配的情况下返回 true；否则，返回 false。\n\n> test() 方法经常被用在 **if 语句** 中\n\n\n<br/>\n<br/>\n<br/>\n\n# Function 类型\n每个函数都是Function 类型的实例，而且都与其他引用类型一样具有属性和方法。\n由于**函数是对象**，因此 **函数名** 实际上也是一个 **指向函数对象的指针**，不会与某个函数绑定。\n\n定义函数的方式：\n\n - **函数声明**\n - **函数表达式**\n - **使用Function 构造函数**\n\n```javascript\n// 函数声明\nfunction sum (num1, num2) {\n\treturn num1 + num2;\n}\n// 函数表达式定义法\nvar sum = function(num1, num2){\n\treturn num1 + num2;\n};\n// 构造函数定义法\nvar sum = new Function(\"num1\", \"num2\", \"return num1 + num2\"); // 不推荐\n```\n\n> 构造函数定义法 会导致**解析两次代码**（第一次是解析常规ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。\n\n由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。\n\n```javascript\nfunction sum(num1, num2){\n\treturn num1 + num2;\n}\nalert(sum(10,10)); //20\nvar anotherSum = sum;\nalert(anotherSum(10,10)); //20\nsum = null;\nalert(anotherSum(10,10)); //20\n```\n\n> 注意，使用 **不带圆括号的函数名** 是 **访问函数指针**，而非调用函数。\n\n## 没有重载\n函数是对象，没有重载，可以将函数名理解为 指针：\n```javascript\nfunction addSomeNumber(num){\n\treturn num + 100;\n}\nfunction addSomeNumber(num) {\n\treturn num + 200;\n}\nvar result = addSomeNumber(100); //300\n```\n上述代码 用 函数表达式 表示为：\n\n```javascript\nvar addSomeNumber = function (num){\n\treturn num + 100;\n};\naddSomeNumber = function (num) {\n\treturn num + 200;\n};\nvar result = addSomeNumber(100); //300\n```\n可见，在创建第二个函数时，实际上覆盖了**引用**第一个函数的变量addSomeNumber。\n\n## 函数声明 与 函数表达式\n> 解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。\n> **解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）； \n> 至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。**\n\n**函数声明提升**（function declaration hoisting）\n对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把函数声明提升到顶部。\n\n## 作为值的函数\n因为 **函数名** 本身就是 **变量**，所以函数也可以 **作为值** 来使用。\n也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。\n\n```javascript\nfunction callSomeFunction(someFunction, someArgument){\n\treturn someFunction(someArgument);\n}\n```\n例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。我们需要一种方式来指明按照哪个属性来排序：\n```javascript\nfunction createComparisonFunction(propertyName) {\n\treturn function(object1, object2){\n\t\tvar value1 = object1[propertyName];\n\t\tvar value2 = object2[propertyName];\n\t\tif (value1 < value2){\n\t\t\treturn -1;\n\t\t} else if (value1 > value2){\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t};\n}\n```\n\n## 函数内部属性\n在函数内部，有两个特殊的对象：arguments 和 this 。\n\n - **arguments** ：类数组对象，包含着传入函数中的所有参数。\n 这个对象还有一个名叫 **callee** 的属性，该属性是一个指针，指向 **拥有这个arguments 对象的函数**。使用arguments.callee，可以消除 递归调用 中的紧密耦合现象。\n \n```javascript\nfunction factorial(num){\n\tif (num <=1) {\n\t\treturn 1;\n\t} else {\n\t\treturn num * arguments.callee(num-1)\n\t}\n}\n```\n\n - **this** ：this 引用的是 **函数据以执行的环境对象**（当在网页的全局作用域中调用函数时，this 对象引用的就是 window）\n \n> 请牢记：函数的名字仅仅是一个 **包含指针的变量** 而已\n\n- **caller** ：保存着 **调用当前函数的函数的引用**，如果是在全局作用域中调用当前函数，它的值为null。\n\n## 函数属性和方法\n- **length 属性**：表示函数希望接收的 **命名参数的个数**；\n- **prototype 属性**： 不可枚举；\n\n以下方法 在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值：\n- **apply() 方法**：接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象。\n- **call() 方法**：第一个参数是this 值，其余参数都直接传递给函数（必须逐个列举出来）。\n- **bind() 方法**：这个方法会创建一个函数的实例，其this 值会被绑定到传给bind()函数的值。\n\n> call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。\n\napply()和call() 能够扩充函数赖以运行的作用域，使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。\n\n```javascript\nwindow.color = \"red\";\nvar o = { color: \"blue\" };\nfunction sayColor(){\n\talert(this.color);\n}\nsayColor(); //red\nsayColor.call(this); //red\nsayColor.call(window); //red\nsayColor.call(o); //blue\n```\n\n\n<br/>\n<br/>\n<br/>\n\n# 基本包装类型\n实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。\n\n> 引用类型与基本包装类型的主要区别就是 **对象的生存期**。\n> （1）使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。\n> （2）而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。\n\n三种基本包装类型的共同特征：\n（1）每个包装类型都 **映射** 到同名的基本类型；\n（2）在 **读取模式** 下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作（在实例上调用指定的方法）；\n（3）操作基本类型值的语句一经 **执行完毕**，就会 **立即销毁** 新创建的包装对象。\n\n## Boolean 类型\n\n```javascript\nvar falseObject = new Boolean(false);\nvar result = falseObject && true;\nalert(result); //true\n\nvar falseValue = false;\nresult = falseValue && true;\nalert(result); //false\n\nalert(typeof falseObject); //object\nalert(typeof falseValue); //boolean\nalert(falseObject instanceof Boolean); //true\nalert(falseValue instanceof Boolean); //false\n```\n**布尔表达式中的所有对象都会被转换为 true**，因此上述代码中，falseObject 对象在布尔表达式中代表的是true。\n我们的建议是永远不要使用Boolean 对象。\n\n## Number 类型\n- **valueOf() 方法** ：返回对象表示的基本类型的数值；\n- **toLocaleString() 方法** ：返回字符串形式的数值；\n- **toString() 方法**： 返回字符串形式的数值（可以为toString()方法传递一个**表示基数**的参数，告诉它返回**几进制数值**的字符串形式）；\n- **toFixed() 方法** ：会按照指定的小数位返回数值的字符串表示 ；\n- **toExponential() 方法** ：返回以指数表示法（也称e 表示法）表示的数值的字符串形式；\n- **toPrecision() 方法** ：可能会返回固定大小（fixed）格式，也可能返回指数\n（exponential）格式；具体规则是看哪种格式最合适。接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。\n\n```javascript\nvar num = 10.005;\nalert(num.toFixed(2)); //\"10.01\"\n// 能够 自动舍入 的特性，使得toFixed()方法很适合 处理货币值\n```\n\n```javascript\nvar num = 99;\nalert(num.toPrecision(1)); //\"1e+2\"\nalert(num.toPrecision(2)); //\"99\"\naler t(num.toPrecision(3)); //\"99.0\"\n```\n\n## String 类型\nString 类型的每个实例都有一个 **length 属性**，表示字符串中包含多个字符。\n\n> 应该注意的是，即使字符串中包含 **双字节字符**（不是占一个字节的ASCII 字符），每个字符 也仍然 **算一个字符**。\n\nString 类型提供了很多方法，用于辅助完成对ECMAScript 中字符串的解析和操作：\n\n - 字符方法\n \t- **charAt()** ：以**单字符字符串**的形式返回给定位置的那个字符\n \t- **charCodeAt()** ：以**字符编码**的形式返回给定位置的那个字符\n - 字符串操作方法\n \t- **concat()** ：用于将一或多个字符串拼接起来，返回拼接得到的新字符串。 \n \t- **加号操作符（+）**\n \t- **slice()** \n \t- **substr()** \n \t- **substring()**\n - 字符串位置方法\n \t- **indexOf()** ： 从前往后\n \t- **lastIndexOf()** ： 从后往前\n - **trim() 方法** ： 创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果；\n - 字符串大小写转换方法\n \t- **toLowerCase()**\n \t- **toUpperCase()**\n \t- **toLocaleLowerCase()**\n \t- **toLocaleUpperCase()**\n - 字符串的模式匹配方法\n \t- **match()** ：本质上与调用RegExp 的exec()方法相同。\n \t-  **search()** ：返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。\n \t- **replace()** ： 这个方法接受两个参数：第一个参数可以是一个RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。\n \t- **split()** ：基于 **指定的分隔符** 将一个字符串分割成多个子字符串，并将结果放在一个**数组**中。分隔符可以是字符串，也可以是一个RegExp 对象（这个方法不会将字符串看成正则表达式）；\n\n```javascript\nvar text = \"cat, bat, sat, fat\";\nvar result = text.replace(\"at\", \"ond\");\nalert(result); //\"cond, bat, sat, fat\"\nresult = text.replace(/at/g, \"ond\");\naler t(result); //\"cond, bond, sond, fond\"\n```\n - **localeCompare() 方法** ：比较两个字符串，并返回下列值中的一个：\n\t- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（-1）；\n\t- 如果字符串等于字符串参数，则返回 0；\n\t- 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（1）。\n```javascript\nvar stringValue = \"yellow\";\nalert(stringValue.localeCompare(\"brick\")); //1\nalert(stringValue.localeCompare(\"yellow\")); //0\nalert(stringValue.localeCompare(\"zoo\")); //-1\n```\n\n - **fromCharCode() 方法** ： 接收一或多个字符编码，然后将它们转换成一个字符串。\n - HTML 方法\n\n\n<br/>\n<br/>\n<br/>\n\n# 单体内置对象\nECMA-262 对内置对象的定义是：“由ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript 程序执行之前就已经存在了。\n\n## Global对象\n事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global 对象的属性。不属于任何其他对象的属性和方法，最终都是它的属性和方法。\n例如，isNaN()、isFinite()、parseInt() 以及 parseFloat() 等。\n\n - URI 编码方法 ：Global 对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform ResourceIdentifiers，通用资源标识符）进行编码，以便发送给浏览器。\n \t- **encodeURI()**：主要用于整个URI；\n \t- **encodeURIComponent()** ：主要用于对URI 中的某一段。\n \t- **decodeURI()** ：只能对使用encodeURI()替换的字符进行解码；\n \t- **decodeURIComponent()** ：能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。\n\n> 它们的主要区别在于，encodeURI()不会对本身属于URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。\n\n> 一般来说， 我们使用encodeURIComponent() 方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码。\n\n - **eval() 方法** ：\n 通过 eval() 执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量；在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。\n - **Global 对象的属性**\n - **window 对象** ：\nECMAScript 虽然没有指出如何直接访问Global 对象，但Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。\n\n```javascript\nvar global = function(){\n\treturn this;\n}();\n/* 在没有给函数明确指定this 值的情况下\n（无论是通过将函数添加为对象的方法，\n还是通过调用call()或apply()），\nthis值等于Global 对象。\n*/\n```\n\n## Math对象\nMath 对象有如下方法：\n\n - **min() 方法** ：确定一组数中的最小值；\n - **max() 方法** ：确定一组数中的最大值；\n \n\n> 这两个方法经常用于\n> （1）避免多余的循环；\n> （2）在if 语句中确定一组数的最大/小值。\n\n要找到 **数组** 中的最大或最小值，可以像下面这样使用 apply() 方法：\n\n```javascript\nvar values = [1, 2, 3, 4, 5, 6, 7, 8];\nvar max = Math.max.apply(Math, values);\n// 关键是把 Math 对象作为apply()的第一个参数，从而正确地设置this 值。\n```\n\n - **Math.ceil()** ：向上舍入；\n - **Math.floor()** ：向下舍入；\n - **Math.round()** ：四舍五入；\n - **Math.random()** ：返回 **[ 0 , 1 )** 中的一个随机数\n\n> 利用Math.random()从某个整数范围内随机选择一个值：\n值 = Math.floor( Math.random() * 可能值的总数 + 第一个可能的值 )\n\n\n```javascript\nfunction selectFrom(lowerValue, upperValue) {\n\tvar choices = upperValue - lowerValue + 1;\n\treturn Math.floor(Math.random() * choices + lowerValue);\n}\nvar num = selectFrom(2, 10);\nalert(num); // 介于 2 和10 之间（包括 2 和 10）的一个数值\n\n// 利用这个函数，可以方便地从数组中随机取出一项\nvar colors = [\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"purple\", \"brown\"];\nvar color = colors[selectFrom(0, colors.length-1)];\nalert(color); // 可能是数组中包含的任何一个字符串\n```\n\n<br/>\n<br/>\n<br/>\n以上。\n\n","tags":["JavaScript","JavaScript高级程序设计"]},{"title":"JavaScript 变量、作用域和内存问题","url":"/2019/08/08/JavaScript-变量、作用域和内存问题/","content":"\n\n# 基本类型和引用类型的值\n\nJavaScript采用松散类型变量\n&emsp;&emsp;**松散类型变量** -- 在特定时间用于保存特定值的一个名字，**变量的值** 及其 **数据类型** 可以在脚本的生命周期内改变。\n \n<br/>\n\n**基本类型值** \n- 简单的数据段；  \n- 按值访问；  \n- 可以操作保存在变量中的实际的值（栈内存，固定大小）；\n\n<br/>\n\n\n**引用类型值** \n- 可能由多个值构成的对象；  \n- 按引用访问；  \n- 实际上是在操作对象的引用，而不是实际的对象（堆内存）；\n- 当复制保存着对象的某个变量时，操作的是对象的引用；在为对象添加属性时，操作的是实际的对象（JS 不允许直接访问内存中的位置）；\n- 只能给 引用类型值 动态地添加属性。\n\n<br/>\n\n\n**复制变量值** \n基本类型值 会在变量对象上 创建一个新值，然后把该值 复制 到为新变量分配的位置上；\n&emsp;&emsp;引用类型值 也会在变量对象上 创建一个新值，然后把该值 复制 到为新变量分配的位置上，这个值的副本 实际上是一个指针，指向 存储在堆中 的一个对象。\n<br/>\n\n**传递参数** \nECMAScript 中，所有函数的参数 都是 **按值传递** 的，被传递的值（基本类型值 / 引用类型值在内存中的地址） 会被复制给一个 局部变量（即命名参数 / arguments对象中的一个元素）。\n\n```javascript\nfunction setName(obj) {\n    obj.name = \"Nicholas\";\n    obj = new Object();\n    obj.name = \"Greg\";\n}\nvar person = new Object();\nsetName(person);\nalert(person.name); //\"Nicholas\"\n\n// 如果person 是按引用传递的，那么person 就会自动被修改为指向其name 属性值为\"Greg\"的新对象。\n// 但是，当接下来再访问person.name 时，显示的值仍然是\"Nicholas\"。\n// 这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。\n```\n<br/>\n\n\n**检测类型**\n- **typeof** 操作符 —— 确定一个变量是 字符串、数值、布尔值，还是undefined  的最佳工具；\n- **instanceof** 操作符 —— 检测是什么类型的对象；\n\n\n<br/>\n<br/>\n<br/>\n\n\n# 执行环境及作用域\n\n\n**执行环境** 定义了 变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。\n\n- **全局执行环境** —— 最外围的一个执行环境。\n在Web浏览器中，全局执行环境被认为是window 对象，因此所有全局变量和函数都是作为window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。\n- **函数执行环境** —— 当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。\n而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。\n\n<br/>\n\n**作用域链**（scope chain）保证对执行环境有权访问的所有变量和函数的有序访问。\n- 作用域链的前端，始终都是 **当前执行的代码所在环境的变量对象** 。\n- **全局执行环境的变量对象** 始终都是作用域链中的最后一个对象。\n\n**标识符解析** 沿着作用域链一级一级地搜索标识符的过程。\n- 搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。\n- 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。\n- 这些环境之间的联系是 **线性、有次序** 的。\n\n**延长作用域链**：\n&emsp;&emsp;有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。当执行流进入下列任何一个语句时，作用域链就会得到加长：\n- try-catch 语句的catch 块；\n- with 语句。\n这两个语句都会在作用域链的前端添加一个变量对象。对with 语句来说，会将指定的对象添加到作用域链中。\n对catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。\n\n**没有块级作用域**：\n变量声明 —— 使用 var 声明的变量会自动被添加到最接近的环境中；如果初始化变量时没有使用var 声明，该变量会自动被添加到全局环境（严格模式下会报错）。\n查询标识符 —— 如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。\n\n\n<br/>\n<br/>\n<br/>\n\n\n# 垃圾收集\n\n\n\nJavaScript 具有**自动垃圾收集机制**，执行环境会负责管理代码执行过程中使用的内存。所需内存的分配以及无用内存的回收完全实现了自动管理。垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），**周期性** 地找出那些不再继续使用的变量，然后释放其占用的内存。\n\n**垃圾收集方式** ：\n- **标记清除** （mark-and-sweep）—— 当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。\n- **引用计数** （reference counting）—— 跟踪记录每个值被引用的次数。当垃圾收集器运行时，它就会释放那些引用次数为零的值所占用的内存。值得注意的问题是：**循环引用** ，指的是对象A 中包含一个指向对象B 的指针，而对象B 中也包含一个指向对象A 的引用。\n\n<br/>\n\n**性能问题 & 管理内存** ：\n&emsp;&emsp;随着IE7 的发布，JavaScript 引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。\n&emsp;&emsp;而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null 来释放其引用——这个做法叫做 **解除引用** （dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。\n解除引用的真正作用是 **让值脱离执行环境** ，以便垃圾收集器下次运行时将其回收。\n\n\n\n\n\n\n\n","tags":["JavaScript","JavaScript高级程序设计"]},{"title":"侧耳倾听 Vol.2","url":"/2019/08/06/侧耳倾听-Vol-2/","content":"\n\n_\\#抄句子\\#_\n\n\n> 「你要記得那些黑暗中默默抱緊你的人，逗你笑的人，陪你徹夜聊天的人，坐車來看望你的人，陪你哭過的人，在醫院陪你的人，總是以你為重的人，帶著你四處遊蕩的人，說想念你的人。\n&emsp;&emsp;&emsp;是這些人組成你生命中一點一滴的溫暖，是這些溫暖使你遠離陰霾，是這些溫暖使你成為善良的人。」  &emsp;—— 村上春樹\n\n</br>\n\n>「你是 我傷心時仍想要笑著去見的人\n&emsp;&emsp;&emsp;是我 自救乏術還想要伸手拉住的人 ​​​」\n\n</br>\n\n> 「我無法控制自己對你的難以忘懷，\n&emsp;&emsp;&emsp;可是關於你的一切 我再也沒有期待。」  &emsp;—《One Day》\n ","tags":["生活","侧耳倾听"]},{"title":"侧耳倾听 Vol.1","url":"/2019/08/01/my_sentence/","content":"\n_\\#抄句子\\#_\n\n\n> 「那日撞見你，草色風衣，自後私宅擺設便換了綠。」  &emsp;—— 木心\n\n</br>\n\n>「何為思念？」\n &emsp;&emsp;「日月，星辰，曠野雨落。」\n &emsp;&emsp;「可否具體？」\n &emsp;&emsp;「山川，江流，煙裊湖泊。」\n &emsp;&emsp;「可否再具體？」\n &emsp;&emsp;「萬物是你，無可躲。」\n\n\n","tags":["生活","侧耳倾听"]},{"title":"JavaScript 基础","url":"/2019/01/26/JavaScript-基础/","content":"\n\n# JavaScript 实现\n\nJavaScript 是一种专门为 **与网页交互** 而设计的脚本语言，由下列三部分组成：\n\n - **ECMAScript**：提供 核心语言功能；\n - **DOM** 文档对象模型：提供 访问和操作网页内容的方法和接口；\n - **BOM** 浏览器对象模型：提供 与浏览器交互的方法和接口。\n\n{% asset_img JavaScript.png JavaScript由三部分组成 %}\n\n<br/>\n<br/>\n<br/>\n\n# 在 HTML 中使用 JavaScript\n\n我们向 HTML 页面中插入 JavaScript 的主要方法，就是使用 **&lt;script&gt; 元素**。\n\n\n## script 标签的属性\n\n在 HTML5 中，&lt;script&gt; 标签有如下属性：\n\n| 属性     | 值        | 描述                                                   |\n| :------: | :-------: | :------------------------------------------------------|\n| **type** | MIME-type | （可选）规定脚本的 MIME 类型                           |\n| **src**  | URL       | 指定外部脚本的URL                                      |\n| async    | async     | 异步执行脚本（仅对外部脚本有效）                       |\n| defer    | defer     | 文档完全被解析和显示之后再执行脚本（仅对外部脚本有效） |\n| charset  | charset   | 规定在脚本中使用的字符编码（仅对外部脚本有效）         |\n\n\n<br/>\n## script 标签的用法\n&lt;script&gt; 标签有以下两种使用方式：\n - 直接在页面中嵌入 JavaScript 代码\n - 包含外部 JavaScript 文件【**推荐做法**】\n\n### 直接嵌入 JavaScript 代码\n\n在使用 &lt;script&gt;元素嵌入 JavaScript 代码时，只需为 &lt;script&gt; 指定 **type属性**，然后将 JavaScript 代码放入元素内部即可。\n\n> 注意：\n>  1. 包含在 &lt;script&gt; 元素内部的 JavaScript 代码将被 **从上至下** 依次解释。\n>  2. 在解释器对 &lt;script&gt; 元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。\n\n\n### 包含外部 JavaScript 文件\n\n如果要通过 &lt;script&gt; 元素来包含外部 JavaScript 文件，则需指定 **src 属性**，该属性值是一个指向外部 JavaScript 文件的链接。\n\n> 注意：\n>  1. 在解析（包括下载）外部 JavaScript 文件时，页面的处理会暂时停止。\n>  2. src 属性可指向当前 **HTML 页面所在域之外**的某个域中的完整 URL。\n\n<br/>\n## script 标签的位置\n传统的做法是将所有 &lt;script&gt; 元素都放在页面的 **&lt;head&gt; 元素中**，目的是把所有对外部文件（包括 CSS 文件和 JavaScript 文件）的引用都放在相同的地方。\n\n由于浏览器通常在遇到 &lt;body&gt; 标签时才开始呈现页面内容，为了减少浏览器呈现页面的延迟，现代 Web应用程序 一般会把全部 JavaScript 引用放在 **&lt;body&gt; 元素**中**页面内容的后面**。\n\n<br/>\n## 文档模式\n文档模式通过使用文档类型（doctype）切换实现，共有三种：\n\n - 混杂模式 quirks mode （默认）\n - **标准模式** standards mode\n - **准标准模式** almost standards mode\n\n使用 HTML5 指定 *标准模式*  方法如下：\n\n```html\n<!-- HTML5 -->\n<DOCTYPE html>\n```\n\n<br/>\n## noscript 元素\n\n使用 &lt;noscript&gt; 元素可以在以下情况下，指定浏览器中显示的替代内容，实现平稳退化：\n\n - 浏览器不支持脚本\n - 浏览器支持脚本，但脚本被禁用\n\n\n<br/>\n<br/>\n<br/>\n\n# JavaScript 基本概念\n\n<br/>\n## 标识符\n指 变量、函数、属性的名字，或者 函数的参数，可以是按下列规则组合起来的 一个或多个字符：\n\n - **首字符** 为字母、下划线（_）或 美元符号（$）；\n - 其他字符可以是 字母、下划线、美元符号 或 数字；\n - 采用 **驼峰大小写** 格式。\n\n> 注意：\n> &emsp;&emsp;不能把 关键字、保留字、true、false、null 用作标识符。\n> &emsp;&emsp;**关键字**：\n> &emsp;&emsp;break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with\n> &emsp;&emsp;**保留字**：\n> &emsp;&emsp;abstract, boolean, byte, char, class, const, debugger, double, enum, export, extends, final, float, goto, implements, import, int, interface, long, native, package, private, protected, public, short, static, super, synchronized, throws, transient, volatile\n\n<br/>\n## 注释\n单行注释：\n```javascript\n// 单行注释\n```\n块级注释：\n```javascript\n/*\n * 多行（块级）注释\n */\n```\n\n<br/>\n## 变量\nECMAScript 的变量是**松散类型**的，可以用来保存 **任何类型** 的数据。定义变量时，使用 **var 操作符**，此时定义的变量是 定义该变量的作用域 中的 **局部变量**。省略 var 操作符可以定义全局变量。\n\n```javascript\nvar message; // 未经初始化的变量，值为 undefined\nvar message = 'hi';\n```\n\n<br/>\n## 数据类型\nECMAScript 有 5 种基本数据类型（分别为 Undefined、Null、Boolean、Number 和 String）和 1 种复杂数据类型（Object 类型），不支持任何创建自定义类型的机制。\n\n{% asset_img JS数据类型.png JavaScript数据类型 %}\n\n### Undefined 类型\n仅有一个值 undefined。未经初始化的变量 值为 undefined。一般而言，不需要显式地把一个变量设置为 undefined。\n\n### Null 类型\n仅有一个值 null，表示一个 **空对象指针**。意在保存对象的变量，建议初始化为 null。\n\n### Boolean 类型\n有两个字面值：true 和 false。可以对任何数据类型的值调用 Boolean() 函数，且总会返回一个 Boolean 值。在 **流控制语句**（如 if 语句）中，会 **自动执行** 相应的 **Boolean 转换**。\n各种数据类型对应的 *Boolean转换规则* 如下：\n\n|   数据类型   |  转换为 true 的值              |  转换为 false 的值  |\n|--------------|--------------------------------|---------------------|\n|   Boolean    |   true                         |   false             |\n|   String     |   任何非空字符串               |   \"\" （空字符串）   |\n|   Number     |   任何非零数字值（包括无穷大） |  0 和 NaN           |\n|   Object     |   任何对象                     |   **null**          |\n|   Undefined  |   ——                           |  undefined          |\n\n\n### Number 类型\nNumber 类型采用 IEEE-754 格式表示 整数和浮点数值。其中，**整数** 数值字面量格式可以是 八进制、十进制、十六进制，但在进行算术计算时，统一使用十进制数值。另外，由于 **浮点数值** 所需内存空间是保存整数的两倍，因此，在下列情况下，数值会作为整数值来保存：\n\n - 小数点后没有跟任何数字（如 1.）\n - 浮点数值本身表示的就是一个整数（如 10.0）\n\n对于 **极大** 或 **极小（小数点后有6个以上的0）** 的数值，可使用 **e表示法** 表示。\n\n{% asset_img number类型.png Number 类型 %}\n\n其中，**转型函数 Number()** 的*转换规则*  如下：\n\n > - Boolean 值 true 和 false 分别返回 1 和 0；\n > - 数字值 只是简单的传入和返回；\n > - null 值返回 0；\n > - undefined 值返回 NaN；\n > - 对于 字符串：\n > \t1. 只包含 数字，则将其转换为 十进制数；\n > \t2. 包含 有效的浮点格式，则转换为对应的 浮点数值；\n > \t3. 包含 有效的十六进制格式，则转换为相同大小的十进制整数；\n > \t4. 空字符串 转换为 0；\n > \t5. 包含除上述格式之外的字符，转换为 NaN；\n > - 对于 对象，先调用 valueOf() 并转换，若转换结果为 NaN，再调用 toString() 方法并进行转换。\n\n\n在处理 整数 时，我们常用 **parseInt() 函数**，对于字符串，其 *转换规则*  如下：\n\n > - 从 第一个非空格字符 开始转换（始终忽略前导零）；\n > - 若第一个字符不是 数字字符 或 负号，则返回 NaN（即 parseInt() 对空字符串返回 NaN）；\n > - 解析过程 直到完成所有后续字符 或 遇到非数字字符；\n > - 为避免转换过程中，由整数的进制问题导致错误，建议使用时在 parseInt() 的第二个参数中 明确指定基数。\n\n\n对于 **parseFloat() 函数**，转换规则与 parseInt() 类似，*不同点* 如下：\n\n > - 字符串中 第一个小数点 有效；\n > - 只解析 十进制值；\n > - 若字符串包含的是可解析为整数的数，则返回整数。\n\n\n### String 类型\n\nString 类型用于表示由零或多个 16位 Unicode字符 组成的字符序列，即字符串。\n\n{% asset_img string类型.png String 类型 %}\n\n对于 **转型函数 toString()** ，可用于 数值、布尔值、对象和字符串值，其中，在调用数值的 toString() 方法时，可传递一个参数：输出数值的基数（默认十进制）。\n&emsp;&emsp;由于 null 和 undefined 值没有 toString() 方法，在不确定要转换的值是否为 null 或 undefined 时，可使用 **转型函数 String()**，该函数可将任何类型的值转换为字符串，*转换规则* 如下：\n\n - 该值有 toString()  方法，则调用该方法并返回相应结果；\n - 值为 null，则返回 \"null\"；\n - 值为 undefined，则返回 \"undefined\"。\n\n\n### Object 类型\n\nECMAScript 中的对象 其实就是一组数据和功能的集合。Object 类型是所有它的实例的基础。Object 的每个实例 都具有下列属性和方法：\n\n - **constructor**：保存着 用于创建当前对象的函数；\n - **hasOwnProperty( propertyName )**：用于检查 给定的属性 在当前对象实例中是否存在；\n - **isPrototypeOf( object )**：用于检查 传入的对象是否是当前对象的原型；\n - **propertyIsEnumerable( propertyName )**： 用于检查 给定的属性是否可使用 for-in 语句；\n - **toLocaleString()** ：返回对象的 字符串表示，该字符串与执行环境的地区对应；\n - **toString()** ：返回对象的 字符串表示；\n - **valueOf()** ：返回对象的 字符串、数值 或 布尔值 表示。\n\n\n### typeof 操作符\n\ntypeof 操作符用于检测 给定变量的数据类型。对一个值使用 typeof 操作符可能返回下列某个字符串：\n\n - **\"undefined\"** —— 值 **未定义**，或 变量**未初始化**；\n - **\"boolean\"** —— 值是 布尔值；\n - **\"string\"** —— 值是 字符串；\n - **\"number\"** —— 值为 数值；\n - **\"object\"** —— 值为 对象 或 **null**；\n - **\"function\"** —— 值为 函数。\n\n\n<br/>\n## 操作符\n\nECMAScript 规定的操作符有以下 10 种：\n\n{% asset_img 操作符.png JS操作符 %}\n\n### 一元操作符：\n\n{% asset_img 一元操作符.png 一元操作符 %}\n\n### 位操作符：\n\n{% asset_img 位操作符.png 位操作符 %}\n\n### 布尔操作符：\n\n{% asset_img 布尔操作符.png 布尔操作符 %}\n\n### 乘性操作符：\n\n{% asset_img 乘性操作符.png 乘性操作符 %}\n\n### 加性操作符：\n\n{% asset_img 加性操作符.png 加性操作符 %}\n\n### 关系操作符：\n\n{% asset_img 关系操作符.png 关系操作符 %}\n\n### 相等操作符：\n\n{% asset_img 相等操作符.png 相等操作符 %}\n\n### 条件操作符：\n\n条件操作符 语法如下：\n\n```javascript\nvalue = boolean_expression ? true_value : false_value ;\n```\n\n### 赋值操作符：\n\n{% asset_img 赋值操作符.png 赋值操作符 %}\n\n### 逗号操作符：\n\n逗号操作符 多用于：\n1. 声明多个变量；\n2. 赋值（返回表达式中最后一项）\n\n\n<br/>\n## 流控制语句\n\nEXMAScript 规定的语句有以下几种：\n\n{% asset_img JS语句.png JS语句 %}\n\n### if 语句\n\n```javascript\nif (condition) statement1 else statement2\n\nif (condition1) {\n\t// statement1\n} else if (condition2) {\n\t// statement2\n} else {\n\t// statement3\n}\n```\n\n### do-while 语句\n循环体内的代码至少会被执行一次（后测试循环语句）。\n```javascript\ndo {\n\t// statement\n} while (expression);\n```\n\n### while 语句\n循环体内的代码有可能永远不会被执行（前测试语句）。\n\n```javascript\nwhile (expression) statement\n```\n\n### for 语句\n前测试循环语句。\n\n```javascript\nfor (initialization; expression; post-loop-expression) {\n\t// statement\n}\n```\n\n### for-in 语句\nfor-in 语句用来 枚举对象的属性。通过 for-in 循环输出的属性名的顺序是不可预测的。另外，建议在使用 for-in 循环之前，先检测确认该对象的值 不是 null 或 undefined。\n\n```javascript\nfor (property in expression) {\n\t// statement\n}\n```\n\n### label 语句\n使用 label 语句可以在代码中添加标签。加标签的语句一般与 for 语句、break 和 continue 语句等联合使用，从而在执行中返回 代码特定位置（这种联合使用 多发生在 **嵌套循环** 的情况下）。\n如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。\n\n```javascript\nlabel: statement\n```\n\n### with 语句\nwith 语句用于将代码的作用域设置到一个特定的对象中，以简化多次编写同一个对象的工作。【不建议使用】\n代码示例如下：\n\n```javascript\nwith(location) {\n\tvar qs = search.substring(1); // 即 location.search.substring\n\tvar hostName = hostname;\n\tvar url = href;\n}\n```\n\n### switch 语句\n当有多个判别条件时，可以使用 switch 语句。在 switch 语句中可以使用任何数据类型，每个 case 的值也可以是 常量、变量或表达式。需要注意的是，switch 语句在比较值时，使用的是 **全等操作符**。\n\n```javascript\nswitch (expression) {\n\tcase value: statement\n\t\tbreak;\n\tcase value: statement\n\t\tbreak;\n\tdefault: statement\n}\n```\n\n<br/>\n## 函数\n\n函数的基本语法如下：\n\n```javascript\nfunction functionName (arg0, arg1, ..., argN) {\n\tstatements\n}\n```\n\n**关于 return 语句：**\n\n - 任何函数 在任何时候 都可通过 return语句后跟要返回的值 来实现返回值；\n - 函数在定义时不必指定是否返回值（未指定返回值的函数，返回 undefined）；\n - return 语句也可以不带任何返回值；\n - 函数体内 return 语句后的语句不再执行；\n - 要么让函数 **始终都返回一个值**，要么 **永远都不要返回值**【**推荐做法**】\n\n**关于 函数参数：**\n\n - ECMAScript 中的参数在内部使用一个 **数组** 来表示的（也就是说，函数参数 可以有任意个，也可以是任何数据类型）；\n - 在函数体内可通过 **arguments 对象** 来访问该函数的参数数组，从而获取传递给函数的每一个参数；\n - 命名的参数只提供便利，但不是必须的。解析器不会验证命名参数；\n - 通过访问 arguments 对象的 **length 属性**，可获知有多少个参数传递给了函数（也就是说，arguments 对象的长度，由传入的参数个数决定，而非定义函数时的命名参数个数）；\n - arguments 对象 可以与 命名参数 一起使用。其中，arguments 对象的值永远与对应的命名参数保持同步（内存空间相独立，但 **值同步**）；\n - 没传递值的命名参数，将自动被赋予 undefined 值；\n - 参数传递的是 **值**，不可能通过 引用 传递参数。\n\n**关于 函数重载：**\n\n - 由于不存在 **函数签名**（参数类型和数量） 的概念，ECMAScript函数不能重载；\n - 通过检查传入函数中的 参数的类型和数量 并作出不同的反映，可以模拟方法的重载。\n","tags":["JavaScript","JavaScript高级程序设计"]},{"title":"初 · 等待下雪的日子","url":"/2017/11/20/my_first_blog/","content":"\n2017-11-20\n&emsp;&emsp;与你初相见。\n&emsp;&emsp;祝我生日快乐！\n\n喜欢微显萧瑟的冬日气息，一杯热饮，软糯的毛衣，起雾的玻璃窗，干枯的树叶，飘落的雪花，一张口的哈气，还有对除夕的期待，等等等等…… 所有的这些 都成了让人幸福的小因素。\n","tags":["生活"]}]